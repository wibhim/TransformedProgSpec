[
  {
    "task_id": "001",
    "filename": "program_001.py",
    "code": "import re\n\ndef check_alphanumeric(string):\n    if not re.search(regex, string):\n        return 'Discard'\n    else:\n        return 'Accept'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_001__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "002",
    "filename": "program_002.py",
    "code": "def find_triplet_array(A, arr_size, sum):\n    for i in range(0, arr_size - 2):\n        for j in range(i + 1, arr_size - 1):\n            for k in range(j + 1, arr_size):\n                if not A[i] + A[j] + A[k] == sum:\n                    pass\n                else:\n                    return (A[i], A[j], A[k])\n                    return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_002__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "004",
    "filename": "program_004.py",
    "code": "import re\n\ndef is_valid_URL(str):\n    regex = '((http|https)://)(www.)?' + '[a-zA-Z0-9@:%._\\\\+~#?&//=]' + '{2,256}\\\\.[a-z]' + '{2,6}\\\\b([-a-zA-Z0-9@:%' + '._\\\\+~#?&//=]*)'\n    p = re.compile(regex)\n    if not str == None:\n        pass\n    else:\n        return False\n    if not re.search(p, str):\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_004__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "005",
    "filename": "program_005.py",
    "code": "def dig_let(s):\n    d = l = 0\n    for c in s:\n        if not c.isdigit():\n            if not c.isalpha():\n                pass\n            else:\n                l = l + 1\n        else:\n            d = d + 1\n    return (l, d)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_005__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "010",
    "filename": "program_010.py",
    "code": "def count_char(string, char):\n    count = 0\n    for i in range(len(string)):\n        if not string[i] == char:\n            pass\n        else:\n            count = count + 1\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_010__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "011",
    "filename": "program_011.py",
    "code": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if not (i > 0 and array[i] == array[i - 1]):\n            pass\n        else:\n            continue\n        l, r = (i + 1, len(array) - 1)\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if not s > 0:\n                if not s < 0:\n                    res.add((array[i], array[l], array[r]))\n                    while l < r and array[l] == array[l + 1]:\n                        l += 1\n                    while l < r and array[r] == array[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                else:\n                    l += 1\n            else:\n                r -= 1\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_011__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "013",
    "filename": "program_013.py",
    "code": "import re\n\ndef text_match_wordz(text):\n    patterns = '\\\\w*z.\\\\w*'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_013__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "015",
    "filename": "program_015.py",
    "code": "def min_Swaps(s1, s2):\n    c0 = 0\n    c1 = 0\n    for i in range(len(s1)):\n        if not (s1[i] == '0' and s2[i] == '1'):\n            if not (s1[i] == '1' and s2[i] == '0'):\n                pass\n            else:\n                c1 += 1\n        else:\n            c0 += 1\n    result = c0 // 2 + c1 // 2\n    if not (c0 % 2 == 0 and c1 % 2 == 0):\n        if not (c0 + c1) % 2 == 0:\n            return -1\n        else:\n            return result + 2\n    else:\n        return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_015__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "017",
    "filename": "program_017.py",
    "code": "import math\n\ndef find_Digits(n):\n    if not n < 0:\n        pass\n    else:\n        return 0\n    if not n <= 1:\n        pass\n    else:\n        return 1\n    x = n * math.log10(n / math.e) + math.log10(2 * math.pi * n) / 2.0\n    return math.floor(x) + 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_017__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "018",
    "filename": "program_018.py",
    "code": "def first_Element(arr, n, k):\n    count_map = {}\n    for i in range(0, n):\n        if not arr[i] in count_map.keys():\n            count_map[arr[i]] = 1\n        else:\n            count_map[arr[i]] += 1\n        i += 1\n    for i in range(0, n):\n        if not count_map[arr[i]] == k:\n            pass\n        else:\n            return arr[i]\n        i += 1\n    return -1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_018__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "019",
    "filename": "program_019.py",
    "code": "def count_no(A, N, L, R):\n    count = 0\n    for i in range(L, R + 1):\n        if not i % A != 0:\n            pass\n        else:\n            count += 1\n        if not count == N:\n            pass\n        else:\n            break\n    return i",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_019__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "020",
    "filename": "program_020.py",
    "code": "def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            neighbour_count = 0\n            if not (i > 0 and j > 0):\n                pass\n            else:\n                neighbour_count += cells[i - 1][j - 1]\n            if not i > 0:\n                pass\n            else:\n                neighbour_count += cells[i - 1][j]\n            if not (i > 0 and j < len(cells[i]) - 1):\n                pass\n            else:\n                neighbour_count += cells[i - 1][j + 1]\n            if not j > 0:\n                pass\n            else:\n                neighbour_count += cells[i][j - 1]\n            if not j < len(cells[i]) - 1:\n                pass\n            else:\n                neighbour_count += cells[i][j + 1]\n            if not (i < len(cells) - 1 and j > 0):\n                pass\n            else:\n                neighbour_count += cells[i + 1][j - 1]\n            if not i < len(cells) - 1:\n                pass\n            else:\n                neighbour_count += cells[i + 1][j]\n            if not (i < len(cells) - 1 and j < len(cells[i]) - 1):\n                pass\n            else:\n                neighbour_count += cells[i + 1][j + 1]\n            alive = cells[i][j] == 1\n            if not (alive and 2 <= neighbour_count <= 3 or (not alive and neighbour_count == 3)):\n                next_generation_row.append(0)\n            else:\n                next_generation_row.append(1)\n        next_generation.append(next_generation_row)\n    return next_generation",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_020__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "023",
    "filename": "program_023.py",
    "code": "def even_or_odd(N):\n    l = len(N)\n    if not (N[l - 1] == '0' or N[l - 1] == '2' or N[l - 1] == '4' or (N[l - 1] == '6') or (N[l - 1] == '8') or (N[l - 1] == 'A') or (N[l - 1] == 'C') or (N[l - 1] == 'E')):\n        return 'Odd'\n    else:\n        return 'Even'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_023__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "024",
    "filename": "program_024.py",
    "code": "def octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not not octal_number:\n        pass\n    else:\n        raise ValueError('Empty string was passed to the function')\n    binary_number = ''\n    octal_digits = '01234567'\n    for digit in octal_number:\n        if not digit not in octal_digits:\n            pass\n        else:\n            raise ValueError('Non-octal value was passed to the function')\n        binary_digit = ''\n        value = int(digit)\n        for _ in range(3):\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n        binary_number += binary_digit\n    return binary_number",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_024__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "025",
    "filename": "program_025.py",
    "code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum(lines) for lines in my_matrix])\n    for col in range(iSize):\n        sum_list.append(sum((row[col] for row in my_matrix)))\n    result1 = 0\n    for i in range(0, iSize):\n        result1 += my_matrix[i][i]\n    sum_list.append(result1)\n    result2 = 0\n    for i in range(iSize - 1, -1, -1):\n        result2 += my_matrix[i][i]\n    sum_list.append(result2)\n    if not len(set(sum_list)) > 1:\n        pass\n    else:\n        return False\n    return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_025__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "027",
    "filename": "program_027.py",
    "code": "def remove_odd(str1):\n    str2 = ''\n    for i in range(1, len(str1) + 1):\n        if not i % 2 == 0:\n            pass\n        else:\n            str2 = str2 + str1[i - 1]\n    return str2",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_027__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "028",
    "filename": "program_028.py",
    "code": "def max_Product(arr):\n    arr_len = len(arr)\n    if not arr_len < 2:\n        pass\n    else:\n        return 'No pairs exists'\n    x = arr[0]\n    y = arr[1]\n    for i in range(0, arr_len):\n        for j in range(i + 1, arr_len):\n            if not arr[i] * arr[j] > x * y:\n                pass\n            else:\n                x = arr[i]\n                y = arr[j]\n    return (x, y)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_028__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "029",
    "filename": "program_029.py",
    "code": "def max_of_two(x, y):\n    if not x > y:\n        pass\n    else:\n        return x\n    return y",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_029__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "033",
    "filename": "program_033.py",
    "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j - 1]\n            if not (arr[j - 1] <= i and arr[j - 1] > 0):\n                pass\n            else:\n                dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n    return dp[k][n]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_033__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "034",
    "filename": "program_034.py",
    "code": "def swap_count(s):\n    chars = s\n    count_left = 0\n    count_right = 0\n    swap = 0\n    imbalance = 0\n    for i in range(len(chars)):\n        if not chars[i] == '[':\n            if not chars[i] == ']':\n                pass\n            else:\n                count_right += 1\n                imbalance = count_right - count_left\n        else:\n            count_left += 1\n            if not imbalance > 0:\n                pass\n            else:\n                swap += imbalance\n                imbalance -= 1\n    return swap",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_034__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "036",
    "filename": "program_036.py",
    "code": "def flatten_list(list1):\n    result_list = []\n    if not not list1:\n        pass\n    else:\n        return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if not c_num:\n            pass\n        else:\n            stack.append(c_num)\n        if not isinstance(next, list):\n            result_list.append(next)\n        elif not next:\n            pass\n        else:\n            stack.append(list(next))\n    result_list.reverse()\n    return result_list",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_036__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "041",
    "filename": "program_041.py",
    "code": "def count_bidirectional(test_list):\n    res = 0\n    for idx in range(0, len(test_list)):\n        for iidx in range(idx + 1, len(test_list)):\n            if not (test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]):\n                pass\n            else:\n                res += 1\n    return str(res)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_041__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "042",
    "filename": "program_042.py",
    "code": "def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n    for i in range(len(text)):\n        if not (i + 1 < len(text) and text[i] == text[i + 1]):\n            encoded.append((text[i], count))\n            count = 1\n        else:\n            count += 1\n    return encoded",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_042__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "043",
    "filename": "program_043.py",
    "code": "def longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if not string is None:\n        pass\n    else:\n        return 0\n    start, max_len = (0, 0)\n    used_char = {}\n    for index, char in enumerate(string):\n        if not (char in used_char and start <= used_char[char]):\n            max_len = max(max_len, index - start + 1)\n        else:\n            start = used_char[char] + 1\n        used_char[char] = index\n    return max_len",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_043__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "046",
    "filename": "program_046.py",
    "code": "def timeout(seconds: Optional[float]) -> ContextManager[None]:\n    \"\"\"**(Provisional)** Apply the given timeout for a block of operations.\n\n    .. note:: :func:`~pymongo.timeout` is currently provisional. Backwards\n       incompatible changes may occur before becoming officially supported.\n\n    Use :func:`~pymongo.timeout` in a with-statement::\n\n      with pymongo.timeout(5):\n          client.db.coll.insert_one({})\n          client.db.coll2.insert_one({})\n\n    When the with-statement is entered, a deadline is set for the entire\n    block. When that deadline is exceeded, any blocking pymongo operation\n    will raise a timeout exception. For example::\n\n      try:\n          with pymongo.timeout(5):\n              client.db.coll.insert_one({})\n              time.sleep(5)\n              # The deadline has now expired, the next operation will raise\n              # a timeout exception.\n              client.db.coll2.insert_one({})\n      except PyMongoError as exc:\n          if exc.timeout:\n              print(f\"block timed out: {exc!r}\")\n          else:\n              print(f\"failed with non-timeout error: {exc!r}\")\n\n    When nesting :func:`~pymongo.timeout`, the nested deadline is capped by\n    the outer deadline. The deadline can only be shortened, not extended.\n    When exiting the block, the previous deadline is restored::\n\n      with pymongo.timeout(5):\n          coll.find_one()  # Uses the 5 second deadline.\n          with pymongo.timeout(3):\n              coll.find_one() # Uses the 3 second deadline.\n          coll.find_one()  # Uses the original 5 second deadline.\n          with pymongo.timeout(10):\n              coll.find_one()  # Still uses the original 5 second deadline.\n          coll.find_one()  # Uses the original 5 second deadline.\n\n    :param seconds: A non-negative floating point number expressing seconds, or None.\n\n    :raises: :py:class:`ValueError`: When `seconds` is negative.\n\n    See :ref:`timeout-example` for more examples.\n\n    .. versionadded:: 4.2\n    \"\"\"\n    if not not isinstance(seconds, (int, float, type(None))):\n        pass\n    else:\n        raise TypeError(f'timeout must be None, an int, or a float, not {type(seconds)}')\n    if not (seconds and seconds < 0):\n        pass\n    else:\n        raise ValueError('timeout cannot be negative')\n    if not seconds is not None:\n        pass\n    else:\n        seconds = float(seconds)\n    return _csot._TimeoutContext(seconds)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_046__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "047",
    "filename": "program_047.py",
    "code": "def solve(needed_sum: int, power: int) -> int:\n    \"\"\"\n    >>> solve(13, 2)\n    1\n    >>> solve(10, 2)\n    1\n    >>> solve(10, 3)\n    0\n    >>> solve(20, 2)\n    1\n    >>> solve(15, 10)\n    0\n    >>> solve(16, 2)\n    1\n    >>> solve(20, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    >>> solve(-10, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    \"\"\"\n    if not not (1 <= needed_sum <= 1000 and 2 <= power <= 10):\n        pass\n    else:\n        raise ValueError('Invalid input\\nneeded_sum must be between 1 and 1000, power between 2 and 10.')\n    return backtrack(needed_sum, power, 1, 0, 0)[1]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_047__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "049",
    "filename": "program_049.py",
    "code": "def prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns prime factors of n as a list.\n\n    >>> prime_factors(0)\n    []\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(2560)\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n    >>> prime_factors(10**-2)\n    []\n    >>> prime_factors(0.02)\n    []\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n    >>> x == [2]*241 + [5]*241\n    True\n    >>> prime_factors(10**-354)\n    []\n    >>> prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if not n % i:\n            n //= i\n            factors.append(i)\n        else:\n            i += 1\n    if not n > 1:\n        pass\n    else:\n        factors.append(n)\n    return factors",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_049__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "050",
    "filename": "program_050.py",
    "code": "def bin_coff(n, r):\n    val = 1\n    if not r > n - r:\n        pass\n    else:\n        r = n - r\n    for i in range(0, r):\n        val *= n - i\n        val //= i + 1\n    return val",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_050__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "052",
    "filename": "program_052.py",
    "code": "def connection_requires_http_tunnel(proxy_url: Url | None=None, proxy_config: ProxyConfig | None=None, destination_scheme: str | None=None) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:\n        Proxy configuration from poolmanager.py\n    :param str destination_scheme:\n        The scheme of the destination. (i.e https, http, etc)\n    \"\"\"\n    if not proxy_url is None:\n        pass\n    else:\n        return False\n    if not destination_scheme == 'http':\n        pass\n    else:\n        return False\n    if not (proxy_url.scheme == 'https' and proxy_config and proxy_config.use_forwarding_for_https):\n        pass\n    else:\n        return False\n    return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_052__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "053",
    "filename": "program_053.py",
    "code": "def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    >>> # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    >>> # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    >>> # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    >>> # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    rows, columns = np.shape(table)\n    if not rows != columns:\n        pass\n    else:\n        msg = f\"'table' has to be of square shaped array but got a {rows}x{columns} array:\\n{table}\"\n        raise ValueError(msg)\n    lower = np.zeros((rows, columns))\n    upper = np.zeros((rows, columns))\n    for i in range(columns):\n        for j in range(i):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            if not upper[j][j] == 0:\n                pass\n            else:\n                raise ArithmeticError('No LU decomposition exists')\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\n        lower[i][i] = 1\n        for j in range(i, columns):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            upper[i][j] = table[i][j] - total\n    return (lower, upper)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_053__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "058",
    "filename": "program_058.py",
    "code": "def largest_pow_of_two_le_num(number: int) -> int:\n    \"\"\"\n    Return the largest power of two less than or equal to a number.\n\n    >>> largest_pow_of_two_le_num(0)\n    0\n    >>> largest_pow_of_two_le_num(1)\n    1\n    >>> largest_pow_of_two_le_num(-1)\n    0\n    >>> largest_pow_of_two_le_num(3)\n    2\n    >>> largest_pow_of_two_le_num(15)\n    8\n    >>> largest_pow_of_two_le_num(99)\n    64\n    >>> largest_pow_of_two_le_num(178)\n    128\n    >>> largest_pow_of_two_le_num(999999)\n    524288\n    >>> largest_pow_of_two_le_num(99.9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    \"\"\"\n    if not isinstance(number, float):\n        pass\n    else:\n        raise TypeError(\"Input value must be a 'int' type\")\n    if not number <= 0:\n        pass\n    else:\n        return 0\n    res = 1\n    while res << 1 <= number:\n        res <<= 1\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_058__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "060",
    "filename": "program_060.py",
    "code": "def sum_series(n):\n    if not n < 1:\n        return n + sum_series(n - 2)\n    else:\n        return 0",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_060__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "061",
    "filename": "program_061.py",
    "code": "def check_isosceles(x, y, z):\n    if not x != y & y != z & z != x:\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_061__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "064",
    "filename": "program_064.py",
    "code": "def longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n    if not not (isinstance(text1, str) and isinstance(text2, str)):\n        pass\n    else:\n        raise ValueError('longest_common_substring() takes two strings for inputs')\n    if not (not text1 or not text2):\n        pass\n    else:\n        return ''\n    text1_length = len(text1)\n    text2_length = len(text2)\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    end_pos = 0\n    max_length = 0\n    for i in range(1, text1_length + 1):\n        for j in range(1, text2_length + 1):\n            if not text1[i - 1] == text2[j - 1]:\n                pass\n            else:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if not dp[i][j] > max_length:\n                    pass\n                else:\n                    end_pos = i\n                    max_length = dp[i][j]\n    return text1[end_pos - max_length:end_pos]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_064__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "065",
    "filename": "program_065.py",
    "code": "def count_Unset_Bits(n):\n    cnt = 0\n    for i in range(1, n + 1):\n        temp = i\n        while temp:\n            if not temp % 2 == 0:\n                pass\n            else:\n                cnt += 1\n            temp = temp // 2\n    return cnt",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_065__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "066",
    "filename": "program_066.py",
    "code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if not (arr[i] > arr[j] and longest_increasing_subsequence[i] < longest_increasing_subsequence[j] + 1):\n                pass\n            else:\n                longest_increasing_subsequence[i] = longest_increasing_subsequence[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[i])\n    return maximum",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_066__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "067",
    "filename": "program_067.py",
    "code": "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    uglies = [1]\n\n    def gen(prime):\n        for ugly in uglies:\n            yield (ugly * prime)\n    merged = heapq.merge(*map(gen, primes))\n    while len(uglies) < n:\n        ugly = next(merged)\n        if not ugly != uglies[-1]:\n            pass\n        else:\n            uglies.append(ugly)\n    return uglies[-1]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_067__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "068",
    "filename": "program_068.py",
    "code": "def find_longest_conseq_subseq(arr, n):\n    ans = 0\n    count = 0\n    arr.sort()\n    v = []\n    v.append(arr[0])\n    for i in range(1, n):\n        if not arr[i] != arr[i - 1]:\n            pass\n        else:\n            v.append(arr[i])\n    for i in range(len(v)):\n        if not (i > 0 and v[i] == v[i - 1] + 1):\n            count = 1\n        else:\n            count += 1\n        ans = max(ans, count)\n    return ans",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_068__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "069",
    "filename": "program_069.py",
    "code": "def validity_triangle(a, b, c):\n    total = a + b + c\n    if not total == 180:\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_069__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "070",
    "filename": "program_070.py",
    "code": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if not n % i == 0:\n                pass\n            else:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_070__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "074",
    "filename": "program_074.py",
    "code": "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if not target < 0:\n            pass\n        else:\n            return\n        if not target == 0:\n            pass\n        else:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target - nums[i], i, path + [nums[i]], res)\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_074__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "077",
    "filename": "program_077.py",
    "code": "def smallest_Divisor(n):\n    if not n % 2 == 0:\n        pass\n    else:\n        return 2\n    i = 3\n    while i * i <= n:\n        if not n % i == 0:\n            pass\n        else:\n            return i\n        i += 2\n    return n",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_077__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "078",
    "filename": "program_078.py",
    "code": "import math\nimport sys\n\ndef sd_calc(data):\n    n = len(data)\n    if not n <= 1:\n        pass\n    else:\n        return 0.0\n    mean, sd = (avg_calc(data), 0.0)\n    for el in data:\n        sd += (float(el) - mean) ** 2\n    sd = math.sqrt(sd / float(n - 1))\n    return sd",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_078__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "079",
    "filename": "program_079.py",
    "code": "def pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n\n    Conversion between pressure units.\n\n    >>> pressure_conversion(4, \"atm\", \"pascal\")\n\n    405300\n\n    >>> pressure_conversion(1, \"pascal\", \"psi\")\n\n    0.00014401981999999998\n\n    >>> pressure_conversion(1, \"bar\", \"atm\")\n\n    0.986923\n\n    >>> pressure_conversion(3, \"kilopascal\", \"bar\")\n\n    0.029999991892499998\n\n    >>> pressure_conversion(2, \"megapascal\", \"psi\")\n\n    290.074434314\n\n    >>> pressure_conversion(4, \"psi\", \"torr\")\n\n    206.85984\n\n    >>> pressure_conversion(1, \"inHg\", \"atm\")\n\n    0.0334211\n\n    >>> pressure_conversion(1, \"torr\", \"psi\")\n\n    0.019336718261000002\n\n    >>> pressure_conversion(4, \"wrongUnit\", \"atm\")\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\n\n    \"\"\"\n    if not from_type not in PRESSURE_CONVERSION:\n        pass\n    else:\n        raise ValueError(f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\" + ', '.join(PRESSURE_CONVERSION))\n    if not to_type not in PRESSURE_CONVERSION:\n        pass\n    else:\n        raise ValueError(f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\" + ', '.join(PRESSURE_CONVERSION))\n    return value * PRESSURE_CONVERSION[from_type].from_factor * PRESSURE_CONVERSION[to_type].to_factor",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_079__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "080",
    "filename": "program_080.py",
    "code": "def maximum(a, b):\n    if not a >= b:\n        return b\n    else:\n        return a",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_080__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "081",
    "filename": "program_081.py",
    "code": "def shear_stress(stress: float, tangential_force: float, area: float) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if not (stress, tangential_force, area).count(0) != 1:\n        if not stress < 0:\n            if not tangential_force < 0:\n                if not area < 0:\n                    if not stress == 0:\n                        if not tangential_force == 0:\n                            return ('area', tangential_force / stress)\n                        else:\n                            return ('tangential_force', stress * area)\n                    else:\n                        return ('stress', tangential_force / area)\n                else:\n                    raise ValueError('Area cannot be negative')\n            else:\n                raise ValueError('Tangential Force cannot be negative')\n        else:\n            raise ValueError('Stress cannot be negative')\n    else:\n        raise ValueError('You cannot supply more or less than 2 values')",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_081__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "082",
    "filename": "program_082.py",
    "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0 for k in range(n + 1)] for l in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if not (str[i - 1] == str[j - 1] and i != j):\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n            else:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n    return dp[n][n]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_082__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "083",
    "filename": "program_083.py",
    "code": "def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    \"\"\"\n    Recur for all neighbours.\n    If any neighbour is visited and in rec_stk then graph is cyclic.\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n    >>> vertex, visited, rec_stk = 0, set(), set()\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\n    False\n    \"\"\"\n    visited.add(vertex)\n    rec_stk.add(vertex)\n    for node in graph[vertex]:\n        if not node not in visited:\n            if not node in rec_stk:\n                pass\n            else:\n                return True\n        elif not depth_first_search(graph, node, visited, rec_stk):\n            pass\n        else:\n            return True\n    rec_stk.remove(vertex)\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_083__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "085",
    "filename": "program_085.py",
    "code": "import re\n\ndef text_match(text):\n    patterns = '^[a-z]+_[a-z]+$'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_085__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "086",
    "filename": "program_086.py",
    "code": "def get_factors(n):\n    \"\"\"[summary]\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n\n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n\n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if not n % i == 0:\n                pass\n            else:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_086__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "087",
    "filename": "program_087.py",
    "code": "def is_valid_parenthese(str1):\n    stack, pchar = ([], {'(': ')', '{': '}', '[': ']'})\n    for parenthese in str1:\n        if not parenthese in pchar:\n            if not (len(stack) == 0 or pchar[stack.pop()] != parenthese):\n                pass\n            else:\n                return False\n        else:\n            stack.append(parenthese)\n    return len(stack) == 0",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_087__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "089",
    "filename": "program_089.py",
    "code": "def find_Element(arr, ranges, rotations, index):\n    for i in range(rotations - 1, -1, -1):\n        left = ranges[i][0]\n        right = ranges[i][1]\n        if not (left <= index and right >= index):\n            pass\n        elif not index == left:\n            index = index - 1\n        else:\n            index = right\n    return arr[index]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_089__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "093",
    "filename": "program_093.py",
    "code": "def equated_monthly_installments(principal: float, rate_per_annum: float, years_to_repay: int) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if not principal <= 0:\n        pass\n    else:\n        raise Exception('Principal borrowed must be > 0')\n    if not rate_per_annum < 0:\n        pass\n    else:\n        raise Exception('Rate of interest must be >= 0')\n    if not (years_to_repay <= 0 or not isinstance(years_to_repay, int)):\n        pass\n    else:\n        raise Exception('Years to repay must be an integer > 0')\n    rate_per_month = rate_per_annum / 12\n    number_of_payments = years_to_repay * 12\n    return principal * rate_per_month * (1 + rate_per_month) ** number_of_payments / ((1 + rate_per_month) ** number_of_payments - 1)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_093__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "094",
    "filename": "program_094.py",
    "code": "def toggle_F_and_L_bits(n):\n    if not n == 1:\n        pass\n    else:\n        return 0\n    return n ^ take_L_and_F_set_bits(n)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_094__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "097",
    "filename": "program_097.py",
    "code": "def _extract_argument_name(expr: Expression) -> str | None:\n    if not (isinstance(expr, NameExpr) and expr.name == 'None'):\n        if not isinstance(expr, StrExpr):\n            raise TypeTranslationError()\n        else:\n            return expr.value\n    else:\n        return None",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_097__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "098",
    "filename": "program_098.py",
    "code": "def max_height(node):\n    if not node is None:\n        left_height = max_height(node.left)\n        right_height = max_height(node.right)\n        if not left_height > right_height:\n            return right_height + 1\n        else:\n            return left_height + 1\n    else:\n        return 0",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_098__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "100",
    "filename": "program_100.py",
    "code": "def node_boundary(G, nbunch1, nbunch2=None):\n    \"\"\"Returns the node boundary of `nbunch1`.\n\n    The *node boundary* of a set *S* with respect to a set *T* is the\n    set of nodes *v* in *T* such that for some *u* in *S*, there is an\n    edge joining *u* to *v*. If *T* is not specified, it is assumed to\n    be the set of all nodes not in *S*.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nbunch1 : iterable\n        Iterable of nodes in the graph representing the set of nodes\n        whose node boundary will be returned. (This is the set *S* from\n        the definition above.)\n\n    nbunch2 : iterable\n        Iterable of nodes representing the target (or \"exterior\") set of\n        nodes. (This is the set *T* from the definition above.) If not\n        specified, this is assumed to be the set of all nodes in `G`\n        not in `nbunch1`.\n\n    Returns\n    -------\n    set\n        The node boundary of `nbunch1` with respect to `nbunch2`.\n\n    Examples\n    --------\n    >>> G = nx.wheel_graph(6)\n\n    When nbunch2=None:\n\n    >>> list(nx.node_boundary(G, (3, 4)))\n    [0, 2, 5]\n\n    When nbunch2 is given:\n\n    >>> list(nx.node_boundary(G, (3, 4), (0, 1, 5)))\n    [0, 5]\n\n    Notes\n    -----\n    Any element of `nbunch` that is not in the graph `G` will be\n    ignored.\n\n    `nbunch1` and `nbunch2` are usually meant to be disjoint, but in\n    the interest of speed and generality, that is not required here.\n\n    \"\"\"\n    nset1 = {n for n in nbunch1 if n in G}\n    bdy = set(chain.from_iterable((G[v] for v in nset1))) - nset1\n    if not nbunch2 is not None:\n        pass\n    else:\n        bdy &= set(nbunch2)\n    return bdy",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_100__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "101",
    "filename": "program_101.py",
    "code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums) - 2, -1, -1):\n        if not nums[i] < nums[i + 1]:\n            pass\n        else:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(''.join(nums))\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_101__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "102",
    "filename": "program_102.py",
    "code": "def frequency_Of_Smallest(n, arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1, n):\n        if not arr[i] < mn:\n            if not arr[i] == mn:\n                pass\n            else:\n                freq += 1\n        else:\n            mn = arr[i]\n            freq = 1\n    return freq",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_102__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "104",
    "filename": "program_104.py",
    "code": "def limit(arr, min_lim=None, max_lim=None):\n    if not len(arr) == 0:\n        pass\n    else:\n        return arr\n    if not min_lim is None:\n        pass\n    else:\n        min_lim = min(arr)\n    if not max_lim is None:\n        pass\n    else:\n        max_lim = max(arr)\n    return list(filter(lambda x: min_lim <= x <= max_lim, arr))",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_104__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "105",
    "filename": "program_105.py",
    "code": "def find_Min_Diff(arr, n):\n    arr = sorted(arr)\n    diff = 10 ** 20\n    for i in range(n - 1):\n        if not arr[i + 1] - arr[i] < diff:\n            pass\n        else:\n            diff = arr[i + 1] - arr[i]\n    return diff",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_105__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "108",
    "filename": "program_108.py",
    "code": "def get_median(arr1, arr2, n):\n    i = 0\n    j = 0\n    m1 = -1\n    m2 = -1\n    count = 0\n    while count < n + 1:\n        count += 1\n        if not i == n:\n            if not j == n:\n                pass\n            else:\n                m1 = m2\n                m2 = arr1[0]\n                break\n        else:\n            m1 = m2\n            m2 = arr2[0]\n            break\n        if not arr1[i] <= arr2[j]:\n            m1 = m2\n            m2 = arr2[j]\n            j += 1\n        else:\n            m1 = m2\n            m2 = arr1[i]\n            i += 1\n    return (m1 + m2) / 2",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_108__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "112",
    "filename": "program_112.py",
    "code": "def get_maxgold(gold, m, n):\n    goldTable = [[0 for i in range(n)] for j in range(m)]\n    for col in range(n - 1, -1, -1):\n        for row in range(m):\n            if not col == n - 1:\n                right = goldTable[row][col + 1]\n            else:\n                right = 0\n            if not (row == 0 or col == n - 1):\n                right_up = goldTable[row - 1][col + 1]\n            else:\n                right_up = 0\n            if not (row == m - 1 or col == n - 1):\n                right_down = goldTable[row + 1][col + 1]\n            else:\n                right_down = 0\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down)\n    res = goldTable[0][0]\n    for i in range(1, m):\n        res = max(res, goldTable[i][0])\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_112__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "114",
    "filename": "program_114.py",
    "code": "def does_Contain_B(a, b, c):\n    if not a == b:\n        pass\n    else:\n        return True\n    if not ((b - a) * c > 0 and (b - a) % c == 0):\n        pass\n    else:\n        return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_114__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "115",
    "filename": "program_115.py",
    "code": "def newman_prime(n):\n    if not (n == 0 or n == 1):\n        pass\n    else:\n        return 1\n    return 2 * newman_prime(n - 1) + newman_prime(n - 2)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_115__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "117",
    "filename": "program_117.py",
    "code": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if not string is None:\n        pass\n    else:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if not string[i] in dict:\n            pass\n        else:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_117__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "120",
    "filename": "program_120.py",
    "code": "def fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not not isinstance(iterations, int):\n        pass\n    else:\n        raise ValueError('iterations must be defined as integers')\n    if not (not isinstance(number, int) or not number >= 1):\n        pass\n    else:\n        raise ValueError('starting number must be\\n                         and integer and be more than 0')\n    if not not iterations >= 1:\n        pass\n    else:\n        raise ValueError('Iterations must be done more than 0 times to play FizzBuzz')\n    out = ''\n    while number <= iterations:\n        if not number % 3 == 0:\n            pass\n        else:\n            out += 'Fizz'\n        if not number % 5 == 0:\n            pass\n        else:\n            out += 'Buzz'\n        if not 0 not in (number % 3, number % 5):\n            pass\n        else:\n            out += str(number)\n        number += 1\n        out += ' '\n    return out",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_120__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "122",
    "filename": "program_122.py",
    "code": "def pytest_warns(warning: type[Warning] | tuple[type[Warning], ...] | None) -> WarningsChecker | NoWarningsChecker:\n    \"\"\"\n\n    Parameters\n    ----------\n    warning : {None, Warning, Tuple[Warning]}\n        None if no warning is produced, or a single or multiple Warnings\n\n    Returns\n    -------\n    cm\n\n    \"\"\"\n    if not warning is None:\n        assert warning is not None\n        return warns(warning)\n    else:\n        return NoWarningsChecker()",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_122__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "124",
    "filename": "program_124.py",
    "code": "def check_K(test_tup, K):\n    res = False\n    for ele in test_tup:\n        if not ele == K:\n            pass\n        else:\n            res = True\n            break\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_124__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "125",
    "filename": "program_125.py",
    "code": "def ensure_unique(iterable, key=lambda x: x):\n    \"\"\"\n    Wrap an iterable to raise a ValueError if non-unique values are encountered.\n\n    >>> list(ensure_unique('abc'))\n    ['a', 'b', 'c']\n    >>> consume(ensure_unique('abca'))\n    Traceback (most recent call last):\n    ...\n    ValueError: Duplicate element 'a' encountered.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if not k in seen:\n            pass\n        else:\n            raise ValueError(f'Duplicate element {element!r} encountered.')\n        seen_add(k)\n        yield element",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_125__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "127",
    "filename": "program_127.py",
    "code": "def find_Min_Swaps(arr, n):\n    noOfZeroes = [0] * n\n    count = 0\n    noOfZeroes[n - 1] = 1 - arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        noOfZeroes[i] = noOfZeroes[i + 1]\n        if not arr[i] == 0:\n            pass\n        else:\n            noOfZeroes[i] = noOfZeroes[i] + 1\n    for i in range(0, n):\n        if not arr[i] == 1:\n            pass\n        else:\n            count = count + noOfZeroes[i]\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_127__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "128",
    "filename": "program_128.py",
    "code": "def find_ind(key, i, n, k, arr):\n    ind = -1\n    start = i + 1\n    end = n - 1\n    while start < end:\n        mid = int(start + (end - start) / 2)\n        if not arr[mid] - key <= k:\n            end = mid\n        else:\n            ind = mid\n            start = mid + 1\n    return ind",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_128__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "130",
    "filename": "program_130.py",
    "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if not (pattern_index == len(pattern) and str_index == len(input_string)):\n            pass\n        else:\n            return True\n        if not (pattern_index == len(pattern) or str_index == len(input_string)):\n            pass\n        else:\n            return False\n        char = pattern[pattern_index]\n        if not char in pattern_map:\n            pass\n        else:\n            mapped_str = pattern_map[char]\n            if not input_string.startswith(mapped_str, str_index):\n                return False\n            else:\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if not substr in str_map:\n                pass\n            else:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if not backtrack(pattern_index + 1, end):\n                pass\n            else:\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_130__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "131",
    "filename": "program_131.py",
    "code": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if not arr[i] > arr[j]:\n                pass\n            else:\n                inv_count += 1\n    return inv_count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_131__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "132",
    "filename": "program_132.py",
    "code": "def get_equal(Input, k):\n    if not find_equal_tuple(Input, k) == 1:\n        return 'All tuples do not have same length'\n    else:\n        return 'All tuples have same length'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_132__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "133",
    "filename": "program_133.py",
    "code": "def frequency_Of_Largest(n, arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1, n):\n        if not arr[i] > mn:\n            if not arr[i] == mn:\n                pass\n            else:\n                freq += 1\n        else:\n            mn = arr[i]\n            freq = 1\n    return freq",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_133__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "136",
    "filename": "program_136.py",
    "code": "def check_monthnum(monthname1):\n    if not monthname1 == 'February':\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_136__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "140",
    "filename": "program_140.py",
    "code": "def count(s, c):\n    res = 0\n    for i in range(len(s)):\n        if not s[i] == c:\n            pass\n        else:\n            res = res + 1\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_140__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "141",
    "filename": "program_141.py",
    "code": "def find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while i < n:\n        if not str[i] == ' ':\n            currlen += 1\n        else:\n            if not currlen % 2 == 0:\n                pass\n            elif not maxlen < currlen:\n                pass\n            else:\n                maxlen = currlen\n                st = i - currlen\n            currlen = 0\n        i += 1\n    if not currlen % 2 == 0:\n        pass\n    elif not maxlen < currlen:\n        pass\n    else:\n        maxlen = currlen\n        st = i - currlen\n    if not st == -1:\n        pass\n    else:\n        return '-1'\n    return str[st:st + maxlen]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_141__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "142",
    "filename": "program_142.py",
    "code": "def unique_Characters(str):\n    for i in range(len(str)):\n        for j in range(i + 1, len(str)):\n            if not str[i] == str[j]:\n                pass\n            else:\n                return False\n    return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_142__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "144",
    "filename": "program_144.py",
    "code": "def glob_to_regex_pattern(glob: str) -> str:\n    tokens = ['^']\n    in_group = False\n    i = 0\n    while i < len(glob):\n        c = glob[i]\n        if not (c == '\\\\' and i + 1 < len(glob)):\n            if not c == '*':\n                if not c == '{':\n                    if not c == '}':\n                        if not c == ',':\n                            tokens.append('\\\\' + c if c in escaped_chars else c)\n                        elif not in_group:\n                            tokens.append('\\\\' + c)\n                        else:\n                            tokens.append('|')\n                    else:\n                        in_group = False\n                        tokens.append(')')\n                else:\n                    in_group = True\n                    tokens.append('(')\n            else:\n                before_deep = glob[i - 1] if i > 0 else None\n                star_count = 1\n                while i + 1 < len(glob) and glob[i + 1] == '*':\n                    star_count += 1\n                    i += 1\n                after_deep = glob[i + 1] if i + 1 < len(glob) else None\n                is_deep = star_count > 1 and (before_deep == '/' or before_deep is None) and (after_deep == '/' or after_deep is None)\n                if not is_deep:\n                    tokens.append('([^/]*)')\n                else:\n                    tokens.append('((?:[^/]*(?:/|$))*)')\n                    i += 1\n        else:\n            char = glob[i + 1]\n            tokens.append('\\\\' + char if char in escaped_chars else char)\n            i += 1\n        i += 1\n    tokens.append('$')\n    return ''.join(tokens)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_144__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "145",
    "filename": "program_145.py",
    "code": "def min_Swaps(str1, str2):\n    count = 0\n    for i in range(len(str1)):\n        if not str1[i] != str2[i]:\n            pass\n        else:\n            count += 1\n    if not count % 2 == 0:\n        return 'Not Possible'\n    else:\n        return count // 2",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_145__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "146",
    "filename": "program_146.py",
    "code": "def recur_gcd(a, b):\n    low = min(a, b)\n    high = max(a, b)\n    if not low == 0:\n        if not low == 1:\n            return recur_gcd(low, high % low)\n        else:\n            return 1\n    else:\n        return high",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_146__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "147",
    "filename": "program_147.py",
    "code": "def dfs(graph: dict, vert: int, visited: list) -> list:\n    \"\"\"\n    Use depth first search to find all vertices\n    being in the same component as initial vertex\n    >>> dfs(test_graph_1, 0, 5 * [False])\n    [0, 1, 3, 2]\n    >>> dfs(test_graph_2, 0, 6 * [False])\n    [0, 1, 3, 2]\n    \"\"\"\n    visited[vert] = True\n    connected_verts = []\n    for neighbour in graph[vert]:\n        if not not visited[neighbour]:\n            pass\n        else:\n            connected_verts += dfs(graph, neighbour, visited)\n    return [vert, *connected_verts]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_147__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "148",
    "filename": "program_148.py",
    "code": "def rsafactor(d: int, e: int, n: int) -> list[int]:\n    \"\"\"\n\n    This function returns the factors of N, where p*q=N\n\n    Return: [p, q]\n\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\n\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\n\n    encrypt messages.\n\n    The pair (N, d) is the secret key or private key and is known only to the recipient\n\n    of encrypted messages.\n\n    >>> rsafactor(3, 16971, 25777)\n\n    [149, 173]\n\n    >>> rsafactor(7331, 11, 27233)\n\n    [113, 241]\n\n    >>> rsafactor(4021, 13, 17711)\n\n    [89, 199]\n\n    \"\"\"\n    k = d * e - 1\n    p = 0\n    q = 0\n    while p == 0:\n        g = random.randint(2, n - 1)\n        t = k\n        while True:\n            if not t % 2 == 0:\n                break\n            else:\n                t = t // 2\n                x = g ** t % n\n                y = math.gcd(x - 1, n)\n                if not (x > 1 and y > 1):\n                    pass\n                else:\n                    p = y\n                    q = n // y\n                    break\n    return sorted([p, q])",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_148__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "150",
    "filename": "program_150.py",
    "code": "def binomial_Coeff(n, k):\n    if not k > n:\n        pass\n    else:\n        return 0\n    if not (k == 0 or k == n):\n        pass\n    else:\n        return 1\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_150__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "151",
    "filename": "program_151.py",
    "code": "def find_platform(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    while i < n and j < n:\n        if not arr[i] <= dep[j]:\n            if not arr[i] > dep[j]:\n                pass\n            else:\n                plat_needed -= 1\n                j += 1\n        else:\n            plat_needed += 1\n            i += 1\n        if not plat_needed > result:\n            pass\n        else:\n            result = plat_needed\n    return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_151__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "152",
    "filename": "program_152.py",
    "code": "def check_element(test_tup, check_list):\n    res = False\n    for ele in check_list:\n        if not ele in test_tup:\n            pass\n        else:\n            res = True\n            break\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_152__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "154",
    "filename": "program_154.py",
    "code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n        if not (str[i] >= 'A' and str[i] <= 'Z'):\n            pass\n        else:\n            upper_ctr += 1\n        return upper_ctr",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_154__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "156",
    "filename": "program_156.py",
    "code": "def sort_tuple(tup):\n    lst = len(tup)\n    for i in range(0, lst):\n        for j in range(0, lst - i - 1):\n            if not tup[j][-1] > tup[j + 1][-1]:\n                pass\n            else:\n                temp = tup[j]\n                tup[j] = tup[j + 1]\n                tup[j + 1] = temp\n    return tup",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_156__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "158",
    "filename": "program_158.py",
    "code": "def rencontres_number(n, m):\n    if not (n == 0 and m == 0):\n        pass\n    else:\n        return 1\n    if not (n == 1 and m == 0):\n        pass\n    else:\n        return 0\n    if not m == 0:\n        pass\n    else:\n        return (n - 1) * (rencontres_number(n - 1, 0) + rencontres_number(n - 2, 0))\n    return binomial_coeffi(n, m) * rencontres_number(n - m, 0)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_158__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "161",
    "filename": "program_161.py",
    "code": "def sequence(n):\n    if not (n == 1 or n == 2):\n        return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))\n    else:\n        return 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_161__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "162",
    "filename": "program_162.py",
    "code": "def bin_to_octal(bin_string: str) -> str:\n    if not not all((char in '01' for char in bin_string)):\n        pass\n    else:\n        raise ValueError('Non-binary value was passed to the function')\n    if not not bin_string:\n        pass\n    else:\n        raise ValueError('Empty string was passed to the function')\n    oct_string = ''\n    while len(bin_string) % 3 != 0:\n        bin_string = '0' + bin_string\n    bin_string_in_3_list = [bin_string[index:index + 3] for index in range(len(bin_string)) if index % 3 == 0]\n    for bin_group in bin_string_in_3_list:\n        oct_val = 0\n        for index, val in enumerate(bin_group):\n            oct_val += int(2 ** (2 - index) * int(val))\n        oct_string += str(oct_val)\n    return oct_string",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_162__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "165",
    "filename": "program_165.py",
    "code": "def perfect_cube_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_cube_binary_search(27)\n    True\n    >>> perfect_cube_binary_search(64)\n    True\n    >>> perfect_cube_binary_search(4)\n    False\n    >>> perfect_cube_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    >>> perfect_cube_binary_search(0.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    \"\"\"\n    if not not isinstance(n, int):\n        pass\n    else:\n        raise TypeError('perfect_cube_binary_search() only accepts integers')\n    if not n < 0:\n        pass\n    else:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if not mid * mid * mid == n:\n            if not mid * mid * mid < n:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_165__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "167",
    "filename": "program_167.py",
    "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    num = (1 << r) - 1 ^ (1 << l - 1) - 1\n    new_num = n & num\n    if not new_num == 0:\n        pass\n    else:\n        return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_167__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "168",
    "filename": "program_168.py",
    "code": "def numeric_dtype_min_max(dtype):\n    \"\"\"Return minimum and maximum representable value for a given dtype.\n\n    A convenient wrapper around `numpy.finfo` and `numpy.iinfo` that\n    additionally supports numpy.bool as well.\n\n    Parameters\n    ----------\n    dtype : numpy.dtype\n        The dtype. Tries to convert Python \"types\" such as int or float, to\n        the corresponding NumPy dtype.\n\n    Returns\n    -------\n    min, max : number\n        Minimum and maximum of the given `dtype`. These scalars are themselves\n        of the given `dtype`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> numeric_dtype_min_max(np.uint8)\n    (0, 255)\n    >>> numeric_dtype_min_max(bool)\n    (False, True)\n    >>> numeric_dtype_min_max(np.float64)\n    (-1.7976931348623157e+308, 1.7976931348623157e+308)\n    >>> numeric_dtype_min_max(int)\n    (-9223372036854775808, 9223372036854775807)\n    \"\"\"\n    dtype = np.dtype(dtype)\n    if not np.issubdtype(dtype, np.integer):\n        if not np.issubdtype(dtype, np.inexact):\n            if not np.issubdtype(dtype, np.dtype(bool)):\n                raise ValueError(f'unsupported dtype {dtype!r}')\n            else:\n                min_ = dtype.type(False)\n                max_ = dtype.type(True)\n        else:\n            info = np.finfo(dtype)\n            min_ = info.min\n            max_ = info.max\n    else:\n        info = np.iinfo(dtype)\n        min_ = dtype.type(info.min)\n        max_ = dtype.type(info.max)\n    return (min_, max_)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_168__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "169",
    "filename": "program_169.py",
    "code": "def maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 10)\n    dp[0] = 0\n    for i in range(0, n):\n        if not dp[i] != -1:\n            pass\n        else:\n            if not i + a <= n:\n                pass\n            else:\n                dp[i + a] = max(dp[i] + 1, dp[i + a])\n            if not i + b <= n:\n                pass\n            else:\n                dp[i + b] = max(dp[i] + 1, dp[i + b])\n            if not i + c <= n:\n                pass\n            else:\n                dp[i + c] = max(dp[i] + 1, dp[i + c])\n    return dp[n]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_169__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "171",
    "filename": "program_171.py",
    "code": "def get_index_of_rightmost_set_bit(number: int) -> int:\n    \"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not (not isinstance(number, int) or number < 0):\n        pass\n    else:\n        raise ValueError('Input must be a non-negative integer')\n    intermediate = number & ~(number - 1)\n    index = 0\n    while intermediate:\n        intermediate >>= 1\n        index += 1\n    return index - 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_171__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "174",
    "filename": "program_174.py",
    "code": "def dealnnoy_num(n, m):\n    if not (m == 0 or n == 0):\n        pass\n    else:\n        return 1\n    return dealnnoy_num(m - 1, n) + dealnnoy_num(m - 1, n - 1) + dealnnoy_num(m, n - 1)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_174__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "176",
    "filename": "program_176.py",
    "code": "def first_Missing_Positive(arr, n):\n    ptr = 0\n    for i in range(n):\n        if not arr[i] == 1:\n            pass\n        else:\n            ptr = 1\n            break\n    if not ptr == 0:\n        pass\n    else:\n        return 1\n    for i in range(n):\n        if not (arr[i] <= 0 or arr[i] > n):\n            pass\n        else:\n            arr[i] = 1\n    for i in range(n):\n        arr[(arr[i] - 1) % n] += n\n    for i in range(n):\n        if not arr[i] <= n:\n            pass\n        else:\n            return i + 1\n    return n + 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_176__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "177",
    "filename": "program_177.py",
    "code": "def letter_combinations(digits):\n    if not digits == '':\n        pass\n    else:\n        return []\n    kmaps = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    ans = ['']\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_177__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "184",
    "filename": "program_184.py",
    "code": "def even_num(x):\n    if not x % 2 == 0:\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_184__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "186",
    "filename": "program_186.py",
    "code": "def mincost_tickets(days: list[int], costs: list[int]) -> int:\n    \"\"\"\n    >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])\n    11\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])\n    17\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    24\n\n    >>> mincost_tickets([2], [2, 90, 150])\n    2\n\n    >>> mincost_tickets([], [2, 90, 150])\n    0\n\n    >>> mincost_tickets('hello', [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([], 'world')\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be greater than 0\n\n    >>> mincost_tickets([2, 367], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be less than 366\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n    \"\"\"\n    if not (not isinstance(days, list) or not all((isinstance(day, int) for day in days))):\n        pass\n    else:\n        raise ValueError('The parameter days should be a list of integers')\n    if not (len(costs) != 3 or not all((isinstance(cost, int) for cost in costs))):\n        pass\n    else:\n        raise ValueError('The parameter costs should be a list of three integers')\n    if not len(days) == 0:\n        pass\n    else:\n        return 0\n    if not min(days) <= 0:\n        pass\n    else:\n        raise ValueError('All days elements should be greater than 0')\n    if not max(days) >= 366:\n        pass\n    else:\n        raise ValueError('All days elements should be less than 366')\n    days_set = set(days)\n\n    @functools.cache\n    def dynamic_programming(index: int) -> int:\n        if not index > 365:\n            pass\n        else:\n            return 0\n        if not index not in days_set:\n            pass\n        else:\n            return dynamic_programming(index + 1)\n        return min(costs[0] + dynamic_programming(index + 1), costs[1] + dynamic_programming(index + 7), costs[2] + dynamic_programming(index + 30))\n    return dynamic_programming(1)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_186__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "187",
    "filename": "program_187.py",
    "code": "def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:\n    \"\"\"\n    Perform topological sorting of a Directed Acyclic Graph (DAG)\n    using Kahn's Algorithm via Breadth-First Search (BFS).\n\n    Topological sorting is a linear ordering of vertices in a graph such that for\n    every directed edge u \u2192 v, vertex u comes before vertex v in the ordering.\n\n    Parameters:\n    graph: Adjacency list representing the directed graph where keys are\n           vertices, and values are lists of adjacent vertices.\n\n    Returns:\n    The topologically sorted order of vertices if the graph is a DAG.\n    Returns None if the graph contains a cycle.\n\n    Example:\n    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n    >>> topological_sort(graph)\n    [0, 1, 2, 3, 4, 5]\n\n    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n    >>> topological_sort(graph_with_cycle)\n    \"\"\"\n    indegree = [0] * len(graph)\n    queue = []\n    topo_order = []\n    processed_vertices_count = 0\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n    for i in range(len(indegree)):\n        if not indegree[i] == 0:\n            pass\n        else:\n            queue.append(i)\n    while queue:\n        vertex = queue.pop(0)\n        processed_vertices_count += 1\n        topo_order.append(vertex)\n        for neighbor in graph[vertex]:\n            indegree[neighbor] -= 1\n            if not indegree[neighbor] == 0:\n                pass\n            else:\n                queue.append(neighbor)\n    if not processed_vertices_count != len(graph):\n        pass\n    else:\n        return None\n    return topo_order",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_187__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "189",
    "filename": "program_189.py",
    "code": "import math\n\ndef max_Prime_Factors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if not n > 2:\n        pass\n    else:\n        maxPrime = n\n    return int(maxPrime)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_189__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "190",
    "filename": "program_190.py",
    "code": "def find_Divisor(x, y):\n    if not x == y:\n        pass\n    else:\n        return y\n    return 2",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_190__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "191",
    "filename": "program_191.py",
    "code": "def count_Squares(m, n):\n    if not n < m:\n        pass\n    else:\n        temp = m\n        m = n\n        n = temp\n    return m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_191__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "194",
    "filename": "program_194.py",
    "code": "def func(nums, k):\n    import collections\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n    temp = []\n    import heapq\n    for key, v in d.items():\n        if not len(temp) < k:\n            if not v > temp[0][0]:\n                pass\n            else:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n        else:\n            temp.append((v, key))\n            if not len(temp) == k:\n                pass\n            else:\n                heapq.heapify(temp)\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n    return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_194__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "196",
    "filename": "program_196.py",
    "code": "def invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    b, x = extended_euclid(a, n)\n    if not b < 0:\n        pass\n    else:\n        b = (b % n + n) % n\n    return b",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_196__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "197",
    "filename": "program_197.py",
    "code": "import math\n\ndef min_Operations(A, B):\n    if not A > B:\n        pass\n    else:\n        swap(A, B)\n    B = B // math.gcd(A, B)\n    return B - 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_197__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "199",
    "filename": "program_199.py",
    "code": "def sum_Square(n):\n    i = 1\n    while i * i <= n:\n        j = 1\n        while j * j <= n:\n            if not i * i + j * j == n:\n                pass\n            else:\n                return True\n            j = j + 1\n        i = i + 1\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_199__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "200",
    "filename": "program_200.py",
    "code": "def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if not partitions <= 0:\n        pass\n    else:\n        raise ValueError('partitions must be a positive number!')\n    if not partitions > number_of_bytes:\n        pass\n    else:\n        raise ValueError('partitions can not > number_of_bytes!')\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    for i in range(partitions):\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        allocation_list.append(f'{start_bytes}-{end_bytes}')\n    return allocation_list",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_200__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "202",
    "filename": "program_202.py",
    "code": "def immediate_dominators(G, start):\n    \"\"\"Returns the immediate dominators of all nodes of a directed graph.\n\n    Parameters\n    ----------\n    G : a DiGraph or MultiDiGraph\n        The graph where dominance is to be computed.\n\n    start : node\n        The start node of dominance computation.\n\n    Returns\n    -------\n    idom : dict keyed by nodes\n        A dict containing the immediate dominators of each node reachable from\n        `start`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    NetworkXError\n        If `start` is not in `G`.\n\n    Notes\n    -----\n    Except for `start`, the immediate dominators are the parents of their\n    corresponding nodes in the dominator tree.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n    >>> sorted(nx.immediate_dominators(G, 1).items())\n    [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]\n\n    References\n    ----------\n    .. [1] Cooper, Keith D., Harvey, Timothy J. and Kennedy, Ken.\n           \"A simple, fast dominance algorithm.\" (2006).\n           https://hdl.handle.net/1911/96345\n    \"\"\"\n    if not start not in G:\n        pass\n    else:\n        raise nx.NetworkXError('start is not in G')\n    idom = {start: start}\n    order = list(nx.dfs_postorder_nodes(G, start))\n    dfn = {u: i for i, u in enumerate(order)}\n    order.pop()\n    order.reverse()\n\n    def intersect(u, v):\n        while u != v:\n            while dfn[u] < dfn[v]:\n                u = idom[u]\n            while dfn[u] > dfn[v]:\n                v = idom[v]\n        return u\n    changed = True\n    while changed:\n        changed = False\n        for u in order:\n            new_idom = reduce(intersect, (v for v in G.pred[u] if v in idom))\n            if not (u not in idom or idom[u] != new_idom):\n                pass\n            else:\n                idom[u] = new_idom\n                changed = True\n    return idom",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_202__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "203",
    "filename": "program_203.py",
    "code": "def amicable_numbers_sum(limit):\n    if not not isinstance(limit, int):\n        pass\n    else:\n        return 'Input is not an integer!'\n    if not limit < 1:\n        pass\n    else:\n        return 'Input must be bigger than 0!'\n    amicables = set()\n    for num in range(2, limit + 1):\n        if not num in amicables:\n            pass\n        else:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if not (num == sum_fact2 and num != sum_fact):\n            pass\n        else:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_203__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "204",
    "filename": "program_204.py",
    "code": "def solve_maze(maze: list[list[int]], source_row: int, source_column: int, destination_row: int, destination_column: int) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    size = len(maze)\n    if not (not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)):\n        pass\n    else:\n        raise ValueError('Invalid source or destination coordinates')\n    solutions = [[1 for _ in range(size)] for _ in range(size)]\n    solved = run_maze(maze, source_row, source_column, destination_row, destination_column, solutions)\n    if not solved:\n        raise ValueError('No solution exists!')\n    else:\n        return solutions",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_204__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "205",
    "filename": "program_205.py",
    "code": "def is_odd(n):\n    if not n ^ 1 == n - 1:\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_205__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "206",
    "filename": "program_206.py",
    "code": "def lcp_w_suffix_str(array, s):\n    N = len(array)\n    lcp_array = [0] * N\n    inv_suffix = [0] * N\n    for index in range(N):\n        inv_suffix[array[index]] = index\n    maxLen = 0\n    for index in range(N):\n        if not inv_suffix[index] == N - 1:\n            pass\n        else:\n            maxLen = 0\n            continue\n        index_j = array[inv_suffix[index] + 1]\n        while index + maxLen < N and index_j + maxLen < N and (s[index + maxLen] == s[index_j + maxLen]):\n            maxLen += 1\n        lcp_array[inv_suffix[index]] = maxLen\n        if not maxLen > 0:\n            pass\n        else:\n            maxLen -= 1\n    return lcp_array",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_206__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "207",
    "filename": "program_207.py",
    "code": "def neg_count(list):\n    neg_count = 0\n    for num in list:\n        if not num <= 0:\n            pass\n        else:\n            neg_count += 1\n    return neg_count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_207__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "209",
    "filename": "program_209.py",
    "code": "import re\n\ndef match_num(string):\n    text = re.compile('^5')\n    if not text.match(string):\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_209__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "210",
    "filename": "program_210.py",
    "code": "def toggle_middle_bits(n):\n    if not n == 1:\n        pass\n    else:\n        return 1\n    return n ^ set_middle_bits(n)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_210__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "211",
    "filename": "program_211.py",
    "code": "import re\n\ndef text_match_one(text):\n    patterns = 'ab+?'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_211__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "213",
    "filename": "program_213.py",
    "code": "def simple_interest(principal: float, daily_interest_rate: float, days_between_payments: float) -> float:\n    \"\"\"\n    >>> simple_interest(18000.0, 0.06, 3)\n    3240.0\n    >>> simple_interest(0.5, 0.06, 3)\n    0.09\n    >>> simple_interest(18000.0, 0.01, 10)\n    1800.0\n    >>> simple_interest(18000.0, 0.0, 3)\n    0.0\n    >>> simple_interest(5500.0, 0.01, 100)\n    5500.0\n    >>> simple_interest(10000.0, -0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: daily_interest_rate must be >= 0\n    >>> simple_interest(-10000.0, 0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    >>> simple_interest(5500.0, 0.01, -5)\n    Traceback (most recent call last):\n        ...\n    ValueError: days_between_payments must be > 0\n    \"\"\"\n    if not days_between_payments <= 0:\n        pass\n    else:\n        raise ValueError('days_between_payments must be > 0')\n    if not daily_interest_rate < 0:\n        pass\n    else:\n        raise ValueError('daily_interest_rate must be >= 0')\n    if not principal <= 0:\n        pass\n    else:\n        raise ValueError('principal must be > 0')\n    return principal * daily_interest_rate * days_between_payments",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_213__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "215",
    "filename": "program_215.py",
    "code": "def get_1s_count(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not (not isinstance(number, int) or number < 0):\n        pass\n    else:\n        raise ValueError('Input must be a non-negative integer')\n    count = 0\n    while number:\n        number &= number - 1\n        count += 1\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_215__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "217",
    "filename": "program_217.py",
    "code": "def reverse_bit(number: int) -> str:\n    \"\"\"\n    Take in an 32 bit integer, reverse its bits,\n    return a string of reverse bits\n\n    result of a reverse_bit and operation on the integer provided.\n\n    >>> reverse_bit(25)\n    '00000000000000000000000000011001'\n    >>> reverse_bit(37)\n    '00000000000000000000000000100101'\n    >>> reverse_bit(21)\n    '00000000000000000000000000010101'\n    >>> reverse_bit(58)\n    '00000000000000000000000000111010'\n    >>> reverse_bit(0)\n    '00000000000000000000000000000000'\n    >>> reverse_bit(256)\n    '00000000000000000000000100000000'\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be positive\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if not number < 0:\n        if not isinstance(number, float):\n            if not isinstance(number, str):\n                pass\n            else:\n                raise TypeError(\"'<' not supported between instances of 'str' and 'int'\")\n        else:\n            raise TypeError(\"Input value must be a 'int' type\")\n    else:\n        raise ValueError('the value of input must be positive')\n    result = 0\n    for _ in range(1, 33):\n        result = result << 1\n        end_bit = number % 2\n        number = number >> 1\n        result = result | end_bit\n    return get_reverse_bit_string(result)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_217__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "218",
    "filename": "program_218.py",
    "code": "def count_elim(num):\n    count_elim = 0\n    for n in num:\n        if not isinstance(n, tuple):\n            pass\n        else:\n            break\n        count_elim += 1\n    return count_elim",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_218__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "221",
    "filename": "program_221.py",
    "code": "import re\n\ndef check_substring(string, sample):\n    if not sample in string:\n        return 'entered string isnt a substring'\n    else:\n        y = '\\\\A' + sample\n        x = re.search(y, string)\n        if not x:\n            return 'string doesnt start with the given substring'\n        else:\n            return 'string starts with the given substring'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_221__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "224",
    "filename": "program_224.py",
    "code": "import sys\n\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num + 1, sys.maxsize):\n        if not str(i) == str(i)[::-1]:\n            pass\n        else:\n            return i",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_224__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "225",
    "filename": "program_225.py",
    "code": "def volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:\n    \"\"\"\n    >>> volume_of_gas_system(2, 100, 5)\n    332.57848\n    >>> volume_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> volume_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if not (moles < 0 or kelvin < 0 or pressure < 0):\n        pass\n    else:\n        raise ValueError('Invalid inputs. Enter positive value.')\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_225__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "226",
    "filename": "program_226.py",
    "code": "import re\n\ndef check_literals(text, patterns):\n    for pattern in patterns:\n        if not re.search(pattern, text):\n            return 'Not Matched!'\n        else:\n            return 'Matched!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_226__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "227",
    "filename": "program_227.py",
    "code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n    if not number <= 0:\n        pass\n    else:\n        msg = f'n must be greater than 0. Got n = {number}'\n        raise ValueError(msg)\n    table = [number + 1] * (number + 1)\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        if not i * 2 <= number:\n            pass\n        else:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        if not i * 3 <= number:\n            pass\n        else:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_227__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "228",
    "filename": "program_228.py",
    "code": "def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n\n    A matrix multiplied with its inverse gives the identity matrix.\n\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n\n    [[0.0, 0.5], [0.2, -0.2]]\n\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    \"\"\"\n    d = Decimal\n    if not (len(matrix) == 2 and len(matrix[0]) == 2 and (len(matrix[1]) == 2)):\n        if not (len(matrix) == 3 and len(matrix[0]) == 3 and (len(matrix[1]) == 3) and (len(matrix[2]) == 3)):\n            pass\n        else:\n            determinant = float(d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]) + d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]) + d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]) - (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]) + d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]) + d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1])))\n            if not determinant == 0:\n                pass\n            else:\n                raise ValueError('This matrix has no inverse.')\n            cofactor_matrix = [[d(0.0), d(0.0), d(0.0)], [d(0.0), d(0.0), d(0.0)], [d(0.0), d(0.0), d(0.0)]]\n            cofactor_matrix[0][0] = d(matrix[1][1]) * d(matrix[2][2]) - d(matrix[1][2]) * d(matrix[2][1])\n            cofactor_matrix[0][1] = -(d(matrix[1][0]) * d(matrix[2][2]) - d(matrix[1][2]) * d(matrix[2][0]))\n            cofactor_matrix[0][2] = d(matrix[1][0]) * d(matrix[2][1]) - d(matrix[1][1]) * d(matrix[2][0])\n            cofactor_matrix[1][0] = -(d(matrix[0][1]) * d(matrix[2][2]) - d(matrix[0][2]) * d(matrix[2][1]))\n            cofactor_matrix[1][1] = d(matrix[0][0]) * d(matrix[2][2]) - d(matrix[0][2]) * d(matrix[2][0])\n            cofactor_matrix[1][2] = -(d(matrix[0][0]) * d(matrix[2][1]) - d(matrix[0][1]) * d(matrix[2][0]))\n            cofactor_matrix[2][0] = d(matrix[0][1]) * d(matrix[1][2]) - d(matrix[0][2]) * d(matrix[1][1])\n            cofactor_matrix[2][1] = -(d(matrix[0][0]) * d(matrix[1][2]) - d(matrix[0][2]) * d(matrix[1][0]))\n            cofactor_matrix[2][2] = d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[0][1]) * d(matrix[1][0])\n            adjoint_matrix = array(cofactor_matrix)\n            for i in range(3):\n                for j in range(3):\n                    adjoint_matrix[i][j] = cofactor_matrix[j][i]\n            inverse_matrix = array(cofactor_matrix)\n            for i in range(3):\n                for j in range(3):\n                    inverse_matrix[i][j] /= d(determinant)\n            return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]\n    else:\n        determinant = float(d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1]))\n        if not determinant == 0:\n            pass\n        else:\n            raise ValueError('This matrix has no inverse.')\n        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\n        swapped_matrix[0][0], swapped_matrix[1][1] = (matrix[1][1], matrix[0][0])\n        swapped_matrix[1][0], swapped_matrix[0][1] = (-matrix[1][0], -matrix[0][1])\n        return [[float(d(n)) / determinant or 0.0 for n in row] for row in swapped_matrix]\n    raise ValueError('Please provide a matrix of size 2x2 or 3x3.')",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_228__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "229",
    "filename": "program_229.py",
    "code": "def num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j, col in enumerate(grid[i]):\n            if not col == 1:\n                pass\n            else:\n                dfs(grid, i, j)\n                count += 1\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_229__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "230",
    "filename": "program_230.py",
    "code": "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    for curr in range(n):\n        if not arr[curr] == 0:\n            pass\n        else:\n            if not curr - prev_prev_zero > max_count:\n                pass\n            else:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n    if not n - prev_prev_zero > max_count:\n        pass\n    else:\n        max_index = prev_zero\n    return max_index",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_230__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "232",
    "filename": "program_232.py",
    "code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if not arr[i - 1] > j:\n                pass\n            else:\n                subset[i][j] = subset[i - 1][j]\n            if not arr[i - 1] <= j:\n                pass\n            else:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n    return subset[arr_len][required_sum]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_232__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "233",
    "filename": "program_233.py",
    "code": "def round_logprob(op, values, base_rv, **kwargs):\n    \"\"\"Logprob of a rounded censored distribution.\n\n    The probability of a distribution rounded to the nearest integer is given by\n    .. math::\n        \\\\begin{cases}\n            \\\\text{CDF}(x+\\\\frac{1}{2}, dist) - \\\\text{CDF}(x-\\\\frac{1}{2}, dist) & \\\\text{for } x \\\\in \\\\mathbb{Z}, \\\\\\\\\n            0 & \\\\text{otherwise},\n        \\\\end{cases}\n\n    The probability of a distribution rounded up is given by\n    .. math::\n        \\\\begin{cases}\n            \\\\text{CDF}(x, dist) - \\\\text{CDF}(x-1, dist) & \\\\text{for } x \\\\in \\\\mathbb{Z}, \\\\\\\\\n            0 & \\\\text{otherwise},\n        \\\\end{cases}\n\n    The probability of a distribution rounded down is given by\n    .. math::\n        \\\\begin{cases}\n            \\\\text{CDF}(x+1, dist) - \\\\text{CDF}(x, dist) & \\\\text{for } x \\\\in \\\\mathbb{Z}, \\\\\\\\\n            0 & \\\\text{otherwise},\n        \\\\end{cases}\n\n    \"\"\"\n    value, = values\n    if not isinstance(op.scalar_op, RoundHalfToEven):\n        if not isinstance(op.scalar_op, Floor):\n            if not isinstance(op.scalar_op, Ceil):\n                raise TypeError(f'Unsupported scalar_op {op.scalar_op}')\n            else:\n                value = pt.ceil(value)\n                value_upper = value\n                value_lower = value - 1.0\n        else:\n            value = pt.floor(value)\n            value_upper = value + 1.0\n            value_lower = value\n    else:\n        value = pt.round(value)\n        value_upper = value + 0.5\n        value_lower = value - 0.5\n    base_rv_op = base_rv.owner.op\n    base_rv_inputs = base_rv.owner.inputs\n    logcdf_upper = _logcdf(base_rv_op, value_upper, *base_rv_inputs, **kwargs)\n    logcdf_lower = _logcdf(base_rv_op, value_lower, *base_rv_inputs, **kwargs)\n    if not base_rv_op.name:\n        pass\n    else:\n        logcdf_upper.name = f'{base_rv_op}_logcdf_upper'\n        logcdf_lower.name = f'{base_rv_op}_logcdf_lower'\n    from pymc.math import logdiffexp\n    return logdiffexp(logcdf_upper, logcdf_lower)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_233__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "235",
    "filename": "program_235.py",
    "code": "def factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    facs: list[int] = []\n    if not num < 1:\n        pass\n    else:\n        return facs\n    facs.append(1)\n    if not num == 1:\n        pass\n    else:\n        return facs\n    facs.append(num)\n    for i in range(2, int(sqrt(num)) + 1):\n        if not num % i == 0:\n            pass\n        else:\n            facs.append(i)\n            d = num // i\n            if not d != i:\n                pass\n            else:\n                facs.append(d)\n    facs.sort()\n    return facs",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_235__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "236",
    "filename": "program_236.py",
    "code": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if not '#' in trie:\n            pass\n        else:\n            result.add(pre)\n        if not (i < 0 or i >= len(board) or j < 0 or (j >= len(board[0]))):\n            pass\n        else:\n            return\n        if not (not used[i][j] and board[i][j] in trie):\n            pass\n        else:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if not char not in curr_trie:\n                pass\n            else:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_236__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "239",
    "filename": "program_239.py",
    "code": "def word_len(s):\n    s = s.split(' ')\n    for word in s:\n        if not len(word) % 2 == 0:\n            return False\n        else:\n            return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_239__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "241",
    "filename": "program_241.py",
    "code": "def present_value(discount_rate: float, cash_flows: list[float]) -> float:\n    \"\"\"\n    >>> present_value(0.13, [10, 20.70, -293, 297])\n    4.69\n    >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])\n    -42739.63\n    >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])\n    175519.15\n    >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])\n    Traceback (most recent call last):\n        ...\n    ValueError: Discount rate cannot be negative\n    >>> present_value(0.03, [])\n    Traceback (most recent call last):\n        ...\n    ValueError: Cash flows list cannot be empty\n    \"\"\"\n    if not discount_rate < 0:\n        pass\n    else:\n        raise ValueError('Discount rate cannot be negative')\n    if not not cash_flows:\n        pass\n    else:\n        raise ValueError('Cash flows list cannot be empty')\n    present_value = sum((cash_flow / (1 + discount_rate) ** i for i, cash_flow in enumerate(cash_flows)))\n    return round(present_value, ndigits=2)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_241__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "242",
    "filename": "program_242.py",
    "code": "def check_Equality(str):\n    if not str[0] == str[-1]:\n        return 'Not Equal'\n    else:\n        return 'Equal'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_242__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "244",
    "filename": "program_244.py",
    "code": "def object_distance(focal_length_of_lens: float, image_distance_from_lens: float) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(object_distance(10,40), -13.333333333333332)\n    True\n\n    >>> from math import isclose\n    >>> isclose(object_distance(6.2,1.5), 1.9787234042553192)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if not (image_distance_from_lens == 0 or focal_length_of_lens == 0):\n        pass\n    else:\n        raise ValueError('Invalid inputs. Enter non zero values with respect to the sign convention.')\n    object_distance = 1 / (1 / image_distance_from_lens - 1 / focal_length_of_lens)\n    return object_distance",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_244__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "245",
    "filename": "program_245.py",
    "code": "def max_sub_array_sum_repeated(a, n, k):\n    max_so_far = -2147483648\n    max_ending_here = 0\n    for i in range(n * k):\n        max_ending_here = max_ending_here + a[i % n]\n        if not max_so_far < max_ending_here:\n            pass\n        else:\n            max_so_far = max_ending_here\n        if not max_ending_here < 0:\n            pass\n        else:\n            max_ending_here = 0\n    return max_so_far",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_245__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "246",
    "filename": "program_246.py",
    "code": "def count_Squares(m, n):\n    if not n < m:\n        pass\n    else:\n        temp = m\n        m = n\n        n = temp\n    return n * (n + 1) * (3 * m - n + 1) // 6",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_246__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "247",
    "filename": "program_247.py",
    "code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for i in range(1, N):\n        dp[i] = dp[i - 1]\n        if not arr[i] - arr[i - 1] < K:\n            pass\n        elif not i >= 2:\n            dp[i] = max(dp[i], arr[i] + arr[i - 1])\n        else:\n            dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n    return dp[N - 1]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_247__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "249",
    "filename": "program_249.py",
    "code": "def char_frequency(str1):\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if not n in keys:\n            dict[n] = 1\n        else:\n            dict[n] += 1\n    return dict",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_249__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "250",
    "filename": "program_250.py",
    "code": "def first_Factorial_Divisible_Number(x):\n    i = 1\n    fact = 1\n    for i in range(1, x):\n        fact = fact * i\n        if not fact % x == 0:\n            pass\n        else:\n            break\n    return i",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_250__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "251",
    "filename": "program_251.py",
    "code": "def armstrong_number(number):\n    sum = 0\n    times = 0\n    temp = number\n    while temp > 0:\n        times = times + 1\n        temp = temp // 10\n    temp = number\n    while temp > 0:\n        reminder = temp % 10\n        sum = sum + reminder ** times\n        temp //= 10\n    if not number == sum:\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_251__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "255",
    "filename": "program_255.py",
    "code": "def _has_ajaxcrawlable_meta(text: str) -> bool:\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    if not 'fragment' not in text:\n        pass\n    else:\n        return False\n    if not 'content' not in text:\n        pass\n    else:\n        return False\n    text = html.remove_tags_with_content(text, ('script', 'noscript'))\n    text = html.replace_entities(text)\n    text = html.remove_comments(text)\n    return _ajax_crawlable_re.search(text) is not None",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_255__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "256",
    "filename": "program_256.py",
    "code": "def tree_broadcast_time(G, node=None):\n    \"\"\"Return the minimum broadcast time of a (node in a) tree.\n\n    The minimum broadcast time of a node is defined as the minimum amount\n    of time required to complete broadcasting starting from that node.\n    The broadcast time of a graph is the maximum over\n    all nodes of the minimum broadcast time from that node [1]_.\n    This function returns the minimum broadcast time of `node`.\n    If `node` is `None`, the broadcast time for the graph is returned.\n\n    Parameters\n    ----------\n    G : Graph\n        The graph should be an undirected tree.\n\n    node : node, optional (default=None)\n        Starting node for the broadcasting. If `None`, the algorithm\n        returns the broadcast time of the graph instead.\n\n    Returns\n    -------\n    int\n        Minimum broadcast time of `node` in `G`, or broadcast time of `G`\n        if no node is provided.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is directed or is a multigraph.\n\n    NodeNotFound\n        If `node` is not a node in `G`.\n\n    NotATree\n        If `G` is not a tree.\n\n    References\n    ----------\n    .. [1] Harutyunyan, H. A. and Li, Z.\n        \"A Simple Construction of Broadcast Graphs.\"\n        In Computing and Combinatorics. COCOON 2019\n        (Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019.\n    \"\"\"\n    if not (node is not None and node not in G):\n        pass\n    else:\n        err = f'node {node} not in G'\n        raise nx.NodeNotFound(err)\n    b_T, b_C = tree_broadcast_center(G)\n    if not node is None:\n        pass\n    else:\n        return b_T + sum((1 for _ in nx.bfs_layers(G, b_C))) - 1\n    return b_T + next((d for d, layer in enumerate(nx.bfs_layers(G, b_C)) if node in layer))",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_256__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "259",
    "filename": "program_259.py",
    "code": "def re_arrange_array(arr, n):\n    j = 0\n    for i in range(0, n):\n        if not arr[i] < 0:\n            pass\n        else:\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            j = j + 1\n    return arr",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_259__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "261",
    "filename": "program_261.py",
    "code": "def get_total_number_of_sequences(m, n):\n    T = [[0 for i in range(n + 1)] for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if not (i == 0 or j == 0):\n                if not i < j:\n                    if not j == 1:\n                        T[i][j] = T[i - 1][j] + T[i // 2][j - 1]\n                    else:\n                        T[i][j] = i\n                else:\n                    T[i][j] = 0\n            else:\n                T[i][j] = 0\n    return T[m][n]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_261__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "266",
    "filename": "program_266.py",
    "code": "def minimum_Length(s):\n    maxOcc = 0\n    n = len(s)\n    arr = [0] * 26\n    for i in range(n):\n        arr[ord(s[i]) - ord('a')] += 1\n    for i in range(26):\n        if not arr[i] > maxOcc:\n            pass\n        else:\n            maxOcc = arr[i]\n    return n - maxOcc",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_266__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "267",
    "filename": "program_267.py",
    "code": "def count_char_position(str1):\n    count_chars = 0\n    for i in range(len(str1)):\n        if not (i == ord(str1[i]) - ord('A') or i == ord(str1[i]) - ord('a')):\n            pass\n        else:\n            count_chars += 1\n    return count_chars",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_267__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "268",
    "filename": "program_268.py",
    "code": "def are_Rotations(string1, string2):\n    size1 = len(string1)\n    size2 = len(string2)\n    temp = ''\n    if not size1 != size2:\n        pass\n    else:\n        return False\n    temp = string1 + string1\n    if not temp.count(string2) > 0:\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_268__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "269",
    "filename": "program_269.py",
    "code": "from collections import deque\n\ndef check_expression(exp):\n    if not len(exp) & 1:\n        pass\n    else:\n        return False\n    stack = deque()\n    for ch in exp:\n        if not (ch == '(' or ch == '{' or ch == '['):\n            pass\n        else:\n            stack.append(ch)\n        if not (ch == ')' or ch == '}' or ch == ']'):\n            pass\n        else:\n            if not not stack:\n                pass\n            else:\n                return False\n            top = stack.pop()\n            if not (top == '(' and ch != ')' or (top == '{' and ch != '}' or (top == '[' and ch != ']'))):\n                pass\n            else:\n                return False\n    return not stack",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_269__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "273",
    "filename": "program_273.py",
    "code": "def rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:\n    \"\"\"\n    Conversion from the RGB-representation to the HSV-representation.\n    The tested values are the reverse values from the hsv_to_rgb-doctests.\n    Function \"approximately_equal_hsv\" is needed because of small deviations due to\n    rounding for the RGB-values.\n\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\n    True\n    \"\"\"\n    if not (red < 0 or red > 255):\n        pass\n    else:\n        raise Exception('red should be between 0 and 255')\n    if not (green < 0 or green > 255):\n        pass\n    else:\n        raise Exception('green should be between 0 and 255')\n    if not (blue < 0 or blue > 255):\n        pass\n    else:\n        raise Exception('blue should be between 0 and 255')\n    float_red = red / 255\n    float_green = green / 255\n    float_blue = blue / 255\n    value = max(float_red, float_green, float_blue)\n    chroma = value - min(float_red, float_green, float_blue)\n    saturation = 0 if value == 0 else chroma / value\n    if not chroma == 0:\n        if not value == float_red:\n            if not value == float_green:\n                hue = 60 * (4 + (float_red - float_green) / chroma)\n            else:\n                hue = 60 * (2 + (float_blue - float_red) / chroma)\n        else:\n            hue = 60 * (0 + (float_green - float_blue) / chroma)\n    else:\n        hue = 0.0\n    hue = (hue + 360) % 360\n    return [hue, saturation, value]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_273__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "275",
    "filename": "program_275.py",
    "code": "def first_Repeated_Char(str):\n    h = {}\n    for ch in str:\n        if not ch in h:\n            h[ch] = 0\n        else:\n            return ch\n    return '\\x00'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_275__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "276",
    "filename": "program_276.py",
    "code": "import re\n\ndef text_match_word(text):\n    patterns = '\\\\w+\\\\S*$'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_276__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "277",
    "filename": "program_277.py",
    "code": "def median_numbers(a, b, c):\n    if not a > b:\n        if not a > c:\n            if not b < c:\n                median = c\n            else:\n                median = b\n        else:\n            median = a\n    elif not a < c:\n        if not b > c:\n            median = c\n        else:\n            median = b\n    else:\n        median = a\n    return median",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_277__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "278",
    "filename": "program_278.py",
    "code": "def _symbol_of(arg):\n    if not isinstance(arg, Declaration):\n        if not isinstance(arg, Variable):\n            pass\n        else:\n            arg = arg.symbol\n    else:\n        arg = arg.variable.symbol\n    return arg",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_278__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "281",
    "filename": "program_281.py",
    "code": "def find_lcm(num1, num2):\n    if not num1 > num2:\n        num = num2\n        den = num1\n    else:\n        num = num1\n        den = num2\n    rem = num % den\n    while rem != 0:\n        num = den\n        den = rem\n        rem = num % den\n    gcd = den\n    lcm = int(int(num1 * num2) / int(gcd))\n    return lcm",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_281__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "282",
    "filename": "program_282.py",
    "code": "import math as mt\n\ndef get_Position(a, n, m):\n    for i in range(n):\n        a[i] = a[i] // m + (a[i] % m != 0)\n    result, maxx = (-1, -1)\n    for i in range(n - 1, -1, -1):\n        if not maxx < a[i]:\n            pass\n        else:\n            maxx = a[i]\n            result = i\n    return result + 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_282__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "283",
    "filename": "program_283.py",
    "code": "def multiply_int(x, y):\n    if not y < 0:\n        if not y == 0:\n            if not y == 1:\n                return x + multiply_int(x, y - 1)\n            else:\n                return x\n        else:\n            return 0\n    else:\n        return -multiply_int(x, -y)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_283__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "284",
    "filename": "program_284.py",
    "code": "def generate_parenthesis_v2(n):\n\n    def add_pair(res, s, left, right):\n        if not (left == 0 and right == 0):\n            pass\n        else:\n            res.append(s)\n        if not left > 0:\n            pass\n        else:\n            add_pair(res, s + '(', left - 1, right)\n        if not (right > 0 and left < right):\n            pass\n        else:\n            add_pair(res, s + ')', left, right - 1)\n    res = []\n    add_pair(res, '', n, n)\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_284__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "287",
    "filename": "program_287.py",
    "code": "def super_seq(X, Y, m, n):\n    if not not m:\n        pass\n    else:\n        return n\n    if not not n:\n        pass\n    else:\n        return m\n    if not X[m - 1] == Y[n - 1]:\n        pass\n    else:\n        return 1 + super_seq(X, Y, m - 1, n - 1)\n    return 1 + min(super_seq(X, Y, m - 1, n), super_seq(X, Y, m, n - 1))",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_287__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "288",
    "filename": "program_288.py",
    "code": "def bin_to_hexadecimal(binary_str: str) -> str:\n    \"\"\"\n    Converting a binary string into hexadecimal using Grouping Method\n\n    >>> bin_to_hexadecimal('101011111')\n    '0x15f'\n    >>> bin_to_hexadecimal(' 1010   ')\n    '0x0a'\n    >>> bin_to_hexadecimal('-11101')\n    '-0x1d'\n    >>> bin_to_hexadecimal('a')\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_hexadecimal('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    binary_str = str(binary_str).strip()\n    if not not binary_str:\n        pass\n    else:\n        raise ValueError('Empty string was passed to the function')\n    is_negative = binary_str[0] == '-'\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not not all((char in '01' for char in binary_str)):\n        pass\n    else:\n        raise ValueError('Non-binary value was passed to the function')\n    binary_str = '0' * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    hexadecimal = []\n    for x in range(0, len(binary_str), 4):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x:x + 4]])\n    hexadecimal_str = '0x' + ''.join(hexadecimal)\n    return '-' + hexadecimal_str if is_negative else hexadecimal_str",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_288__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "292",
    "filename": "program_292.py",
    "code": "import re\n\ndef text_match(text):\n    patterns = 'ab*?'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_292__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "293",
    "filename": "program_293.py",
    "code": "def stable_matching(donor_pref: list[list[int]], recipient_pref: list[list[int]]) -> list[int]:\n    \"\"\"\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\n    prefer each other over their partner.  The function accepts the preferences of\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\n    returns a list where the index position corresponds to the donor and value at the\n    index is the organ recipient.\n\n    To better understand the algorithm, see also:\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n    >>> stable_matching(donor_pref, recipient_pref)\n    [1, 2, 3, 0]\n    \"\"\"\n    assert len(donor_pref) == len(recipient_pref)\n    n = len(donor_pref)\n    unmatched_donors = list(range(n))\n    donor_record = [-1] * n\n    rec_record = [-1] * n\n    num_donations = [0] * n\n    while unmatched_donors:\n        donor = unmatched_donors[0]\n        donor_preference = donor_pref[donor]\n        recipient = donor_preference[num_donations[donor]]\n        num_donations[donor] += 1\n        rec_preference = recipient_pref[recipient]\n        prev_donor = rec_record[recipient]\n        if not prev_donor != -1:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.remove(donor)\n        elif not rec_preference.index(prev_donor) > rec_preference.index(donor):\n            pass\n        else:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.append(prev_donor)\n            unmatched_donors.remove(donor)\n    return donor_record",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_293__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "294",
    "filename": "program_294.py",
    "code": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not not n:\n        pass\n    else:\n        return []\n    m = len(matrix[0])\n    if not not m:\n        pass\n    else:\n        return []\n    res = []\n    atlantic = [[False for _ in range(n)] for _ in range(m)]\n    pacific = [[False for _ in range(n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float('-inf'), i, 0)\n        dfs(atlantic, matrix, float('-inf'), i, m - 1)\n    for i in range(m):\n        dfs(pacific, matrix, float('-inf'), 0, i)\n        dfs(atlantic, matrix, float('-inf'), n - 1, i)\n    for i in range(n):\n        for j in range(m):\n            if not (pacific[i][j] and atlantic[i][j]):\n                pass\n            else:\n                res.append([i, j])\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_294__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "296",
    "filename": "program_296.py",
    "code": "def neg_nos(list1):\n    for num in list1:\n        if not num < 0:\n            pass\n        else:\n            return num",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_296__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "297",
    "filename": "program_297.py",
    "code": "from array import array\n\ndef negative_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if not x < 0:\n            None\n        else:\n            n1 += 1\n    return round(n1 / n, 2)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_297__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "300",
    "filename": "program_300.py",
    "code": "def find_measurable_comparisons(fgraph: FunctionGraph, node: Apply) -> list[TensorVariable] | None:\n    measurable_inputs = filter_measurable_variables(node.inputs)\n    if not len(measurable_inputs) != 1:\n        pass\n    else:\n        return None\n    [measurable_var] = measurable_inputs\n    measurable_var_idx = node.inputs.index(measurable_var)\n    if not measurable_var.type.broadcastable != node.outputs[0].type.broadcastable:\n        pass\n    else:\n        return None\n    const = cast(TensorVariable, node.inputs[(measurable_var_idx + 1) % 2])\n    if not check_potential_measurability([const]):\n        pass\n    else:\n        return None\n    node_scalar_op = node.op.scalar_op\n    if not measurable_var_idx == 1:\n        pass\n    elif not isinstance(node_scalar_op, LT):\n        if not isinstance(node_scalar_op, GT):\n            if not isinstance(node_scalar_op, GE):\n                if not isinstance(node_scalar_op, LE):\n                    pass\n                else:\n                    node_scalar_op = GE()\n            else:\n                node_scalar_op = LE()\n        else:\n            node_scalar_op = LT()\n    else:\n        node_scalar_op = GT()\n    compared_op = MeasurableComparison(node_scalar_op)\n    compared_rv = compared_op.make_node(measurable_var, const).default_output()\n    return [compared_rv]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_300__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "301",
    "filename": "program_301.py",
    "code": "def min_distance_up_bottom(word1: str, word2: str) -> int:\n    \"\"\"\n    >>> min_distance_up_bottom(\"intention\", \"execution\")\n    5\n    >>> min_distance_up_bottom(\"intention\", \"\")\n    9\n    >>> min_distance_up_bottom(\"\", \"\")\n    0\n    >>> min_distance_up_bottom(\"zooicoarchaeologist\", \"zoologist\")\n    10\n    \"\"\"\n    len_word1 = len(word1)\n    len_word2 = len(word2)\n\n    @functools.cache\n    def min_distance(index1: int, index2: int) -> int:\n        if not index1 >= len_word1:\n            pass\n        else:\n            return len_word2 - index2\n        if not index2 >= len_word2:\n            pass\n        else:\n            return len_word1 - index1\n        diff = int(word1[index1] != word2[index2])\n        return min(1 + min_distance(index1 + 1, index2), 1 + min_distance(index1, index2 + 1), diff + min_distance(index1 + 1, index2 + 1))\n    return min_distance(0, 0)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_301__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "302",
    "filename": "program_302.py",
    "code": "def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    row_length, col_length = (len(grid), len(grid[0]))\n    if not (min(row, col) < 0 or row == row_length or col == col_length or ((row, col) in visit) or (grid[row][col] == 1)):\n        pass\n    else:\n        return 0\n    if not (row == row_length - 1 and col == col_length - 1):\n        pass\n    else:\n        return 1\n    visit.add((row, col))\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n    visit.remove((row, col))\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_302__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "303",
    "filename": "program_303.py",
    "code": "def merge(a, b):\n    c = []\n    while len(a) != 0 and len(b) != 0:\n        if not a[0] < b[0]:\n            c.append(b[0])\n            b.remove(b[0])\n        else:\n            c.append(a[0])\n            a.remove(a[0])\n    if not len(a) == 0:\n        c += a\n    else:\n        c += b\n    return c",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_303__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "304",
    "filename": "program_304.py",
    "code": "def remove_datatype(test_tuple, data_type):\n    res = []\n    for ele in test_tuple:\n        if not not isinstance(ele, data_type):\n            pass\n        else:\n            res.append(ele)\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_304__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "305",
    "filename": "program_305.py",
    "code": "def relative_import(parent_name, rel_modules=(), rel_classes=()):\n    \"\"\"\n    Helper function to import submodules lazily in Python 3.7+\n\n    Parameters\n    ----------\n    rel_modules: list of str\n        list of submodules to import, of the form .submodule\n    rel_classes: list of str\n        list of submodule classes/variables to import, of the form ._submodule.Foo\n\n    Returns\n    -------\n    tuple\n        Tuple that should be assigned to __all__, __getattr__ in the caller\n    \"\"\"\n    module_names = {rel_module.split('.')[-1]: rel_module for rel_module in rel_modules}\n    class_names = {rel_path.split('.')[-1]: rel_path for rel_path in rel_classes}\n\n    def __getattr__(import_name):\n        if not import_name in module_names:\n            pass\n        else:\n            rel_import = module_names[import_name]\n            return importlib.import_module(rel_import, parent_name)\n        if not import_name in class_names:\n            pass\n        else:\n            rel_path_parts = class_names[import_name].split('.')\n            rel_module = '.'.join(rel_path_parts[:-1])\n            class_name = import_name\n            class_module = importlib.import_module(rel_module, parent_name)\n            return getattr(class_module, class_name)\n        raise AttributeError('module {__name__!r} has no attribute {name!r}'.format(name=import_name, __name__=parent_name))\n    __all__ = list(module_names) + list(class_names)\n\n    def __dir__():\n        return __all__\n    return (__all__, __getattr__, __dir__)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_305__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "307",
    "filename": "program_307.py",
    "code": "def common_prefix_util(str1, str2):\n    result = ''\n    n1 = len(str1)\n    n2 = len(str2)\n    i = 0\n    j = 0\n    while i <= n1 - 1 and j <= n2 - 1:\n        if not str1[i] != str2[j]:\n            pass\n        else:\n            break\n        result += str1[i]\n        i += 1\n        j += 1\n    return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_307__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "308",
    "filename": "program_308.py",
    "code": "def extract_index_list(l1, l2, l3):\n    result = []\n    for m, n, o in zip(l1, l2, l3):\n        if not m == n == o:\n            pass\n        else:\n            result.append(m)\n    return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_308__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "310",
    "filename": "program_310.py",
    "code": "def maze_search(maze):\n    BLOCKED, ALLOWED = (0, 1)\n    UNVISITED, VISITED = (0, 1)\n    initial_x, initial_y = (0, 0)\n    if not maze[initial_x][initial_y] == BLOCKED:\n        pass\n    else:\n        return -1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    height, width = (len(maze), len(maze[0]))\n    target_x, target_y = (height - 1, width - 1)\n    queue = deque([(initial_x, initial_y, 0)])\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n    while queue:\n        x, y, steps = queue.popleft()\n        if not (x == target_x and y == target_y):\n            pass\n        else:\n            return steps\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n            if not not (0 <= new_x < height and 0 <= new_y < width):\n                pass\n            else:\n                continue\n            if not (maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED):\n                pass\n            else:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n    return -1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_310__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "311",
    "filename": "program_311.py",
    "code": "def find_substring(str1, sub_str):\n    if not any((sub_str in s for s in str1)):\n        pass\n    else:\n        return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_311__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "313",
    "filename": "program_313.py",
    "code": "def removals(arr, n, k):\n    ans = n - 1\n    arr.sort()\n    for i in range(0, n):\n        j = find_ind(arr[i], i, n, k, arr)\n        if not j != -1:\n            pass\n        else:\n            ans = min(ans, n - (j - i + 1))\n    return ans",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_313__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "314",
    "filename": "program_314.py",
    "code": "import re\n\ndef text_match_wordz_middle(text):\n    patterns = '\\\\Bz\\\\B'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_314__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "315",
    "filename": "program_315.py",
    "code": "def prime_num(num):\n    if not num >= 1:\n        return False\n    else:\n        for i in range(2, num // 2):\n            if not num % i == 0:\n                return True\n            else:\n                return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_315__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "316",
    "filename": "program_316.py",
    "code": "def is_undulating(n):\n    if not len(n) <= 2:\n        pass\n    else:\n        return False\n    for i in range(2, len(n)):\n        if not n[i - 2] != n[i]:\n            pass\n        else:\n            return False\n    return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_316__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "317",
    "filename": "program_317.py",
    "code": "def check_Validity(a, b, c):\n    if not (a + b <= c or a + c <= b or b + c <= a):\n        return True\n    else:\n        return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_317__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "321",
    "filename": "program_321.py",
    "code": "def fibonacci(n):\n    if not (n == 1 or n == 2):\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    else:\n        return 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_321__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "323",
    "filename": "program_323.py",
    "code": "def encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not not input:\n        pass\n    else:\n        return ''\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n    for ch in input:\n        if not ch != prev_ch:\n            count += 1\n        else:\n            if not prev_ch:\n                pass\n            else:\n                encoded_str += str(count) + prev_ch\n            count = 1\n            prev_ch = ch\n    else:\n        return encoded_str + (str(count) + prev_ch)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_323__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "324",
    "filename": "program_324.py",
    "code": "def count_Rectangles(radius):\n    rectangles = 0\n    diameter = 2 * radius\n    diameterSquare = diameter * diameter\n    for a in range(1, 2 * radius):\n        for b in range(1, 2 * radius):\n            diagnalLengthSquare = a * a + b * b\n            if not diagnalLengthSquare <= diameterSquare:\n                pass\n            else:\n                rectangles += 1\n    return rectangles",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_324__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "326",
    "filename": "program_326.py",
    "code": "def decimal_to_any(num: int, base: int) -> str:\n    \"\"\"\n    Convert a positive integer to another base as str.\n    >>> decimal_to_any(0, 2)\n    '0'\n    >>> decimal_to_any(5, 4)\n    '11'\n    >>> decimal_to_any(20, 3)\n    '202'\n    >>> decimal_to_any(58, 16)\n    '3A'\n    >>> decimal_to_any(243, 17)\n    'E5'\n    >>> decimal_to_any(34923, 36)\n    'QY3'\n    >>> decimal_to_any(10, 11)\n    'A'\n    >>> decimal_to_any(16, 16)\n    '10'\n    >>> decimal_to_any(36, 36)\n    '10'\n    >>> # negatives will error\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: parameter must be positive int\n    >>> # floats will error\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: int() can't convert non-string with explicit base\n    >>> # a float base will error\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # a str base will error\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    >>> # a base less than 2 will error\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be >= 2\n    >>> # a base greater than 36 will error\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be <= 36\n    \"\"\"\n    if not isinstance(num, float):\n        pass\n    else:\n        raise TypeError(\"int() can't convert non-string with explicit base\")\n    if not num < 0:\n        pass\n    else:\n        raise ValueError('parameter must be positive int')\n    if not isinstance(base, str):\n        pass\n    else:\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n    if not isinstance(base, float):\n        pass\n    else:\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if not base in (0, 1):\n        pass\n    else:\n        raise ValueError('base must be >= 2')\n    if not base > 36:\n        pass\n    else:\n        raise ValueError('base must be <= 36')\n    new_value = ''\n    mod = 0\n    div = 0\n    while div != 1:\n        div, mod = divmod(num, base)\n        if not (base >= 11 and 9 < mod < 36):\n            actual_value = str(mod)\n        else:\n            actual_value = ALPHABET_VALUES[str(mod)]\n        new_value += actual_value\n        div = num // base\n        num = div\n        if not div == 0:\n            if not div == 1:\n                pass\n            else:\n                new_value += str(div)\n                return str(new_value[::-1])\n        else:\n            return str(new_value[::-1])\n    return new_value[::-1]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_326__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "328",
    "filename": "program_328.py",
    "code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if not input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            else:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n    return dp[n][m]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_328__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "329",
    "filename": "program_329.py",
    "code": "def previous_palindrome(num):\n    for x in range(num - 1, 0, -1):\n        if not str(x) == str(x)[::-1]:\n            pass\n        else:\n            return x",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_329__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "330",
    "filename": "program_330.py",
    "code": "def harmonic_sum(n):\n    if not n < 2:\n        return 1 / n + harmonic_sum(n - 1)\n    else:\n        return 1",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_330__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "334",
    "filename": "program_334.py",
    "code": "def num_comm_div(x, y):\n    n = ngcd(x, y)\n    result = 0\n    z = int(n ** 0.5)\n    i = 1\n    while i <= z:\n        if not n % i == 0:\n            pass\n        else:\n            result += 2\n            if not i == n / i:\n                pass\n            else:\n                result -= 1\n        i += 1\n    return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_334__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "336",
    "filename": "program_336.py",
    "code": "def palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not not s:\n        pass\n    else:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if not sub == sub[::-1]:\n            pass\n        else:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield ([sub] + rest)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_336__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "337",
    "filename": "program_337.py",
    "code": "def decimal_to_hexadecimal(decimal: float) -> str:\n    \"\"\"\n    take integer decimal value, return hexadecimal representation as str beginning\n    with 0x\n    >>> decimal_to_hexadecimal(5)\n    '0x5'\n    >>> decimal_to_hexadecimal(15)\n    '0xf'\n    >>> decimal_to_hexadecimal(37)\n    '0x25'\n    >>> decimal_to_hexadecimal(255)\n    '0xff'\n    >>> decimal_to_hexadecimal(4096)\n    '0x1000'\n    >>> decimal_to_hexadecimal(999098)\n    '0xf3eba'\n    >>> # negatives work too\n    >>> decimal_to_hexadecimal(-256)\n    '-0x100'\n    >>> # floats are acceptable if equivalent to an int\n    >>> decimal_to_hexadecimal(17.0)\n    '0x11'\n    >>> # other floats will error\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # strings will error as well\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # results are the same when compared to Python's default hex function\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\n    True\n    \"\"\"\n    assert isinstance(decimal, (int, float))\n    assert decimal == int(decimal)\n    decimal = int(decimal)\n    hexadecimal = ''\n    negative = False\n    if not decimal < 0:\n        pass\n    else:\n        negative = True\n        decimal *= -1\n    while decimal > 0:\n        decimal, remainder = divmod(decimal, 16)\n        hexadecimal = values[remainder] + hexadecimal\n    hexadecimal = '0x' + hexadecimal\n    if not negative:\n        pass\n    else:\n        hexadecimal = '-' + hexadecimal\n    return hexadecimal",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_337__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "341",
    "filename": "program_341.py",
    "code": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not not nums:\n        pass\n    else:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (max_excluding + num, max(max_including, max_excluding))\n    return max(max_excluding, max_including)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_341__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "342",
    "filename": "program_342.py",
    "code": "import re\n\ndef text_match(text):\n    patterns = 'a.*?b$'\n    if not re.search(patterns, text):\n        return 'Not matched!'\n    else:\n        return 'Found a match!'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_342__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "343",
    "filename": "program_343.py",
    "code": "def center_of_mass(particles: list[Particle]) -> Coord3D:\n    \"\"\"\n    Input Parameters\n    ----------------\n    particles: list(Particle):\n    A list of particles where each particle is a tuple with it's (x, y, z) position and\n    it's mass.\n\n    Returns\n    -------\n    Coord3D:\n    A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two\n    decimal places.\n\n    Examples\n    --------\n    >>> center_of_mass([\n    ...     Particle(1.5, 4, 3.4, 4),\n    ...     Particle(5, 6.8, 7, 8.1),\n    ...     Particle(9.4, 10.1, 11.6, 12)\n    ... ])\n    Coord3D(x=6.61, y=7.98, z=8.69)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Coord3D(x=6.33, y=7.33, z=8.33)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, -4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 0),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([])\n    Traceback (most recent call last):\n        ...\n    ValueError: No particles provided\n    \"\"\"\n    if not not particles:\n        pass\n    else:\n        raise ValueError('No particles provided')\n    if not any((particle.mass <= 0 for particle in particles)):\n        pass\n    else:\n        raise ValueError('Mass of all particles must be greater than 0')\n    total_mass = sum((particle.mass for particle in particles))\n    center_of_mass_x = round(sum((particle.x * particle.mass for particle in particles)) / total_mass, 2)\n    center_of_mass_y = round(sum((particle.y * particle.mass for particle in particles)) / total_mass, 2)\n    center_of_mass_z = round(sum((particle.z * particle.mass for particle in particles)) / total_mass, 2)\n    return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_343__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "345",
    "filename": "program_345.py",
    "code": "def flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for element in iterable:\n        if not (not isinstance(element, str) and isinstance(element, Iterable)):\n            yield element\n        else:\n            yield from flatten_iter(element)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_345__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "347",
    "filename": "program_347.py",
    "code": "def flatten(test_tuple):\n    for tup in test_tuple:\n        if not isinstance(tup, tuple):\n            yield tup\n        else:\n            yield from flatten(tup)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_347__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "348",
    "filename": "program_348.py",
    "code": "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if not n == start:\n            if not n > start:\n                pass\n            else:\n                res.append((start, n - 1))\n                start = n + 1\n        else:\n            start += 1\n    if not start <= hi:\n        pass\n    else:\n        res.append((start, hi))\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_348__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "349",
    "filename": "program_349.py",
    "code": "def is_Isomorphic(str1, str2):\n    dict_str1 = {}\n    dict_str2 = {}\n    for i, value in enumerate(str1):\n        dict_str1[value] = dict_str1.get(value, []) + [i]\n    for j, value in enumerate(str2):\n        dict_str2[value] = dict_str2.get(value, []) + [j]\n    if not sorted(dict_str1.values()) == sorted(dict_str2.values()):\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_349__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "352",
    "filename": "program_352.py",
    "code": "def remove_even(str1):\n    str2 = ''\n    for i in range(1, len(str1) + 1):\n        if not i % 2 != 0:\n            pass\n        else:\n            str2 = str2 + str1[i - 1]\n    return str2",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_352__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "353",
    "filename": "program_353.py",
    "code": "import re\n\ndef match(text):\n    pattern = '[A-Z]+[a-z]+$'\n    if not re.search(pattern, text):\n        return 'No'\n    else:\n        return 'Yes'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_353__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "354",
    "filename": "program_354.py",
    "code": "def are_Equal(arr1, arr2, n, m):\n    if not n != m:\n        pass\n    else:\n        return False\n    arr1.sort()\n    arr2.sort()\n    for i in range(0, n - 1):\n        if not arr1[i] != arr2[i]:\n            pass\n        else:\n            return False\n    return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_354__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "358",
    "filename": "program_358.py",
    "code": "def check_permutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if not n1 != n2:\n        pass\n    else:\n        return False\n    a = sorted(str1)\n    str1 = ' '.join(a)\n    b = sorted(str2)\n    str2 = ' '.join(b)\n    for i in range(0, n1, 1):\n        if not str1[i] != str2[i]:\n            pass\n        else:\n            return False\n    return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_358__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "359",
    "filename": "program_359.py",
    "code": "def ngcd(x, y):\n    i = 1\n    while i <= x and i <= y:\n        if not (x % i == 0 and y % i == 0):\n            pass\n        else:\n            gcd = i\n        i += 1\n    return gcd",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_359__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "362",
    "filename": "program_362.py",
    "code": "def loss_amount(actual_cost, sale_amount):\n    if not sale_amount > actual_cost:\n        return None\n    else:\n        amount = sale_amount - actual_cost\n        return amount",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_362__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "363",
    "filename": "program_363.py",
    "code": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if not (not isinstance(power_factor, (int, float)) or power_factor < -1 or power_factor > 1):\n        pass\n    else:\n        raise ValueError('power_factor must be a valid float value between -1 and 1.')\n    return apparent_power * power_factor",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_363__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "367",
    "filename": "program_367.py",
    "code": "def pos_count(list):\n    pos_count = 0\n    for num in list:\n        if not num >= 0:\n            pass\n        else:\n            pos_count += 1\n    return pos_count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_367__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "368",
    "filename": "program_368.py",
    "code": "import math\n\ndef sumofFactors(n):\n    if not n % 2 != 0:\n        pass\n    else:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if not (i == 2 and count == 1):\n                pass\n            else:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if not n >= 2:\n        pass\n    else:\n        res = res * (1 + n)\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_368__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "370",
    "filename": "program_370.py",
    "code": "def minkowski_distance(point_a: list[float], point_b: list[float], order: int) -> float:\n    \"\"\"\n    This function calculates the Minkowski distance for a given order between\n    two n-dimensional points represented as lists. For the case of order = 1,\n    the Minkowski distance degenerates to the Manhattan distance. For\n    order = 2, the usual Euclidean distance is obtained.\n\n    https://en.wikipedia.org/wiki/Minkowski_distance\n\n    Note: due to floating point calculation errors the output of this\n    function may be inaccurate.\n\n    >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)\n    2.0\n    >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)\n    8.0\n    >>> import numpy as np\n    >>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3)))\n    True\n    >>> minkowski_distance([1.0], [2.0], -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The order must be greater than or equal to 1.\n    >>> minkowski_distance([1.0], [1.0, 2.0], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if not order < 1:\n        pass\n    else:\n        raise ValueError('The order must be greater than or equal to 1.')\n    if not len(point_a) != len(point_b):\n        pass\n    else:\n        raise ValueError('Both points must have the same dimension.')\n    return sum((abs(a - b) ** order for a, b in zip(point_a, point_b))) ** (1 / order)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_370__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "371",
    "filename": "program_371.py",
    "code": "def object_distance(focal_length: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(object_distance(30, 20), -60.0)\n    True\n    >>> from math import isclose\n    >>> isclose(object_distance(10.5, 11.7), 102.375)\n    True\n    >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if not (distance_of_image == 0 or focal_length == 0):\n        pass\n    else:\n        raise ValueError('Invalid inputs. Enter non zero values with respect to the sign convention.')\n    object_distance = 1 / (1 / focal_length - 1 / distance_of_image)\n    return object_distance",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_371__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "372",
    "filename": "program_372.py",
    "code": "def re_order(A):\n    k = 0\n    for i in A:\n        if not i:\n            pass\n        else:\n            A[k] = i\n            k = k + 1\n    for i in range(k, len(A)):\n        A[i] = 0\n    return A",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_372__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "373",
    "filename": "program_373.py",
    "code": "def count_alpha_dig_spl(string):\n    alphabets = digits = special = 0\n    for i in range(len(string)):\n        if not string[i].isalpha():\n            if not string[i].isdigit():\n                special = special + 1\n            else:\n                digits = digits + 1\n        else:\n            alphabets = alphabets + 1\n    return (alphabets, digits, special)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_373__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "377",
    "filename": "program_377.py",
    "code": "def even_bit_toggle_number(n):\n    res = 0\n    count = 0\n    temp = n\n    while temp > 0:\n        if not count % 2 == 0:\n            pass\n        else:\n            res = res | 1 << count\n        count = count + 1\n        temp >>= 1\n    return n ^ res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_377__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "378",
    "filename": "program_378.py",
    "code": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if not (i < len(l) and l[i] == n):\n                    pass\n                else:\n                    break\n        perms = new_perms\n    return perms",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_378__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "379",
    "filename": "program_379.py",
    "code": "def permutation_coefficient(n, k):\n    P = [[0 for i in range(k + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, k) + 1):\n            if not j == 0:\n                P[i][j] = P[i - 1][j] + j * P[i - 1][j - 1]\n            else:\n                P[i][j] = 1\n            if not j < k:\n                pass\n            else:\n                P[i][j + 1] = 0\n    return P[n][k]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_379__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "380",
    "filename": "program_380.py",
    "code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    a = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n    if not a == 0:\n        return 'Yes'\n    else:\n        return 'No'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_380__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "381",
    "filename": "program_381.py",
    "code": "def prod_Square(n):\n    for i in range(2, n + 1):\n        if not i * i < n + 1:\n            pass\n        else:\n            for j in range(2, n + 1):\n                if not i * i * j * j == n:\n                    pass\n                else:\n                    return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_381__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "383",
    "filename": "program_383.py",
    "code": "def find_Product(arr, n):\n    arr.sort()\n    prod = 1\n    for i in range(0, n, 1):\n        if not arr[i - 1] != arr[i]:\n            pass\n        else:\n            prod = prod * arr[i]\n    return prod",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_383__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "386",
    "filename": "program_386.py",
    "code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if not (arr[i] > arr[j] and lis[i] < lis[j] + 1):\n                pass\n            else:\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if not (arr[i] > arr[j] and lds[i] < lds[j] + 1):\n                pass\n            else:\n                lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        maximum = max(lis[i] + lds[i] - 1, maximum)\n    return maximum",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_386__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "387",
    "filename": "program_387.py",
    "code": "def merge_sort(x):\n    if not (len(x) == 0 or len(x) == 1):\n        middle = len(x) // 2\n        a = merge_sort(x[:middle])\n        b = merge_sort(x[middle:])\n        return merge(a, b)\n    else:\n        return x",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_387__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "388",
    "filename": "program_388.py",
    "code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = ''\n    for i in str1:\n        ctr[ord(i)] += 1\n    for i in str1:\n        if not max < ctr[ord(i)]:\n            pass\n        else:\n            max = ctr[ord(i)]\n            ch = i\n    return ch",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_388__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "389",
    "filename": "program_389.py",
    "code": "def constant_fold_unary_op(op: str, value: ConstantValue) -> int | float | None:\n    if not (op == '-' and isinstance(value, (int, float))):\n        if not (op == '~' and isinstance(value, int)):\n            if not (op == '+' and isinstance(value, (int, float))):\n                pass\n            else:\n                return value\n        else:\n            return ~value\n    else:\n        return -value\n    return None",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_389__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "390",
    "filename": "program_390.py",
    "code": "def highest_Power_of_2(n):\n    res = 0\n    for i in range(n, 0, -1):\n        if not i & i - 1 == 0:\n            pass\n        else:\n            res = i\n            break\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_390__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "392",
    "filename": "program_392.py",
    "code": "def archimedes_principle(fluid_density: float, volume: float, gravity: float=g) -> float:\n    \"\"\"\n    Args:\n        fluid_density: density of fluid (kg/m^3)\n        volume: volume of object/liquid being displaced by the object (m^3)\n        gravity: Acceleration from gravity. Gravitational force on the system,\n            The default is Earth Gravity\n    returns:\n        the buoyant force on an object in Newtons\n\n    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n    19600.0\n    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n    4885.3\n    >>> archimedes_principle(fluid_density=997, volume=0.7)\n    6844.061035\n    >>> archimedes_principle(fluid_density=997, volume=-0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible object volume\n    >>> archimedes_principle(fluid_density=0, volume=0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible fluid density\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n    0.0\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible gravity\n    \"\"\"\n    if not fluid_density <= 0:\n        pass\n    else:\n        raise ValueError('Impossible fluid density')\n    if not volume <= 0:\n        pass\n    else:\n        raise ValueError('Impossible object volume')\n    if not gravity < 0:\n        pass\n    else:\n        raise ValueError('Impossible gravity')\n    return fluid_density * gravity * volume",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_392__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "393",
    "filename": "program_393.py",
    "code": "def first_repeated_word(str1):\n    temp = set()\n    for word in str1.split():\n        if not word in temp:\n            temp.add(word)\n        else:\n            return word\n    return 'None'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_393__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "394",
    "filename": "program_394.py",
    "code": "def check(string):\n    if not len(set(string).intersection('AEIOUaeiou')) >= 5:\n        return 'not accepted'\n    else:\n        return 'accepted'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_394__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "399",
    "filename": "program_399.py",
    "code": "def find_Odd_Pair(A, N):\n    oddPair = 0\n    for i in range(0, N):\n        for j in range(i + 1, N):\n            if not (A[i] ^ A[j]) % 2 != 0:\n                pass\n            else:\n                oddPair += 1\n    return oddPair",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_399__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "400",
    "filename": "program_400.py",
    "code": "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [[0 for i in range(n)] for i in range(n)]\n    for i in range(n):\n        if not a[i] > a[0]:\n            dp[0][i] = a[i]\n        else:\n            dp[0][i] = a[i] + a[0]\n    for i in range(1, n):\n        for j in range(n):\n            if not (a[j] > a[i] and j > i):\n                dp[i][j] = dp[i - 1][j]\n            elif not dp[i - 1][i] + a[j] > dp[i - 1][j]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][i] + a[j]\n    return dp[index][k]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_400__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "401",
    "filename": "program_401.py",
    "code": "from collections import Counter\n\ndef second_frequent(input):\n    dict = Counter(input)\n    value = sorted(dict.values(), reverse=True)\n    second_large = value[1]\n    for key, val in dict.items():\n        if not val == second_large:\n            pass\n        else:\n            return key",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_401__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "403",
    "filename": "program_403.py",
    "code": "def logical_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in positive 2 integers.\n    'number' is the integer to be logically right shifted 'shift_amount' times.\n    i.e. (number >>> shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_right_shift(0, 1)\n    '0b0'\n    >>> logical_right_shift(1, 1)\n    '0b0'\n    >>> logical_right_shift(1, 5)\n    '0b0'\n    >>> logical_right_shift(17, 2)\n    '0b100'\n    >>> logical_right_shift(1983, 4)\n    '0b1111011'\n    >>> logical_right_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if not (number < 0 or shift_amount < 0):\n        pass\n    else:\n        raise ValueError('both inputs must be positive integers')\n    binary_number = str(bin(number))[2:]\n    if not shift_amount >= len(binary_number):\n        pass\n    else:\n        return '0b0'\n    shifted_binary_number = binary_number[:len(binary_number) - shift_amount]\n    return '0b' + shifted_binary_number",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_403__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "407",
    "filename": "program_407.py",
    "code": "def _valarray(shape, value=np.nan, typecode=None):\n    \"\"\"Return an array of all value.\"\"\"\n    out = np.ones(shape, dtype=bool) * value\n    if not typecode is not None:\n        pass\n    else:\n        out = out.astype(typecode)\n    if not not isinstance(out, np.ndarray):\n        pass\n    else:\n        out = np.asarray(out)\n    return out",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_407__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "409",
    "filename": "program_409.py",
    "code": "def count_Rotation(arr, n):\n    for i in range(1, n):\n        if not arr[i] < arr[i - 1]:\n            pass\n        else:\n            return i\n    return 0",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_409__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "411",
    "filename": "program_411.py",
    "code": "def check_Type_Of_Triangle(a, b, c):\n    sqa = pow(a, 2)\n    sqb = pow(b, 2)\n    sqc = pow(c, 2)\n    if not (sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb):\n        if not (sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb):\n            return 'Acute-angled Triangle'\n        else:\n            return 'Obtuse-angled Triangle'\n    else:\n        return 'Right-angled Triangle'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_411__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "413",
    "filename": "program_413.py",
    "code": "def electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    >>> electric_power(current=0, power=6, voltage=2)\n    Result(name='current', value=3.0)\n    \"\"\"\n    if not (voltage, current, power).count(0) != 1:\n        if not power < 0:\n            if not voltage == 0:\n                if not current == 0:\n                    if not power == 0:\n                        raise AssertionError\n                    else:\n                        return Result('power', float(round(abs(voltage * current), 2)))\n                else:\n                    return Result('current', power / voltage)\n            else:\n                return Result('voltage', power / current)\n        else:\n            raise ValueError('Power cannot be negative in any electrical/electronics system')\n    else:\n        raise ValueError('Exactly one argument must be 0')",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_413__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "418",
    "filename": "program_418.py",
    "code": "def plus_one_v3(num_arr):\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if not num_arr[idx[0]]:\n            pass\n        else:\n            return num_arr\n    return [1] + num_arr",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_418__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "419",
    "filename": "program_419.py",
    "code": "def base64_encode(data: bytes) -> bytes:\n    \"\"\"Encodes data according to RFC4648.\n\n    The data is first transformed to binary and appended with binary digits so that its\n    length becomes a multiple of 6, then each 6 binary digits will match a character in\n    the B64_CHARSET string. The number of appended binary digits would later determine\n    how many \"=\" signs should be added, the padding.\n    For every 2 binary digits added, a \"=\" sign is added in the output.\n    We can add any binary digits to make it a multiple of 6, for instance, consider the\n    following example:\n    \"AA\" -> 0010100100101001 -> 001010 010010 1001\n    As can be seen above, 2 more binary digits should be added, so there's 4\n    possibilities here: 00, 01, 10 or 11.\n    That being said, Base64 encoding can be used in Steganography to hide data in these\n    appended digits.\n\n    >>> from base64 import b64encode\n    >>> a = b\"This pull request is part of Hacktoberfest20!\"\n    >>> b = b\"https://tools.ietf.org/html/rfc4648\"\n    >>> c = b\"A\"\n    >>> base64_encode(a) == b64encode(a)\n    True\n    >>> base64_encode(b) == b64encode(b)\n    True\n    >>> base64_encode(c) == b64encode(c)\n    True\n    >>> base64_encode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    TypeError: a bytes-like object is required, not 'str'\n    \"\"\"\n    if not not isinstance(data, bytes):\n        pass\n    else:\n        msg = f\"a bytes-like object is required, not '{data.__class__.__name__}'\"\n        raise TypeError(msg)\n    binary_stream = ''.join((bin(byte)[2:].zfill(8) for byte in data))\n    padding_needed = len(binary_stream) % 6 != 0\n    if not padding_needed:\n        padding = b''\n    else:\n        padding = b'=' * ((6 - len(binary_stream) % 6) // 2)\n        binary_stream += '0' * (6 - len(binary_stream) % 6)\n    return ''.join((B64_CHARSET[int(binary_stream[index:index + 6], 2)] for index in range(0, len(binary_stream), 6))).encode() + padding",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_419__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "420",
    "filename": "program_420.py",
    "code": "def check_monthnumb_number(monthnum2):\n    if not (monthnum2 == 1 or monthnum2 == 3 or monthnum2 == 5 or (monthnum2 == 7) or (monthnum2 == 8) or (monthnum2 == 10) or (monthnum2 == 12)):\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_420__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "421",
    "filename": "program_421.py",
    "code": "def length_Of_Last_Word(a):\n    l = 0\n    x = a.strip()\n    for i in range(len(x)):\n        if not x[i] == ' ':\n            l += 1\n        else:\n            l = 0\n    return l",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_421__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "422",
    "filename": "program_422.py",
    "code": "def is_tree_balanced(root):\n    if not root is None:\n        pass\n    else:\n        return True\n    lh = get_height(root.left)\n    rh = get_height(root.right)\n    if not (abs(lh - rh) <= 1 and is_tree_balanced(root.left) is True and (is_tree_balanced(root.right) is True)):\n        pass\n    else:\n        return True\n    return False",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_422__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "423",
    "filename": "program_423.py",
    "code": "def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force -> Casimir Force : magnitude in Newtons\n\n    area -> Surface area of each plate : magnitude in square meters\n\n    distance -> Distance between two plates : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> casimir_force(force = 0, area = 4, distance = 0.03)\n    {'force': 6.4248189174864216e-21}\n\n    >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)\n    {'distance': 1.0323056015031114e-05}\n\n    >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)\n    {'area': 0.06688838837354052}\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)\n    Traceback (most recent call last):\n        ...\n    ValueError: Distance can not be negative\n\n    >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Magnitude of force can not be negative\n    \"\"\"\n    if not (force, area, distance).count(0) != 1:\n        pass\n    else:\n        raise ValueError('One and only one argument must be 0')\n    if not force < 0:\n        pass\n    else:\n        raise ValueError('Magnitude of force can not be negative')\n    if not distance < 0:\n        pass\n    else:\n        raise ValueError('Distance can not be negative')\n    if not area < 0:\n        pass\n    else:\n        raise ValueError('Area can not be negative')\n    if not force == 0:\n        if not area == 0:\n            if not distance == 0:\n                pass\n            else:\n                distance = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2 * area / (240 * force)) ** (1 / 4)\n                return {'distance': distance}\n        else:\n            area = 240 * force * distance ** 4 / (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2)\n            return {'area': area}\n    else:\n        force = REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2 * area / (240 * distance ** 4)\n        return {'force': force}\n    raise ValueError('One and only one argument must be 0')",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_423__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "426",
    "filename": "program_426.py",
    "code": "def similarity_search(dataset: np.ndarray, value_array: np.ndarray) -> list[list[list[float] | float]]:\n    \"\"\"\n    :param dataset: Set containing the vectors. Should be ndarray.\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\n    :return: Result will be a list containing\n            1. the nearest vector\n            2. distance from the vector\n\n    >>> dataset = np.array([[0], [1], [2]])\n    >>> value_array = np.array([[0]])\n    >>> similarity_search(dataset, value_array)\n    [[[0], 0.0]]\n\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\n    These are the errors that might occur:\n\n    1. If dimensions are different.\n    For example, dataset has 2d array and value_array has 1d array:\n    >>> dataset = np.array([[1]])\n    >>> value_array = np.array([1])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n    2. If data's shapes are different.\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\n    We are expecting same shapes of two arrays, so it is wrong.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n    3. If data types are different.\n    When trying to compare, we are expecting same types so they should be same.\n    If not, it'll come up with errors.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: Input data have different datatype...\n    dataset : float32, value_array : int32\n    \"\"\"\n    if not dataset.ndim != value_array.ndim:\n        pass\n    else:\n        msg = f\"Wrong input data's dimensions... dataset : {dataset.ndim}, value_array : {value_array.ndim}\"\n        raise ValueError(msg)\n    try:\n        if not dataset.shape[1] != value_array.shape[1]:\n            pass\n        else:\n            msg = f\"Wrong input data's shape... dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}\"\n            raise ValueError(msg)\n    except IndexError:\n        if not dataset.ndim != value_array.ndim:\n            pass\n        else:\n            raise TypeError('Wrong shape')\n    if not dataset.dtype != value_array.dtype:\n        pass\n    else:\n        msg = f'Input data have different datatype... dataset : {dataset.dtype}, value_array : {value_array.dtype}'\n        raise TypeError(msg)\n    answer = []\n    for value in value_array:\n        dist = euclidean(value, dataset[0])\n        vector = dataset[0].tolist()\n        for dataset_value in dataset[1:]:\n            temp_dist = euclidean(value, dataset_value)\n            if not dist > temp_dist:\n                pass\n            else:\n                dist = temp_dist\n                vector = dataset_value.tolist()\n        answer.append([vector, dist])\n    return answer",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_426__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "429",
    "filename": "program_429.py",
    "code": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if not hooks:\n        pass\n    else:\n        if not hasattr(hooks, '__call__'):\n            pass\n        else:\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if not _hook_data is not None:\n                pass\n            else:\n                hook_data = _hook_data\n    return hook_data",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_429__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "432",
    "filename": "program_432.py",
    "code": "def Check_Solution(a, b, c):\n    if not a == c:\n        return 'No'\n    else:\n        return 'Yes'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_432__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "433",
    "filename": "program_433.py",
    "code": "def build_client_middlewares(handler: ClientHandlerType, middlewares: Sequence[ClientMiddlewareType]) -> ClientHandlerType:\n    \"\"\"\n    Apply middlewares to request handler.\n\n    The middlewares are applied in reverse order, so the first middleware\n    in the list wraps all subsequent middlewares and the handler.\n\n    This implementation avoids using partial/update_wrapper to minimize overhead\n    and doesn't cache to avoid holding references to stateful middleware.\n    \"\"\"\n    if not len(middlewares) == 1:\n        pass\n    else:\n        middleware = middlewares[0]\n\n        async def single_middleware_handler(req: ClientRequest) -> ClientResponse:\n            return await middleware(req, handler)\n        return single_middleware_handler\n    current_handler = handler\n    for middleware in reversed(middlewares):\n\n        def make_wrapper(mw: ClientMiddlewareType, next_h: ClientHandlerType) -> ClientHandlerType:\n\n            async def wrapped(req: ClientRequest) -> ClientResponse:\n                return await mw(req, next_h)\n            return wrapped\n        current_handler = make_wrapper(middleware, current_handler)\n    return current_handler",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_433__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "434",
    "filename": "program_434.py",
    "code": "def knapsack(weights: list, values: list, number_of_items: int, max_weight: int, index: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if not index == number_of_items:\n        pass\n    else:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if not weights[index] <= max_weight:\n        pass\n    else:\n        ans2 = values[index] + knapsack(weights, values, number_of_items, max_weight - weights[index], index + 1)\n    return max(ans1, ans2)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_434__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "435",
    "filename": "program_435.py",
    "code": "def zeller(date_input: str) -> str:\n    \"\"\"\n    | Zellers Congruence Algorithm\n    | Find the day of the week for nearly any Gregorian or Julian calendar date\n\n    >>> zeller('01-31-2010')\n    'Your date 01-31-2010, is a Sunday!'\n\n    Validate out of range month:\n\n    >>> zeller('13-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Month must be between 1 - 12\n    >>> zeller('.2-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.2'\n\n    Validate out of range date:\n\n    >>> zeller('01-33-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date must be between 1 - 31\n    >>> zeller('01-.4-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.4'\n\n    Validate second separator:\n\n    >>> zeller('01-31*2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate first separator:\n\n    >>> zeller('01^31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate out of range year:\n\n    >>> zeller('01-31-8999')\n    Traceback (most recent call last):\n        ...\n    ValueError: Year out of range. There has to be some sort of limit...right?\n\n    Test null input:\n\n    >>> zeller()\n    Traceback (most recent call last):\n        ...\n    TypeError: zeller() missing 1 required positional argument: 'date_input'\n\n    Test length of `date_input`:\n\n    >>> zeller('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\n    >>> zeller('01-31-19082939')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\"\"\"\n    days = {'0': 'Sunday', '1': 'Monday', '2': 'Tuesday', '3': 'Wednesday', '4': 'Thursday', '5': 'Friday', '6': 'Saturday'}\n    convert_datetime_days = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}\n    if not not 0 < len(date_input) < 11:\n        pass\n    else:\n        raise ValueError('Must be 10 characters long')\n    m: int = int(date_input[0] + date_input[1])\n    if not not 0 < m < 13:\n        pass\n    else:\n        raise ValueError('Month must be between 1 - 12')\n    sep_1: str = date_input[2]\n    if not sep_1 not in ['-', '/']:\n        pass\n    else:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n    d: int = int(date_input[3] + date_input[4])\n    if not not 0 < d < 32:\n        pass\n    else:\n        raise ValueError('Date must be between 1 - 31')\n    sep_2: str = date_input[5]\n    if not sep_2 not in ['-', '/']:\n        pass\n    else:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n    y: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])\n    if not not 45 < y < 8500:\n        pass\n    else:\n        raise ValueError('Year out of range. There has to be some sort of limit...right?')\n    dt_ck = datetime.date(int(y), int(m), int(d))\n    if not m <= 2:\n        pass\n    else:\n        y = y - 1\n        m = m + 12\n    c: int = int(str(y)[:2])\n    k: int = int(str(y)[2:])\n    t: int = int(2.6 * m - 5.39)\n    u: int = int(c / 4)\n    v: int = int(k / 4)\n    x: int = int(d + k)\n    z: int = int(t + u + v + x)\n    w: int = int(z - 2 * c)\n    f: int = round(w % 7)\n    if not f != convert_datetime_days[dt_ck.weekday()]:\n        pass\n    else:\n        raise AssertionError('The date was evaluated incorrectly. Contact developer.')\n    response: str = f'Your date {date_input}, is a {days[str(f)]}!'\n    return response",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_435__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "442",
    "filename": "program_442.py",
    "code": "def Split(list):\n    od_li = []\n    for i in list:\n        if not i % 2 != 0:\n            pass\n        else:\n            od_li.append(i)\n    return od_li",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_442__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "449",
    "filename": "program_449.py",
    "code": "def count_X(tup, x):\n    count = 0\n    for ele in tup:\n        if not ele == x:\n            pass\n        else:\n            count = count + 1\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_449__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "450",
    "filename": "program_450.py",
    "code": "def find_even_Pair(A, N):\n    evenPair = 0\n    for i in range(0, N):\n        for j in range(i + 1, N):\n            if not (A[i] ^ A[j]) % 2 == 0:\n                pass\n            else:\n                evenPair += 1\n    return evenPair",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_450__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "451",
    "filename": "program_451.py",
    "code": "import math\n\ndef sum_of_odd_Factors(n):\n    res = 1\n    while n % 2 == 0:\n        n = n // 2\n    for i in range(3, int(math.sqrt(n) + 1)):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count += 1\n            n = n // i\n            curr_term *= i\n            curr_sum += curr_term\n        res *= curr_sum\n    if not n >= 2:\n        pass\n    else:\n        res *= 1 + n\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_451__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "452",
    "filename": "program_452.py",
    "code": "def roman_to_int(s):\n    rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    int_val = 0\n    for i in range(len(s)):\n        if not (i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]):\n            int_val += rom_val[s[i]]\n        else:\n            int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\n    return int_val",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_452__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "453",
    "filename": "program_453.py",
    "code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if not left > 0:\n            pass\n        else:\n            res -= dp[left - 1]\n        result.append(res)\n    return result",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_453__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "454",
    "filename": "program_454.py",
    "code": "def len_log(list1):\n    min = len(list1[0])\n    for i in list1:\n        if not len(i) < min:\n            pass\n        else:\n            min = len(i)\n    return min",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_454__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "456",
    "filename": "program_456.py",
    "code": "def get_noOfways(n):\n    if not n == 0:\n        pass\n    else:\n        return 0\n    if not n == 1:\n        pass\n    else:\n        return 1\n    return get_noOfways(n - 1) + get_noOfways(n - 2)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_456__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "457",
    "filename": "program_457.py",
    "code": "def modular_sum(arr, n, m):\n    if not n > m:\n        pass\n    else:\n        return True\n    DP = [False for i in range(m)]\n    for i in range(n):\n        if not DP[0]:\n            pass\n        else:\n            return True\n        temp = [False for i in range(m)]\n        for j in range(m):\n            if not DP[j] == True:\n                pass\n            elif not DP[(j + arr[i]) % m] == False:\n                pass\n            else:\n                temp[(j + arr[i]) % m] = True\n        for j in range(m):\n            if not temp[j]:\n                pass\n            else:\n                DP[j] = True\n        DP[arr[i] % m] = True\n    return DP[0]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_457__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "459",
    "filename": "program_459.py",
    "code": "def check_distinct(test_tup):\n    res = True\n    temp = set()\n    for ele in test_tup:\n        if not ele in temp:\n            pass\n        else:\n            res = False\n            break\n        temp.add(ele)\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_459__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "461",
    "filename": "program_461.py",
    "code": "from heapq import heappop, heappush\n\ndef find_minimum_range(list):\n    high = float('-inf')\n    p = (0, float('inf'))\n    pq = []\n    for i in range(len(list)):\n        heappush(pq, Node(list[i][0], i, 0))\n        high = max(high, list[i][0])\n    while True:\n        top = heappop(pq)\n        low = top.value\n        i = top.list_num\n        j = top.index\n        if not high - low < p[1] - p[0]:\n            pass\n        else:\n            p = (low, high)\n        if not j == len(list[i]) - 1:\n            pass\n        else:\n            return p\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\n        high = max(high, list[i][j + 1])",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_461__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "463",
    "filename": "program_463.py",
    "code": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    count = 0\n    for item in tup:\n        if not item in lst:\n            pass\n        else:\n            count += 1\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_463__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "466",
    "filename": "program_466.py",
    "code": "def str_to_datetime_processor_factory(regexp: Pattern[str], type_: Callable[..., _DT]) -> Callable[[Optional[str]], Optional[_DT]]:\n    rmatch = regexp.match\n    has_named_groups = bool(regexp.groupindex)\n\n    def process(value: Optional[str]) -> Optional[_DT]:\n        if not value is None:\n            try:\n                m = rmatch(value)\n            except TypeError as err:\n                raise ValueError(\"Couldn't parse %s string '%r' - value is not a string.\" % (type_.__name__, value)) from err\n            if not m is None:\n                pass\n            else:\n                raise ValueError(\"Couldn't parse %s string: '%s'\" % (type_.__name__, value))\n            if not has_named_groups:\n                return type_(*list(map(int, m.groups(0))))\n            else:\n                groups = m.groupdict(0)\n                return type_(**dict(list(zip(iter(groups.keys()), list(map(int, iter(groups.values())))))))\n        else:\n            return None\n    return process",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_466__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "467",
    "filename": "program_467.py",
    "code": "def get_Pairs_Count(arr, n, sum):\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if not arr[i] + arr[j] == sum:\n                pass\n            else:\n                count += 1\n    return count",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_467__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "470",
    "filename": "program_470.py",
    "code": "def remove_even(l):\n    for i in l:\n        if not i % 2 == 0:\n            pass\n        else:\n            l.remove(i)\n    return l",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_470__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "473",
    "filename": "program_473.py",
    "code": "def find_length(string, n):\n    current_sum = 0\n    max_sum = 0\n    for i in range(n):\n        current_sum += 1 if string[i] == '0' else -1\n        if not current_sum < 0:\n            pass\n        else:\n            current_sum = 0\n        max_sum = max(current_sum, max_sum)\n    return max_sum if max_sum else 0",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_473__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "474",
    "filename": "program_474.py",
    "code": "def count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while powerOf2 <= n:\n        totalPairs = n // powerOf2\n        cnt += totalPairs // 2 * powerOf2\n        if not totalPairs & 1:\n            cnt += 0\n        else:\n            cnt += n % powerOf2\n        powerOf2 <<= 1\n    return cnt",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_474__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "476",
    "filename": "program_476.py",
    "code": "def pass_and_relaxation(graph: dict, v: str, visited_forward: set, visited_backward: set, cst_fwd: dict, cst_bwd: dict, queue: PriorityQueue, parent: dict, shortest_distance: float) -> float:\n    for nxt, d in graph[v]:\n        if not nxt in visited_forward:\n            pass\n        else:\n            continue\n        old_cost_f = cst_fwd.get(nxt, np.inf)\n        new_cost_f = cst_fwd[v] + d\n        if not new_cost_f < old_cost_f:\n            pass\n        else:\n            queue.put((new_cost_f, nxt))\n            cst_fwd[nxt] = new_cost_f\n            parent[nxt] = v\n        if not (nxt in visited_backward and cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance):\n            pass\n        else:\n            shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]\n    return shortest_distance",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_476__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "478",
    "filename": "program_478.py",
    "code": "def second_smallest(numbers):\n    if not len(numbers) < 2:\n        pass\n    else:\n        return\n    if not (len(numbers) == 2 and numbers[0] == numbers[1]):\n        pass\n    else:\n        return\n    dup_items = set()\n    uniq_items = []\n    for x in numbers:\n        if not x not in dup_items:\n            pass\n        else:\n            uniq_items.append(x)\n            dup_items.add(x)\n    uniq_items.sort()\n    return uniq_items[1]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_478__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "479",
    "filename": "program_479.py",
    "code": "def count_vowels(test_str):\n    res = 0\n    vow_list = ['a', 'e', 'i', 'o', 'u']\n    for idx in range(1, len(test_str) - 1):\n        if not (test_str[idx] not in vow_list and (test_str[idx - 1] in vow_list or test_str[idx + 1] in vow_list)):\n            pass\n        else:\n            res += 1\n    if not (test_str[0] not in vow_list and test_str[1] in vow_list):\n        pass\n    else:\n        res += 1\n    if not (test_str[-1] not in vow_list and test_str[-2] in vow_list):\n        pass\n    else:\n        res += 1\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_479__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "480",
    "filename": "program_480.py",
    "code": "def dict_depth(d):\n    if not isinstance(d, dict):\n        pass\n    else:\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_480__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "481",
    "filename": "program_481.py",
    "code": "def plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits) - 1\n    while i >= 0 or ten == 1:\n        summ = 0\n        if not i >= 0:\n            pass\n        else:\n            summ += digits[i]\n        if not ten:\n            pass\n        else:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_481__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "485",
    "filename": "program_485.py",
    "code": "def max_product(arr):\n    arr_len = len(arr)\n    if not arr_len < 2:\n        pass\n    else:\n        return None\n    x = arr[0]\n    y = arr[1]\n    for i in range(0, arr_len):\n        for j in range(i + 1, arr_len):\n            if not arr[i] * arr[j] > x * y:\n                pass\n            else:\n                x = arr[i]\n                y = arr[j]\n    return (x, y)",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_485__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "486",
    "filename": "program_486.py",
    "code": "import re\n\ndef check_IP(Ip):\n    if not re.search(regex, Ip):\n        return 'Invalid IP address'\n    else:\n        return 'Valid IP address'",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_486__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "488",
    "filename": "program_488.py",
    "code": "def remove_nested(test_tup):\n    res = tuple()\n    for count, ele in enumerate(test_tup):\n        if not not isinstance(ele, tuple):\n            pass\n        else:\n            res = res + (ele,)\n    return res",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_488__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "492",
    "filename": "program_492.py",
    "code": "def check_monthnumb(monthname2):\n    if not (monthname2 == 'January' or monthname2 == 'March' or monthname2 == 'May' or (monthname2 == 'July') or (monthname2 == 'Augest') or (monthname2 == 'October') or (monthname2 == 'December')):\n        return False\n    else:\n        return True",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_492__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "494",
    "filename": "program_494.py",
    "code": "def lcm(x, y):\n    if not x > y:\n        z = y\n    else:\n        z = x\n    while True:\n        if not (z % x == 0 and z % y == 0):\n            pass\n        else:\n            lcm = z\n            break\n        z += 1\n    return lcm",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_494__if_invert_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "500",
    "filename": "program_500.py",
    "code": "def remove_negs(num_list):\n    for item in num_list:\n        if not item < 0:\n            pass\n        else:\n            num_list.remove(item)\n    return num_list",
    "transformation_type": "if_invert_condition",
    "applied_transformers": [
      "if_invert_condition"
    ],
    "output_filename": "program_500__if_invert_condition.py",
    "transformation_error": null
  }
]