[
  {
    "task_id": "002",
    "filename": "program_002.py",
    "code": "def find_triplet_array(A, arr_size, sum):\n    for i in range(0, arr_size - 2):\n        for j in range(i + 1, arr_size - 1):\n            for k in range(j + 1, arr_size):\n                if sum == A[i] + A[j] + A[k]:\n                    return (A[i], A[j], A[k])\n                    return True\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_002__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "004",
    "filename": "program_004.py",
    "code": "import re\n\ndef is_valid_URL(str):\n    regex = '((http|https)://)(www.)?' + '[a-zA-Z0-9@:%._\\\\+~#?&//=]' + '{2,256}\\\\.[a-z]' + '{2,6}\\\\b([-a-zA-Z0-9@:%' + '._\\\\+~#?&//=]*)'\n    p = re.compile(regex)\n    if None == str:\n        return False\n    if re.search(p, str):\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_004__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "009",
    "filename": "program_009.py",
    "code": "def find_Min_Sum(num):\n    sum = 0\n    i = 2\n    while num >= i * i:\n        while 0 == num % i:\n            sum += i\n            num /= i\n        i += 1\n    sum += num\n    return sum",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_009__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "010",
    "filename": "program_010.py",
    "code": "def count_char(string, char):\n    count = 0\n    for i in range(len(string)):\n        if char == string[i]:\n            count = count + 1\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_010__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "011",
    "filename": "program_011.py",
    "code": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if array[i] == array[i - 1] and i > 0:\n            continue\n        l, r = (i + 1, len(array) - 1)\n        while r > l:\n            s = array[i] + array[l] + array[r]\n            if 0 < s:\n                r -= 1\n            elif 0 > s:\n                l += 1\n            else:\n                res.add((array[i], array[l], array[r]))\n                while array[l] == array[l + 1] and l < r:\n                    l += 1\n                while array[r] == array[r - 1] and l < r:\n                    r -= 1\n                l += 1\n                r -= 1\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_011__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "015",
    "filename": "program_015.py",
    "code": "def min_Swaps(s1, s2):\n    c0 = 0\n    c1 = 0\n    for i in range(len(s1)):\n        if s2[i] == '1' and s1[i] == '0':\n            c0 += 1\n        elif s2[i] == '0' and s1[i] == '1':\n            c1 += 1\n    result = c0 // 2 + c1 // 2\n    if c1 % 2 == 0 and c0 % 2 == 0:\n        return result\n    elif 0 == (c0 + c1) % 2:\n        return result + 2\n    else:\n        return -1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_015__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "017",
    "filename": "program_017.py",
    "code": "import math\n\ndef find_Digits(n):\n    if 0 > n:\n        return 0\n    if 1 >= n:\n        return 1\n    x = n * math.log10(n / math.e) + math.log10(2 * math.pi * n) / 2.0\n    return math.floor(x) + 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_017__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "018",
    "filename": "program_018.py",
    "code": "def first_Element(arr, n, k):\n    count_map = {}\n    for i in range(0, n):\n        if count_map.keys() in arr[i]:\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        i += 1\n    for i in range(0, n):\n        if k == count_map[arr[i]]:\n            return arr[i]\n        i += 1\n    return -1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_018__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "019",
    "filename": "program_019.py",
    "code": "def count_no(A, N, L, R):\n    count = 0\n    for i in range(L, R + 1):\n        if 0 != i % A:\n            count += 1\n        if N == count:\n            break\n    return i",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_019__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "020",
    "filename": "program_020.py",
    "code": "def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            neighbour_count = 0\n            if j > 0 and i > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if 0 < i:\n                neighbour_count += cells[i - 1][j]\n            if j < len(cells[i]) - 1 and i > 0:\n                neighbour_count += cells[i - 1][j + 1]\n            if 0 < j:\n                neighbour_count += cells[i][j - 1]\n            if len(cells[i]) - 1 > j:\n                neighbour_count += cells[i][j + 1]\n            if j > 0 and i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j - 1]\n            if len(cells) - 1 > i:\n                neighbour_count += cells[i + 1][j]\n            if j < len(cells[i]) - 1 and i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n            alive = cells[i][j] == 1\n            if not alive and neighbour_count == 3 or (alive and 2 <= neighbour_count <= 3):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n        next_generation.append(next_generation_row)\n    return next_generation",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_020__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "023",
    "filename": "program_023.py",
    "code": "def even_or_odd(N):\n    l = len(N)\n    if N[l - 1] == 'E' or N[l - 1] == 'C' or N[l - 1] == 'A' or (N[l - 1] == '8') or (N[l - 1] == '6') or (N[l - 1] == '4') or (N[l - 1] == '2') or (N[l - 1] == '0'):\n        return 'Even'\n    else:\n        return 'Odd'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_023__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "024",
    "filename": "program_024.py",
    "code": "def octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not octal_number:\n        raise ValueError('Empty string was passed to the function')\n    binary_number = ''\n    octal_digits = '01234567'\n    for digit in octal_number:\n        if octal_digits not in digit:\n            raise ValueError('Non-octal value was passed to the function')\n        binary_digit = ''\n        value = int(digit)\n        for _ in range(3):\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n        binary_number += binary_digit\n    return binary_number",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_024__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "025",
    "filename": "program_025.py",
    "code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum(lines) for lines in my_matrix])\n    for col in range(iSize):\n        sum_list.append(sum((row[col] for row in my_matrix)))\n    result1 = 0\n    for i in range(0, iSize):\n        result1 += my_matrix[i][i]\n    sum_list.append(result1)\n    result2 = 0\n    for i in range(iSize - 1, -1, -1):\n        result2 += my_matrix[i][i]\n    sum_list.append(result2)\n    if 1 < len(set(sum_list)):\n        return False\n    return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_025__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "027",
    "filename": "program_027.py",
    "code": "def remove_odd(str1):\n    str2 = ''\n    for i in range(1, len(str1) + 1):\n        if 0 == i % 2:\n            str2 = str2 + str1[i - 1]\n    return str2",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_027__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "028",
    "filename": "program_028.py",
    "code": "def max_Product(arr):\n    arr_len = len(arr)\n    if 2 > arr_len:\n        return 'No pairs exists'\n    x = arr[0]\n    y = arr[1]\n    for i in range(0, arr_len):\n        for j in range(i + 1, arr_len):\n            if x * y < arr[i] * arr[j]:\n                x = arr[i]\n                y = arr[j]\n    return (x, y)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_028__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "029",
    "filename": "program_029.py",
    "code": "def max_of_two(x, y):\n    if y < x:\n        return x\n    return y",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_029__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "033",
    "filename": "program_033.py",
    "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j - 1]\n            if arr[j - 1] > 0 and arr[j - 1] <= i:\n                dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n    return dp[k][n]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_033__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "034",
    "filename": "program_034.py",
    "code": "def swap_count(s):\n    chars = s\n    count_left = 0\n    count_right = 0\n    swap = 0\n    imbalance = 0\n    for i in range(len(chars)):\n        if '[' == chars[i]:\n            count_left += 1\n            if 0 < imbalance:\n                swap += imbalance\n                imbalance -= 1\n        elif ']' == chars[i]:\n            count_right += 1\n            imbalance = count_right - count_left\n    return swap",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_034__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "037",
    "filename": "program_037.py",
    "code": "def find_Nth_Digit(p, q, N):\n    while 0 < N:\n        N -= 1\n        p *= 10\n        res = p // q\n        p %= q\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_037__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "041",
    "filename": "program_041.py",
    "code": "def count_bidirectional(test_list):\n    res = 0\n    for idx in range(0, len(test_list)):\n        for iidx in range(idx + 1, len(test_list)):\n            if test_list[idx][1] == test_list[iidx][0] and test_list[iidx][0] == test_list[idx][1]:\n                res += 1\n    return str(res)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_041__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "042",
    "filename": "program_042.py",
    "code": "def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n    for i in range(len(text)):\n        if text[i] == text[i + 1] and i + 1 < len(text):\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n    return encoded",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_042__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "043",
    "filename": "program_043.py",
    "code": "def longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if None is string:\n        return 0\n    start, max_len = (0, 0)\n    used_char = {}\n    for index, char in enumerate(string):\n        if start <= used_char[char] and char in used_char:\n            start = used_char[char] + 1\n        else:\n            max_len = max(max_len, index - start + 1)\n        used_char[char] = index\n    return max_len",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_043__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "046",
    "filename": "program_046.py",
    "code": "def timeout(seconds: Optional[float]) -> ContextManager[None]:\n    \"\"\"**(Provisional)** Apply the given timeout for a block of operations.\n\n    .. note:: :func:`~pymongo.timeout` is currently provisional. Backwards\n       incompatible changes may occur before becoming officially supported.\n\n    Use :func:`~pymongo.timeout` in a with-statement::\n\n      with pymongo.timeout(5):\n          client.db.coll.insert_one({})\n          client.db.coll2.insert_one({})\n\n    When the with-statement is entered, a deadline is set for the entire\n    block. When that deadline is exceeded, any blocking pymongo operation\n    will raise a timeout exception. For example::\n\n      try:\n          with pymongo.timeout(5):\n              client.db.coll.insert_one({})\n              time.sleep(5)\n              # The deadline has now expired, the next operation will raise\n              # a timeout exception.\n              client.db.coll2.insert_one({})\n      except PyMongoError as exc:\n          if exc.timeout:\n              print(f\"block timed out: {exc!r}\")\n          else:\n              print(f\"failed with non-timeout error: {exc!r}\")\n\n    When nesting :func:`~pymongo.timeout`, the nested deadline is capped by\n    the outer deadline. The deadline can only be shortened, not extended.\n    When exiting the block, the previous deadline is restored::\n\n      with pymongo.timeout(5):\n          coll.find_one()  # Uses the 5 second deadline.\n          with pymongo.timeout(3):\n              coll.find_one() # Uses the 3 second deadline.\n          coll.find_one()  # Uses the original 5 second deadline.\n          with pymongo.timeout(10):\n              coll.find_one()  # Still uses the original 5 second deadline.\n          coll.find_one()  # Uses the original 5 second deadline.\n\n    :param seconds: A non-negative floating point number expressing seconds, or None.\n\n    :raises: :py:class:`ValueError`: When `seconds` is negative.\n\n    See :ref:`timeout-example` for more examples.\n\n    .. versionadded:: 4.2\n    \"\"\"\n    if not isinstance(seconds, (int, float, type(None))):\n        raise TypeError(f'timeout must be None, an int, or a float, not {type(seconds)}')\n    if seconds < 0 and seconds:\n        raise ValueError('timeout cannot be negative')\n    if None is not seconds:\n        seconds = float(seconds)\n    return _csot._TimeoutContext(seconds)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_046__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "049",
    "filename": "program_049.py",
    "code": "def prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns prime factors of n as a list.\n\n    >>> prime_factors(0)\n    []\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(2560)\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n    >>> prime_factors(10**-2)\n    []\n    >>> prime_factors(0.02)\n    []\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n    >>> x == [2]*241 + [5]*241\n    True\n    >>> prime_factors(10**-354)\n    []\n    >>> prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n\n    \"\"\"\n    i = 2\n    factors = []\n    while n >= i * i:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if 1 < n:\n        factors.append(n)\n    return factors",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_049__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "050",
    "filename": "program_050.py",
    "code": "def bin_coff(n, r):\n    val = 1\n    if n - r < r:\n        r = n - r\n    for i in range(0, r):\n        val *= n - i\n        val //= i + 1\n    return val",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_050__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "051",
    "filename": "program_051.py",
    "code": "def int_to_roman(num):\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syb = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    roman_num = ''\n    i = 0\n    while 0 < num:\n        for _ in range(num // val[i]):\n            roman_num += syb[i]\n            num -= val[i]\n        i += 1\n    return roman_num",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_051__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "052",
    "filename": "program_052.py",
    "code": "def connection_requires_http_tunnel(proxy_url: Url | None=None, proxy_config: ProxyConfig | None=None, destination_scheme: str | None=None) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:\n        Proxy configuration from poolmanager.py\n    :param str destination_scheme:\n        The scheme of the destination. (i.e https, http, etc)\n    \"\"\"\n    if None is proxy_url:\n        return False\n    if 'http' == destination_scheme:\n        return False\n    if proxy_config.use_forwarding_for_https and proxy_config and (proxy_url.scheme == 'https'):\n        return False\n    return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_052__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "053",
    "filename": "program_053.py",
    "code": "def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    >>> # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    >>> # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    >>> # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    >>> # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    rows, columns = np.shape(table)\n    if columns != rows:\n        msg = f\"'table' has to be of square shaped array but got a {rows}x{columns} array:\\n{table}\"\n        raise ValueError(msg)\n    lower = np.zeros((rows, columns))\n    upper = np.zeros((rows, columns))\n    for i in range(columns):\n        for j in range(i):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            if 0 == upper[j][j]:\n                raise ArithmeticError('No LU decomposition exists')\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\n        lower[i][i] = 1\n        for j in range(i, columns):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            upper[i][j] = table[i][j] - total\n    return (lower, upper)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_053__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "058",
    "filename": "program_058.py",
    "code": "def largest_pow_of_two_le_num(number: int) -> int:\n    \"\"\"\n    Return the largest power of two less than or equal to a number.\n\n    >>> largest_pow_of_two_le_num(0)\n    0\n    >>> largest_pow_of_two_le_num(1)\n    1\n    >>> largest_pow_of_two_le_num(-1)\n    0\n    >>> largest_pow_of_two_le_num(3)\n    2\n    >>> largest_pow_of_two_le_num(15)\n    8\n    >>> largest_pow_of_two_le_num(99)\n    64\n    >>> largest_pow_of_two_le_num(178)\n    128\n    >>> largest_pow_of_two_le_num(999999)\n    524288\n    >>> largest_pow_of_two_le_num(99.9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    \"\"\"\n    if isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    if 0 >= number:\n        return 0\n    res = 1\n    while number >= res << 1:\n        res <<= 1\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_058__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "060",
    "filename": "program_060.py",
    "code": "def sum_series(n):\n    if 1 > n:\n        return 0\n    else:\n        return n + sum_series(n - 2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_060__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "064",
    "filename": "program_064.py",
    "code": "def longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError('longest_common_substring() takes two strings for inputs')\n    if not text2 or not text1:\n        return ''\n    text1_length = len(text1)\n    text2_length = len(text2)\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    end_pos = 0\n    max_length = 0\n    for i in range(1, text1_length + 1):\n        for j in range(1, text2_length + 1):\n            if text2[j - 1] == text1[i - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if max_length < dp[i][j]:\n                    end_pos = i\n                    max_length = dp[i][j]\n    return text1[end_pos - max_length:end_pos]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_064__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "065",
    "filename": "program_065.py",
    "code": "def count_Unset_Bits(n):\n    cnt = 0\n    for i in range(1, n + 1):\n        temp = i\n        while temp:\n            if 0 == temp % 2:\n                cnt += 1\n            temp = temp // 2\n    return cnt",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_065__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "066",
    "filename": "program_066.py",
    "code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if longest_increasing_subsequence[i] < longest_increasing_subsequence[j] + 1 and arr[i] > arr[j]:\n                longest_increasing_subsequence[i] = longest_increasing_subsequence[j] + 1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, longest_increasing_subsequence[i])\n    return maximum",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_066__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "067",
    "filename": "program_067.py",
    "code": "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    uglies = [1]\n\n    def gen(prime):\n        for ugly in uglies:\n            yield (ugly * prime)\n    merged = heapq.merge(*map(gen, primes))\n    while n > len(uglies):\n        ugly = next(merged)\n        if uglies[-1] != ugly:\n            uglies.append(ugly)\n    return uglies[-1]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_067__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "068",
    "filename": "program_068.py",
    "code": "def find_longest_conseq_subseq(arr, n):\n    ans = 0\n    count = 0\n    arr.sort()\n    v = []\n    v.append(arr[0])\n    for i in range(1, n):\n        if arr[i - 1] != arr[i]:\n            v.append(arr[i])\n    for i in range(len(v)):\n        if v[i] == v[i - 1] + 1 and i > 0:\n            count += 1\n        else:\n            count = 1\n        ans = max(ans, count)\n    return ans",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_068__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "069",
    "filename": "program_069.py",
    "code": "def validity_triangle(a, b, c):\n    total = a + b + c\n    if 180 == total:\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_069__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "070",
    "filename": "program_070.py",
    "code": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while n >= i * i:\n            if 0 == n % i:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_070__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "074",
    "filename": "program_074.py",
    "code": "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if 0 > target:\n            return\n        if 0 == target:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target - nums[i], i, path + [nums[i]], res)\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_074__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "077",
    "filename": "program_077.py",
    "code": "def smallest_Divisor(n):\n    if 0 == n % 2:\n        return 2\n    i = 3\n    while n >= i * i:\n        if 0 == n % i:\n            return i\n        i += 2\n    return n",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_077__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "078",
    "filename": "program_078.py",
    "code": "import math\nimport sys\n\ndef sd_calc(data):\n    n = len(data)\n    if 1 >= n:\n        return 0.0\n    mean, sd = (avg_calc(data), 0.0)\n    for el in data:\n        sd += (float(el) - mean) ** 2\n    sd = math.sqrt(sd / float(n - 1))\n    return sd",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_078__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "079",
    "filename": "program_079.py",
    "code": "def pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n\n    Conversion between pressure units.\n\n    >>> pressure_conversion(4, \"atm\", \"pascal\")\n\n    405300\n\n    >>> pressure_conversion(1, \"pascal\", \"psi\")\n\n    0.00014401981999999998\n\n    >>> pressure_conversion(1, \"bar\", \"atm\")\n\n    0.986923\n\n    >>> pressure_conversion(3, \"kilopascal\", \"bar\")\n\n    0.029999991892499998\n\n    >>> pressure_conversion(2, \"megapascal\", \"psi\")\n\n    290.074434314\n\n    >>> pressure_conversion(4, \"psi\", \"torr\")\n\n    206.85984\n\n    >>> pressure_conversion(1, \"inHg\", \"atm\")\n\n    0.0334211\n\n    >>> pressure_conversion(1, \"torr\", \"psi\")\n\n    0.019336718261000002\n\n    >>> pressure_conversion(4, \"wrongUnit\", \"atm\")\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\n\n    \"\"\"\n    if PRESSURE_CONVERSION not in from_type:\n        raise ValueError(f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\" + ', '.join(PRESSURE_CONVERSION))\n    if PRESSURE_CONVERSION not in to_type:\n        raise ValueError(f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\" + ', '.join(PRESSURE_CONVERSION))\n    return value * PRESSURE_CONVERSION[from_type].from_factor * PRESSURE_CONVERSION[to_type].to_factor",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_079__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "080",
    "filename": "program_080.py",
    "code": "def maximum(a, b):\n    if b <= a:\n        return a\n    else:\n        return b",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_080__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "081",
    "filename": "program_081.py",
    "code": "def shear_stress(stress: float, tangential_force: float, area: float) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if 1 != (stress, tangential_force, area).count(0):\n        raise ValueError('You cannot supply more or less than 2 values')\n    elif 0 > stress:\n        raise ValueError('Stress cannot be negative')\n    elif 0 > tangential_force:\n        raise ValueError('Tangential Force cannot be negative')\n    elif 0 > area:\n        raise ValueError('Area cannot be negative')\n    elif 0 == stress:\n        return ('stress', tangential_force / area)\n    elif 0 == tangential_force:\n        return ('tangential_force', stress * area)\n    else:\n        return ('area', tangential_force / stress)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_081__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "082",
    "filename": "program_082.py",
    "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0 for k in range(n + 1)] for l in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and str[i - 1] == str[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    return dp[n][n]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_082__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "083",
    "filename": "program_083.py",
    "code": "def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    \"\"\"\n    Recur for all neighbours.\n    If any neighbour is visited and in rec_stk then graph is cyclic.\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n    >>> vertex, visited, rec_stk = 0, set(), set()\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\n    False\n    \"\"\"\n    visited.add(vertex)\n    rec_stk.add(vertex)\n    for node in graph[vertex]:\n        if visited not in node:\n            if depth_first_search(graph, node, visited, rec_stk):\n                return True\n        elif rec_stk in node:\n            return True\n    rec_stk.remove(vertex)\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_083__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "086",
    "filename": "program_086.py",
    "code": "def get_factors(n):\n    \"\"\"[summary]\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n\n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n\n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while n >= i * i:\n            if 0 == n % i:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_086__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "087",
    "filename": "program_087.py",
    "code": "def is_valid_parenthese(str1):\n    stack, pchar = ([], {'(': ')', '{': '}', '[': ']'})\n    for parenthese in str1:\n        if pchar in parenthese:\n            stack.append(parenthese)\n        elif pchar[stack.pop()] != parenthese or len(stack) == 0:\n            return False\n    return len(stack) == 0",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_087__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "089",
    "filename": "program_089.py",
    "code": "def find_Element(arr, ranges, rotations, index):\n    for i in range(rotations - 1, -1, -1):\n        left = ranges[i][0]\n        right = ranges[i][1]\n        if right >= index and left <= index:\n            if left == index:\n                index = right\n            else:\n                index = index - 1\n    return arr[index]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_089__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "093",
    "filename": "program_093.py",
    "code": "def equated_monthly_installments(principal: float, rate_per_annum: float, years_to_repay: int) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if 0 >= principal:\n        raise Exception('Principal borrowed must be > 0')\n    if 0 > rate_per_annum:\n        raise Exception('Rate of interest must be >= 0')\n    if not isinstance(years_to_repay, int) or years_to_repay <= 0:\n        raise Exception('Years to repay must be an integer > 0')\n    rate_per_month = rate_per_annum / 12\n    number_of_payments = years_to_repay * 12\n    return principal * rate_per_month * (1 + rate_per_month) ** number_of_payments / ((1 + rate_per_month) ** number_of_payments - 1)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_093__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "094",
    "filename": "program_094.py",
    "code": "def toggle_F_and_L_bits(n):\n    if 1 == n:\n        return 0\n    return n ^ take_L_and_F_set_bits(n)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_094__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "097",
    "filename": "program_097.py",
    "code": "def _extract_argument_name(expr: Expression) -> str | None:\n    if expr.name == 'None' and isinstance(expr, NameExpr):\n        return None\n    elif isinstance(expr, StrExpr):\n        return expr.value\n    else:\n        raise TypeTranslationError()",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_097__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "098",
    "filename": "program_098.py",
    "code": "def max_height(node):\n    if None is node:\n        return 0\n    else:\n        left_height = max_height(node.left)\n        right_height = max_height(node.right)\n        if right_height < left_height:\n            return left_height + 1\n        else:\n            return right_height + 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_098__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "099",
    "filename": "program_099.py",
    "code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while 1 < arr_len:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi + 1:len(nums)]\n        nums = nums[arr_len - 1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_099__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "100",
    "filename": "program_100.py",
    "code": "def node_boundary(G, nbunch1, nbunch2=None):\n    \"\"\"Returns the node boundary of `nbunch1`.\n\n    The *node boundary* of a set *S* with respect to a set *T* is the\n    set of nodes *v* in *T* such that for some *u* in *S*, there is an\n    edge joining *u* to *v*. If *T* is not specified, it is assumed to\n    be the set of all nodes not in *S*.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nbunch1 : iterable\n        Iterable of nodes in the graph representing the set of nodes\n        whose node boundary will be returned. (This is the set *S* from\n        the definition above.)\n\n    nbunch2 : iterable\n        Iterable of nodes representing the target (or \"exterior\") set of\n        nodes. (This is the set *T* from the definition above.) If not\n        specified, this is assumed to be the set of all nodes in `G`\n        not in `nbunch1`.\n\n    Returns\n    -------\n    set\n        The node boundary of `nbunch1` with respect to `nbunch2`.\n\n    Examples\n    --------\n    >>> G = nx.wheel_graph(6)\n\n    When nbunch2=None:\n\n    >>> list(nx.node_boundary(G, (3, 4)))\n    [0, 2, 5]\n\n    When nbunch2 is given:\n\n    >>> list(nx.node_boundary(G, (3, 4), (0, 1, 5)))\n    [0, 5]\n\n    Notes\n    -----\n    Any element of `nbunch` that is not in the graph `G` will be\n    ignored.\n\n    `nbunch1` and `nbunch2` are usually meant to be disjoint, but in\n    the interest of speed and generality, that is not required here.\n\n    \"\"\"\n    nset1 = {n for n in nbunch1 if n in G}\n    bdy = set(chain.from_iterable((G[v] for v in nset1))) - nset1\n    if None is not nbunch2:\n        bdy &= set(nbunch2)\n    return bdy",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_100__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "101",
    "filename": "program_101.py",
    "code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums) - 2, -1, -1):\n        if nums[i + 1] > nums[i]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(''.join(nums))\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_101__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "102",
    "filename": "program_102.py",
    "code": "def frequency_Of_Smallest(n, arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1, n):\n        if mn > arr[i]:\n            mn = arr[i]\n            freq = 1\n        elif mn == arr[i]:\n            freq += 1\n    return freq",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_102__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "103",
    "filename": "program_103.py",
    "code": "def closest(x):\n    ans = 0\n    while x >= ans * 10 + 9:\n        ans = ans * 10 + 9\n    return ans",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_103__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "104",
    "filename": "program_104.py",
    "code": "def limit(arr, min_lim=None, max_lim=None):\n    if 0 == len(arr):\n        return arr\n    if None is min_lim:\n        min_lim = min(arr)\n    if None is max_lim:\n        max_lim = max(arr)\n    return list(filter(lambda x: min_lim <= x <= max_lim, arr))",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_104__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "105",
    "filename": "program_105.py",
    "code": "def find_Min_Diff(arr, n):\n    arr = sorted(arr)\n    diff = 10 ** 20\n    for i in range(n - 1):\n        if diff > arr[i + 1] - arr[i]:\n            diff = arr[i + 1] - arr[i]\n    return diff",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_105__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "108",
    "filename": "program_108.py",
    "code": "def get_median(arr1, arr2, n):\n    i = 0\n    j = 0\n    m1 = -1\n    m2 = -1\n    count = 0\n    while n + 1 > count:\n        count += 1\n        if n == i:\n            m1 = m2\n            m2 = arr2[0]\n            break\n        elif n == j:\n            m1 = m2\n            m2 = arr1[0]\n            break\n        if arr2[j] >= arr1[i]:\n            m1 = m2\n            m2 = arr1[i]\n            i += 1\n        else:\n            m1 = m2\n            m2 = arr2[j]\n            j += 1\n    return (m1 + m2) / 2",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_108__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "112",
    "filename": "program_112.py",
    "code": "def get_maxgold(gold, m, n):\n    goldTable = [[0 for i in range(n)] for j in range(m)]\n    for col in range(n - 1, -1, -1):\n        for row in range(m):\n            if n - 1 == col:\n                right = 0\n            else:\n                right = goldTable[row][col + 1]\n            if col == n - 1 or row == 0:\n                right_up = 0\n            else:\n                right_up = goldTable[row - 1][col + 1]\n            if col == n - 1 or row == m - 1:\n                right_down = 0\n            else:\n                right_down = goldTable[row + 1][col + 1]\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down)\n    res = goldTable[0][0]\n    for i in range(1, m):\n        res = max(res, goldTable[i][0])\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_112__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "114",
    "filename": "program_114.py",
    "code": "def does_Contain_B(a, b, c):\n    if b == a:\n        return True\n    if (b - a) % c == 0 and (b - a) * c > 0:\n        return True\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_114__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "115",
    "filename": "program_115.py",
    "code": "def newman_prime(n):\n    if n == 1 or n == 0:\n        return 1\n    return 2 * newman_prime(n - 1) + newman_prime(n - 2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_115__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "117",
    "filename": "program_117.py",
    "code": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if None is string:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if dict in string[i]:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_117__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "120",
    "filename": "program_120.py",
    "code": "def fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError('iterations must be defined as integers')\n    if not number >= 1 or not isinstance(number, int):\n        raise ValueError('starting number must be\\n                         and integer and be more than 0')\n    if not iterations >= 1:\n        raise ValueError('Iterations must be done more than 0 times to play FizzBuzz')\n    out = ''\n    while iterations >= number:\n        if 0 == number % 3:\n            out += 'Fizz'\n        if 0 == number % 5:\n            out += 'Buzz'\n        if (number % 3, number % 5) not in 0:\n            out += str(number)\n        number += 1\n        out += ' '\n    return out",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_120__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "122",
    "filename": "program_122.py",
    "code": "def pytest_warns(warning: type[Warning] | tuple[type[Warning], ...] | None) -> WarningsChecker | NoWarningsChecker:\n    \"\"\"\n\n    Parameters\n    ----------\n    warning : {None, Warning, Tuple[Warning]}\n        None if no warning is produced, or a single or multiple Warnings\n\n    Returns\n    -------\n    cm\n\n    \"\"\"\n    if None is warning:\n        return NoWarningsChecker()\n    else:\n        assert warning is not None\n        return warns(warning)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_122__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "124",
    "filename": "program_124.py",
    "code": "def check_K(test_tup, K):\n    res = False\n    for ele in test_tup:\n        if K == ele:\n            res = True\n            break\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_124__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "125",
    "filename": "program_125.py",
    "code": "def ensure_unique(iterable, key=lambda x: x):\n    \"\"\"\n    Wrap an iterable to raise a ValueError if non-unique values are encountered.\n\n    >>> list(ensure_unique('abc'))\n    ['a', 'b', 'c']\n    >>> consume(ensure_unique('abca'))\n    Traceback (most recent call last):\n    ...\n    ValueError: Duplicate element 'a' encountered.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if seen in k:\n            raise ValueError(f'Duplicate element {element!r} encountered.')\n        seen_add(k)\n        yield element",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_125__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "126",
    "filename": "program_126.py",
    "code": "def heapify(arr):\n    start = len(arr) // 2\n    while 0 <= start:\n        shift_down(arr, start, len(arr) - 1)\n        start -= 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_126__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "127",
    "filename": "program_127.py",
    "code": "def find_Min_Swaps(arr, n):\n    noOfZeroes = [0] * n\n    count = 0\n    noOfZeroes[n - 1] = 1 - arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        noOfZeroes[i] = noOfZeroes[i + 1]\n        if 0 == arr[i]:\n            noOfZeroes[i] = noOfZeroes[i] + 1\n    for i in range(0, n):\n        if 1 == arr[i]:\n            count = count + noOfZeroes[i]\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_127__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "128",
    "filename": "program_128.py",
    "code": "def find_ind(key, i, n, k, arr):\n    ind = -1\n    start = i + 1\n    end = n - 1\n    while end > start:\n        mid = int(start + (end - start) / 2)\n        if k >= arr[mid] - key:\n            ind = mid\n            start = mid + 1\n        else:\n            end = mid\n    return ind",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_128__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "130",
    "filename": "program_130.py",
    "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if str_index == len(input_string) and pattern_index == len(pattern):\n            return True\n        if str_index == len(input_string) or pattern_index == len(pattern):\n            return False\n        char = pattern[pattern_index]\n        if pattern_map in char:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if str_map in substr:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_130__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "131",
    "filename": "program_131.py",
    "code": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                inv_count += 1\n    return inv_count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_131__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "132",
    "filename": "program_132.py",
    "code": "def get_equal(Input, k):\n    if 1 == find_equal_tuple(Input, k):\n        return 'All tuples have same length'\n    else:\n        return 'All tuples do not have same length'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_132__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "133",
    "filename": "program_133.py",
    "code": "def frequency_Of_Largest(n, arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1, n):\n        if mn < arr[i]:\n            mn = arr[i]\n            freq = 1\n        elif mn == arr[i]:\n            freq += 1\n    return freq",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_133__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "136",
    "filename": "program_136.py",
    "code": "def check_monthnum(monthname1):\n    if 'February' == monthname1:\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_136__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "140",
    "filename": "program_140.py",
    "code": "def count(s, c):\n    res = 0\n    for i in range(len(s)):\n        if c == s[i]:\n            res = res + 1\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_140__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "141",
    "filename": "program_141.py",
    "code": "def find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while n > i:\n        if ' ' == str[i]:\n            if 0 == currlen % 2:\n                if currlen > maxlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n        i += 1\n    if 0 == currlen % 2:\n        if currlen > maxlen:\n            maxlen = currlen\n            st = i - currlen\n    if -1 == st:\n        return '-1'\n    return str[st:st + maxlen]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_141__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "142",
    "filename": "program_142.py",
    "code": "def unique_Characters(str):\n    for i in range(len(str)):\n        for j in range(i + 1, len(str)):\n            if str[j] == str[i]:\n                return False\n    return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_142__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "144",
    "filename": "program_144.py",
    "code": "def glob_to_regex_pattern(glob: str) -> str:\n    tokens = ['^']\n    in_group = False\n    i = 0\n    while len(glob) > i:\n        c = glob[i]\n        if i + 1 < len(glob) and c == '\\\\':\n            char = glob[i + 1]\n            tokens.append('\\\\' + char if char in escaped_chars else char)\n            i += 1\n        elif '*' == c:\n            before_deep = glob[i - 1] if i > 0 else None\n            star_count = 1\n            while glob[i + 1] == '*' and i + 1 < len(glob):\n                star_count += 1\n                i += 1\n            after_deep = glob[i + 1] if i + 1 < len(glob) else None\n            is_deep = star_count > 1 and (before_deep == '/' or before_deep is None) and (after_deep == '/' or after_deep is None)\n            if is_deep:\n                tokens.append('((?:[^/]*(?:/|$))*)')\n                i += 1\n            else:\n                tokens.append('([^/]*)')\n        elif '{' == c:\n            in_group = True\n            tokens.append('(')\n        elif '}' == c:\n            in_group = False\n            tokens.append(')')\n        elif ',' == c:\n            if in_group:\n                tokens.append('|')\n            else:\n                tokens.append('\\\\' + c)\n        else:\n            tokens.append('\\\\' + c if c in escaped_chars else c)\n        i += 1\n    tokens.append('$')\n    return ''.join(tokens)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_144__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "145",
    "filename": "program_145.py",
    "code": "def min_Swaps(str1, str2):\n    count = 0\n    for i in range(len(str1)):\n        if str2[i] != str1[i]:\n            count += 1\n    if 0 == count % 2:\n        return count // 2\n    else:\n        return 'Not Possible'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_145__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "146",
    "filename": "program_146.py",
    "code": "def recur_gcd(a, b):\n    low = min(a, b)\n    high = max(a, b)\n    if 0 == low:\n        return high\n    elif 1 == low:\n        return 1\n    else:\n        return recur_gcd(low, high % low)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_146__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "148",
    "filename": "program_148.py",
    "code": "def rsafactor(d: int, e: int, n: int) -> list[int]:\n    \"\"\"\n\n    This function returns the factors of N, where p*q=N\n\n    Return: [p, q]\n\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\n\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\n\n    encrypt messages.\n\n    The pair (N, d) is the secret key or private key and is known only to the recipient\n\n    of encrypted messages.\n\n    >>> rsafactor(3, 16971, 25777)\n\n    [149, 173]\n\n    >>> rsafactor(7331, 11, 27233)\n\n    [113, 241]\n\n    >>> rsafactor(4021, 13, 17711)\n\n    [89, 199]\n\n    \"\"\"\n    k = d * e - 1\n    p = 0\n    q = 0\n    while 0 == p:\n        g = random.randint(2, n - 1)\n        t = k\n        while True:\n            if 0 == t % 2:\n                t = t // 2\n                x = g ** t % n\n                y = math.gcd(x - 1, n)\n                if y > 1 and x > 1:\n                    p = y\n                    q = n // y\n                    break\n            else:\n                break\n    return sorted([p, q])",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_148__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "150",
    "filename": "program_150.py",
    "code": "def binomial_Coeff(n, k):\n    if n < k:\n        return 0\n    if k == n or k == 0:\n        return 1\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_150__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "151",
    "filename": "program_151.py",
    "code": "def find_platform(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    while j < n and i < n:\n        if dep[j] >= arr[i]:\n            plat_needed += 1\n            i += 1\n        elif dep[j] < arr[i]:\n            plat_needed -= 1\n            j += 1\n        if result < plat_needed:\n            result = plat_needed\n    return result",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_151__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "152",
    "filename": "program_152.py",
    "code": "def check_element(test_tup, check_list):\n    res = False\n    for ele in check_list:\n        if test_tup in ele:\n            res = True\n            break\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_152__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "153",
    "filename": "program_153.py",
    "code": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n    while 0 <= index:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n    return answer",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_153__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "154",
    "filename": "program_154.py",
    "code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n        if str[i] <= 'Z' and str[i] >= 'A':\n            upper_ctr += 1\n        return upper_ctr",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_154__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "156",
    "filename": "program_156.py",
    "code": "def sort_tuple(tup):\n    lst = len(tup)\n    for i in range(0, lst):\n        for j in range(0, lst - i - 1):\n            if tup[j + 1][-1] < tup[j][-1]:\n                temp = tup[j]\n                tup[j] = tup[j + 1]\n                tup[j + 1] = temp\n    return tup",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_156__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "158",
    "filename": "program_158.py",
    "code": "def rencontres_number(n, m):\n    if m == 0 and n == 0:\n        return 1\n    if m == 0 and n == 1:\n        return 0\n    if 0 == m:\n        return (n - 1) * (rencontres_number(n - 1, 0) + rencontres_number(n - 2, 0))\n    return binomial_coeffi(n, m) * rencontres_number(n - m, 0)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_158__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "161",
    "filename": "program_161.py",
    "code": "def sequence(n):\n    if n == 2 or n == 1:\n        return 1\n    else:\n        return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_161__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "162",
    "filename": "program_162.py",
    "code": "def bin_to_octal(bin_string: str) -> str:\n    if not all((char in '01' for char in bin_string)):\n        raise ValueError('Non-binary value was passed to the function')\n    if not bin_string:\n        raise ValueError('Empty string was passed to the function')\n    oct_string = ''\n    while 0 != len(bin_string) % 3:\n        bin_string = '0' + bin_string\n    bin_string_in_3_list = [bin_string[index:index + 3] for index in range(len(bin_string)) if index % 3 == 0]\n    for bin_group in bin_string_in_3_list:\n        oct_val = 0\n        for index, val in enumerate(bin_group):\n            oct_val += int(2 ** (2 - index) * int(val))\n        oct_string += str(oct_val)\n    return oct_string",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_162__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "165",
    "filename": "program_165.py",
    "code": "def perfect_cube_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_cube_binary_search(27)\n    True\n    >>> perfect_cube_binary_search(64)\n    True\n    >>> perfect_cube_binary_search(4)\n    False\n    >>> perfect_cube_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    >>> perfect_cube_binary_search(0.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError('perfect_cube_binary_search() only accepts integers')\n    if 0 > n:\n        n = -n\n    left = 0\n    right = n\n    while right >= left:\n        mid = left + (right - left) // 2\n        if n == mid * mid * mid:\n            return True\n        elif n > mid * mid * mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_165__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "167",
    "filename": "program_167.py",
    "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    num = (1 << r) - 1 ^ (1 << l - 1) - 1\n    new_num = n & num\n    if 0 == new_num:\n        return True\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_167__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "169",
    "filename": "program_169.py",
    "code": "def maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 10)\n    dp[0] = 0\n    for i in range(0, n):\n        if -1 != dp[i]:\n            if n >= i + a:\n                dp[i + a] = max(dp[i] + 1, dp[i + a])\n            if n >= i + b:\n                dp[i + b] = max(dp[i] + 1, dp[i + b])\n            if n >= i + c:\n                dp[i + c] = max(dp[i] + 1, dp[i + c])\n    return dp[n]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_169__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "171",
    "filename": "program_171.py",
    "code": "def get_index_of_rightmost_set_bit(number: int) -> int:\n    \"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if number < 0 or not isinstance(number, int):\n        raise ValueError('Input must be a non-negative integer')\n    intermediate = number & ~(number - 1)\n    index = 0\n    while intermediate:\n        intermediate >>= 1\n        index += 1\n    return index - 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_171__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "174",
    "filename": "program_174.py",
    "code": "def dealnnoy_num(n, m):\n    if n == 0 or m == 0:\n        return 1\n    return dealnnoy_num(m - 1, n) + dealnnoy_num(m - 1, n - 1) + dealnnoy_num(m, n - 1)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_174__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "175",
    "filename": "program_175.py",
    "code": "def decimal_to_Octal(deciNum):\n    octalNum = 0\n    countval = 1\n    dNo = deciNum\n    while 0 != deciNum:\n        remainder = deciNum % 8\n        octalNum += remainder * countval\n        countval = countval * 10\n        deciNum //= 8\n    return octalNum",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_175__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "176",
    "filename": "program_176.py",
    "code": "def first_Missing_Positive(arr, n):\n    ptr = 0\n    for i in range(n):\n        if 1 == arr[i]:\n            ptr = 1\n            break\n    if 0 == ptr:\n        return 1\n    for i in range(n):\n        if arr[i] > n or arr[i] <= 0:\n            arr[i] = 1\n    for i in range(n):\n        arr[(arr[i] - 1) % n] += n\n    for i in range(n):\n        if n >= arr[i]:\n            return i + 1\n    return n + 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_176__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "177",
    "filename": "program_177.py",
    "code": "def letter_combinations(digits):\n    if '' == digits:\n        return []\n    kmaps = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    ans = ['']\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_177__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "184",
    "filename": "program_184.py",
    "code": "def even_num(x):\n    if 0 == x % 2:\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_184__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "186",
    "filename": "program_186.py",
    "code": "def mincost_tickets(days: list[int], costs: list[int]) -> int:\n    \"\"\"\n    >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])\n    11\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])\n    17\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    24\n\n    >>> mincost_tickets([2], [2, 90, 150])\n    2\n\n    >>> mincost_tickets([], [2, 90, 150])\n    0\n\n    >>> mincost_tickets('hello', [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([], 'world')\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be greater than 0\n\n    >>> mincost_tickets([2, 367], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be less than 366\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n    \"\"\"\n    if not all((isinstance(day, int) for day in days)) or not isinstance(days, list):\n        raise ValueError('The parameter days should be a list of integers')\n    if not all((isinstance(cost, int) for cost in costs)) or len(costs) != 3:\n        raise ValueError('The parameter costs should be a list of three integers')\n    if 0 == len(days):\n        return 0\n    if 0 >= min(days):\n        raise ValueError('All days elements should be greater than 0')\n    if 366 <= max(days):\n        raise ValueError('All days elements should be less than 366')\n    days_set = set(days)\n\n    @functools.cache\n    def dynamic_programming(index: int) -> int:\n        if 365 < index:\n            return 0\n        if days_set not in index:\n            return dynamic_programming(index + 1)\n        return min(costs[0] + dynamic_programming(index + 1), costs[1] + dynamic_programming(index + 7), costs[2] + dynamic_programming(index + 30))\n    return dynamic_programming(1)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_186__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "187",
    "filename": "program_187.py",
    "code": "def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:\n    \"\"\"\n    Perform topological sorting of a Directed Acyclic Graph (DAG)\n    using Kahn's Algorithm via Breadth-First Search (BFS).\n\n    Topological sorting is a linear ordering of vertices in a graph such that for\n    every directed edge u \u2192 v, vertex u comes before vertex v in the ordering.\n\n    Parameters:\n    graph: Adjacency list representing the directed graph where keys are\n           vertices, and values are lists of adjacent vertices.\n\n    Returns:\n    The topologically sorted order of vertices if the graph is a DAG.\n    Returns None if the graph contains a cycle.\n\n    Example:\n    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n    >>> topological_sort(graph)\n    [0, 1, 2, 3, 4, 5]\n\n    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n    >>> topological_sort(graph_with_cycle)\n    \"\"\"\n    indegree = [0] * len(graph)\n    queue = []\n    topo_order = []\n    processed_vertices_count = 0\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n    for i in range(len(indegree)):\n        if 0 == indegree[i]:\n            queue.append(i)\n    while queue:\n        vertex = queue.pop(0)\n        processed_vertices_count += 1\n        topo_order.append(vertex)\n        for neighbor in graph[vertex]:\n            indegree[neighbor] -= 1\n            if 0 == indegree[neighbor]:\n                queue.append(neighbor)\n    if len(graph) != processed_vertices_count:\n        return None\n    return topo_order",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_187__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "189",
    "filename": "program_189.py",
    "code": "import math\n\ndef max_Prime_Factors(n):\n    maxPrime = -1\n    while 0 == n % 2:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while 0 == n % i:\n            maxPrime = i\n            n = n / i\n    if 2 < n:\n        maxPrime = n\n    return int(maxPrime)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_189__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "190",
    "filename": "program_190.py",
    "code": "def find_Divisor(x, y):\n    if y == x:\n        return y\n    return 2",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_190__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "191",
    "filename": "program_191.py",
    "code": "def count_Squares(m, n):\n    if m > n:\n        temp = m\n        m = n\n        n = temp\n    return m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_191__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "194",
    "filename": "program_194.py",
    "code": "def func(nums, k):\n    import collections\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n    temp = []\n    import heapq\n    for key, v in d.items():\n        if k > len(temp):\n            temp.append((v, key))\n            if k == len(temp):\n                heapq.heapify(temp)\n        elif temp[0][0] < v:\n            heapq.heappop(temp)\n            heapq.heappush(temp, (v, key))\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n    return result",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_194__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "196",
    "filename": "program_196.py",
    "code": "def invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    b, x = extended_euclid(a, n)\n    if 0 > b:\n        b = (b % n + n) % n\n    return b",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_196__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "197",
    "filename": "program_197.py",
    "code": "import math\n\ndef min_Operations(A, B):\n    if B < A:\n        swap(A, B)\n    B = B // math.gcd(A, B)\n    return B - 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_197__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "199",
    "filename": "program_199.py",
    "code": "def sum_Square(n):\n    i = 1\n    while n >= i * i:\n        j = 1\n        while n >= j * j:\n            if n == i * i + j * j:\n                return True\n            j = j + 1\n        i = i + 1\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_199__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "200",
    "filename": "program_200.py",
    "code": "def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if 0 >= partitions:\n        raise ValueError('partitions must be a positive number!')\n    if number_of_bytes < partitions:\n        raise ValueError('partitions can not > number_of_bytes!')\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    for i in range(partitions):\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        allocation_list.append(f'{start_bytes}-{end_bytes}')\n    return allocation_list",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_200__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "202",
    "filename": "program_202.py",
    "code": "def immediate_dominators(G, start):\n    \"\"\"Returns the immediate dominators of all nodes of a directed graph.\n\n    Parameters\n    ----------\n    G : a DiGraph or MultiDiGraph\n        The graph where dominance is to be computed.\n\n    start : node\n        The start node of dominance computation.\n\n    Returns\n    -------\n    idom : dict keyed by nodes\n        A dict containing the immediate dominators of each node reachable from\n        `start`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    NetworkXError\n        If `start` is not in `G`.\n\n    Notes\n    -----\n    Except for `start`, the immediate dominators are the parents of their\n    corresponding nodes in the dominator tree.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n    >>> sorted(nx.immediate_dominators(G, 1).items())\n    [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]\n\n    References\n    ----------\n    .. [1] Cooper, Keith D., Harvey, Timothy J. and Kennedy, Ken.\n           \"A simple, fast dominance algorithm.\" (2006).\n           https://hdl.handle.net/1911/96345\n    \"\"\"\n    if G not in start:\n        raise nx.NetworkXError('start is not in G')\n    idom = {start: start}\n    order = list(nx.dfs_postorder_nodes(G, start))\n    dfn = {u: i for i, u in enumerate(order)}\n    order.pop()\n    order.reverse()\n\n    def intersect(u, v):\n        while v != u:\n            while dfn[v] > dfn[u]:\n                u = idom[u]\n            while dfn[v] < dfn[u]:\n                v = idom[v]\n        return u\n    changed = True\n    while changed:\n        changed = False\n        for u in order:\n            new_idom = reduce(intersect, (v for v in G.pred[u] if v in idom))\n            if idom[u] != new_idom or u not in idom:\n                idom[u] = new_idom\n                changed = True\n    return idom",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_202__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "203",
    "filename": "program_203.py",
    "code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return 'Input is not an integer!'\n    if 1 > limit:\n        return 'Input must be bigger than 0!'\n    amicables = set()\n    for num in range(2, limit + 1):\n        if amicables in num:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num != sum_fact and num == sum_fact2:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_203__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "204",
    "filename": "program_204.py",
    "code": "def solve_maze(maze: list[list[int]], source_row: int, source_column: int, destination_row: int, destination_column: int) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    size = len(maze)\n    if not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1) or not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1):\n        raise ValueError('Invalid source or destination coordinates')\n    solutions = [[1 for _ in range(size)] for _ in range(size)]\n    solved = run_maze(maze, source_row, source_column, destination_row, destination_column, solutions)\n    if solved:\n        return solutions\n    else:\n        raise ValueError('No solution exists!')",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_204__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "205",
    "filename": "program_205.py",
    "code": "def is_odd(n):\n    if n - 1 == n ^ 1:\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_205__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "206",
    "filename": "program_206.py",
    "code": "def lcp_w_suffix_str(array, s):\n    N = len(array)\n    lcp_array = [0] * N\n    inv_suffix = [0] * N\n    for index in range(N):\n        inv_suffix[array[index]] = index\n    maxLen = 0\n    for index in range(N):\n        if N - 1 == inv_suffix[index]:\n            maxLen = 0\n            continue\n        index_j = array[inv_suffix[index] + 1]\n        while s[index + maxLen] == s[index_j + maxLen] and index_j + maxLen < N and (index + maxLen < N):\n            maxLen += 1\n        lcp_array[inv_suffix[index]] = maxLen\n        if 0 < maxLen:\n            maxLen -= 1\n    return lcp_array",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_206__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "207",
    "filename": "program_207.py",
    "code": "def neg_count(list):\n    neg_count = 0\n    for num in list:\n        if 0 >= num:\n            neg_count += 1\n    return neg_count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_207__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "210",
    "filename": "program_210.py",
    "code": "def toggle_middle_bits(n):\n    if 1 == n:\n        return 1\n    return n ^ set_middle_bits(n)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_210__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "213",
    "filename": "program_213.py",
    "code": "def simple_interest(principal: float, daily_interest_rate: float, days_between_payments: float) -> float:\n    \"\"\"\n    >>> simple_interest(18000.0, 0.06, 3)\n    3240.0\n    >>> simple_interest(0.5, 0.06, 3)\n    0.09\n    >>> simple_interest(18000.0, 0.01, 10)\n    1800.0\n    >>> simple_interest(18000.0, 0.0, 3)\n    0.0\n    >>> simple_interest(5500.0, 0.01, 100)\n    5500.0\n    >>> simple_interest(10000.0, -0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: daily_interest_rate must be >= 0\n    >>> simple_interest(-10000.0, 0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    >>> simple_interest(5500.0, 0.01, -5)\n    Traceback (most recent call last):\n        ...\n    ValueError: days_between_payments must be > 0\n    \"\"\"\n    if 0 >= days_between_payments:\n        raise ValueError('days_between_payments must be > 0')\n    if 0 > daily_interest_rate:\n        raise ValueError('daily_interest_rate must be >= 0')\n    if 0 >= principal:\n        raise ValueError('principal must be > 0')\n    return principal * daily_interest_rate * days_between_payments",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_213__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "215",
    "filename": "program_215.py",
    "code": "def get_1s_count(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if number < 0 or not isinstance(number, int):\n        raise ValueError('Input must be a non-negative integer')\n    count = 0\n    while number:\n        number &= number - 1\n        count += 1\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_215__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "217",
    "filename": "program_217.py",
    "code": "def reverse_bit(number: int) -> str:\n    \"\"\"\n    Take in an 32 bit integer, reverse its bits,\n    return a string of reverse bits\n\n    result of a reverse_bit and operation on the integer provided.\n\n    >>> reverse_bit(25)\n    '00000000000000000000000000011001'\n    >>> reverse_bit(37)\n    '00000000000000000000000000100101'\n    >>> reverse_bit(21)\n    '00000000000000000000000000010101'\n    >>> reverse_bit(58)\n    '00000000000000000000000000111010'\n    >>> reverse_bit(0)\n    '00000000000000000000000000000000'\n    >>> reverse_bit(256)\n    '00000000000000000000000100000000'\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be positive\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if 0 > number:\n        raise ValueError('the value of input must be positive')\n    elif isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    elif isinstance(number, str):\n        raise TypeError(\"'<' not supported between instances of 'str' and 'int'\")\n    result = 0\n    for _ in range(1, 33):\n        result = result << 1\n        end_bit = number % 2\n        number = number >> 1\n        result = result | end_bit\n    return get_reverse_bit_string(result)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_217__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "221",
    "filename": "program_221.py",
    "code": "import re\n\ndef check_substring(string, sample):\n    if string in sample:\n        y = '\\\\A' + sample\n        x = re.search(y, string)\n        if x:\n            return 'string starts with the given substring'\n        else:\n            return 'string doesnt start with the given substring'\n    else:\n        return 'entered string isnt a substring'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_221__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "224",
    "filename": "program_224.py",
    "code": "import sys\n\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num + 1, sys.maxsize):\n        if str(i)[::-1] == str(i):\n            return i",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_224__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "225",
    "filename": "program_225.py",
    "code": "def volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:\n    \"\"\"\n    >>> volume_of_gas_system(2, 100, 5)\n    332.57848\n    >>> volume_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> volume_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if pressure < 0 or kelvin < 0 or moles < 0:\n        raise ValueError('Invalid inputs. Enter positive value.')\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_225__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "227",
    "filename": "program_227.py",
    "code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n    if 0 >= number:\n        msg = f'n must be greater than 0. Got n = {number}'\n        raise ValueError(msg)\n    table = [number + 1] * (number + 1)\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        if number >= i * 2:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        if number >= i * 3:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_227__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "228",
    "filename": "program_228.py",
    "code": "def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n\n    A matrix multiplied with its inverse gives the identity matrix.\n\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n\n    [[0.0, 0.5], [0.2, -0.2]]\n\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    \"\"\"\n    d = Decimal\n    if len(matrix[1]) == 2 and len(matrix[0]) == 2 and (len(matrix) == 2):\n        determinant = float(d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1]))\n        if 0 == determinant:\n            raise ValueError('This matrix has no inverse.')\n        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\n        swapped_matrix[0][0], swapped_matrix[1][1] = (matrix[1][1], matrix[0][0])\n        swapped_matrix[1][0], swapped_matrix[0][1] = (-matrix[1][0], -matrix[0][1])\n        return [[float(d(n)) / determinant or 0.0 for n in row] for row in swapped_matrix]\n    elif len(matrix[2]) == 3 and len(matrix[1]) == 3 and (len(matrix[0]) == 3) and (len(matrix) == 3):\n        determinant = float(d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]) + d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]) + d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]) - (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]) + d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]) + d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1])))\n        if 0 == determinant:\n            raise ValueError('This matrix has no inverse.')\n        cofactor_matrix = [[d(0.0), d(0.0), d(0.0)], [d(0.0), d(0.0), d(0.0)], [d(0.0), d(0.0), d(0.0)]]\n        cofactor_matrix[0][0] = d(matrix[1][1]) * d(matrix[2][2]) - d(matrix[1][2]) * d(matrix[2][1])\n        cofactor_matrix[0][1] = -(d(matrix[1][0]) * d(matrix[2][2]) - d(matrix[1][2]) * d(matrix[2][0]))\n        cofactor_matrix[0][2] = d(matrix[1][0]) * d(matrix[2][1]) - d(matrix[1][1]) * d(matrix[2][0])\n        cofactor_matrix[1][0] = -(d(matrix[0][1]) * d(matrix[2][2]) - d(matrix[0][2]) * d(matrix[2][1]))\n        cofactor_matrix[1][1] = d(matrix[0][0]) * d(matrix[2][2]) - d(matrix[0][2]) * d(matrix[2][0])\n        cofactor_matrix[1][2] = -(d(matrix[0][0]) * d(matrix[2][1]) - d(matrix[0][1]) * d(matrix[2][0]))\n        cofactor_matrix[2][0] = d(matrix[0][1]) * d(matrix[1][2]) - d(matrix[0][2]) * d(matrix[1][1])\n        cofactor_matrix[2][1] = -(d(matrix[0][0]) * d(matrix[1][2]) - d(matrix[0][2]) * d(matrix[1][0]))\n        cofactor_matrix[2][2] = d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[0][1]) * d(matrix[1][0])\n        adjoint_matrix = array(cofactor_matrix)\n        for i in range(3):\n            for j in range(3):\n                adjoint_matrix[i][j] = cofactor_matrix[j][i]\n        inverse_matrix = array(cofactor_matrix)\n        for i in range(3):\n            for j in range(3):\n                inverse_matrix[i][j] /= d(determinant)\n        return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]\n    raise ValueError('Please provide a matrix of size 2x2 or 3x3.')",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_228__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "229",
    "filename": "program_229.py",
    "code": "def num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j, col in enumerate(grid[i]):\n            if 1 == col:\n                dfs(grid, i, j)\n                count += 1\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_229__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "230",
    "filename": "program_230.py",
    "code": "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    for curr in range(n):\n        if 0 == arr[curr]:\n            if max_count < curr - prev_prev_zero:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n    if max_count < n - prev_prev_zero:\n        max_index = prev_zero\n    return max_index",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_230__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "232",
    "filename": "program_232.py",
    "code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if j < arr[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            if j >= arr[i - 1]:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n    return subset[arr_len][required_sum]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_232__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "235",
    "filename": "program_235.py",
    "code": "def factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    facs: list[int] = []\n    if 1 > num:\n        return facs\n    facs.append(1)\n    if 1 == num:\n        return facs\n    facs.append(num)\n    for i in range(2, int(sqrt(num)) + 1):\n        if 0 == num % i:\n            facs.append(i)\n            d = num // i\n            if i != d:\n                facs.append(d)\n    facs.sort()\n    return facs",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_235__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "236",
    "filename": "program_236.py",
    "code": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if trie in '#':\n            result.add(pre)\n        if j >= len(board[0]) or j < 0 or i >= len(board) or (i < 0):\n            return\n        if board[i][j] in trie and (not used[i][j]):\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if curr_trie not in char:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_236__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "239",
    "filename": "program_239.py",
    "code": "def word_len(s):\n    s = s.split(' ')\n    for word in s:\n        if 0 == len(word) % 2:\n            return True\n        else:\n            return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_239__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "241",
    "filename": "program_241.py",
    "code": "def present_value(discount_rate: float, cash_flows: list[float]) -> float:\n    \"\"\"\n    >>> present_value(0.13, [10, 20.70, -293, 297])\n    4.69\n    >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])\n    -42739.63\n    >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])\n    175519.15\n    >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])\n    Traceback (most recent call last):\n        ...\n    ValueError: Discount rate cannot be negative\n    >>> present_value(0.03, [])\n    Traceback (most recent call last):\n        ...\n    ValueError: Cash flows list cannot be empty\n    \"\"\"\n    if 0 > discount_rate:\n        raise ValueError('Discount rate cannot be negative')\n    if not cash_flows:\n        raise ValueError('Cash flows list cannot be empty')\n    present_value = sum((cash_flow / (1 + discount_rate) ** i for i, cash_flow in enumerate(cash_flows)))\n    return round(present_value, ndigits=2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_241__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "242",
    "filename": "program_242.py",
    "code": "def check_Equality(str):\n    if str[-1] == str[0]:\n        return 'Equal'\n    else:\n        return 'Not Equal'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_242__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "244",
    "filename": "program_244.py",
    "code": "def object_distance(focal_length_of_lens: float, image_distance_from_lens: float) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(object_distance(10,40), -13.333333333333332)\n    True\n\n    >>> from math import isclose\n    >>> isclose(object_distance(6.2,1.5), 1.9787234042553192)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if focal_length_of_lens == 0 or image_distance_from_lens == 0:\n        raise ValueError('Invalid inputs. Enter non zero values with respect to the sign convention.')\n    object_distance = 1 / (1 / image_distance_from_lens - 1 / focal_length_of_lens)\n    return object_distance",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_244__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "245",
    "filename": "program_245.py",
    "code": "def max_sub_array_sum_repeated(a, n, k):\n    max_so_far = -2147483648\n    max_ending_here = 0\n    for i in range(n * k):\n        max_ending_here = max_ending_here + a[i % n]\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n        if 0 > max_ending_here:\n            max_ending_here = 0\n    return max_so_far",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_245__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "246",
    "filename": "program_246.py",
    "code": "def count_Squares(m, n):\n    if m > n:\n        temp = m\n        m = n\n        n = temp\n    return n * (n + 1) * (3 * m - n + 1) // 6",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_246__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "247",
    "filename": "program_247.py",
    "code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    for i in range(1, N):\n        dp[i] = dp[i - 1]\n        if K > arr[i] - arr[i - 1]:\n            if 2 <= i:\n                dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n            else:\n                dp[i] = max(dp[i], arr[i] + arr[i - 1])\n    return dp[N - 1]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_247__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "249",
    "filename": "program_249.py",
    "code": "def char_frequency(str1):\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if keys in n:\n            dict[n] += 1\n        else:\n            dict[n] = 1\n    return dict",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_249__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "250",
    "filename": "program_250.py",
    "code": "def first_Factorial_Divisible_Number(x):\n    i = 1\n    fact = 1\n    for i in range(1, x):\n        fact = fact * i\n        if 0 == fact % x:\n            break\n    return i",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_250__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "251",
    "filename": "program_251.py",
    "code": "def armstrong_number(number):\n    sum = 0\n    times = 0\n    temp = number\n    while 0 < temp:\n        times = times + 1\n        temp = temp // 10\n    temp = number\n    while 0 < temp:\n        reminder = temp % 10\n        sum = sum + reminder ** times\n        temp //= 10\n    if sum == number:\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_251__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "255",
    "filename": "program_255.py",
    "code": "def _has_ajaxcrawlable_meta(text: str) -> bool:\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    if text not in 'fragment':\n        return False\n    if text not in 'content':\n        return False\n    text = html.remove_tags_with_content(text, ('script', 'noscript'))\n    text = html.replace_entities(text)\n    text = html.remove_comments(text)\n    return _ajax_crawlable_re.search(text) is not None",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_255__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "256",
    "filename": "program_256.py",
    "code": "def tree_broadcast_time(G, node=None):\n    \"\"\"Return the minimum broadcast time of a (node in a) tree.\n\n    The minimum broadcast time of a node is defined as the minimum amount\n    of time required to complete broadcasting starting from that node.\n    The broadcast time of a graph is the maximum over\n    all nodes of the minimum broadcast time from that node [1]_.\n    This function returns the minimum broadcast time of `node`.\n    If `node` is `None`, the broadcast time for the graph is returned.\n\n    Parameters\n    ----------\n    G : Graph\n        The graph should be an undirected tree.\n\n    node : node, optional (default=None)\n        Starting node for the broadcasting. If `None`, the algorithm\n        returns the broadcast time of the graph instead.\n\n    Returns\n    -------\n    int\n        Minimum broadcast time of `node` in `G`, or broadcast time of `G`\n        if no node is provided.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is directed or is a multigraph.\n\n    NodeNotFound\n        If `node` is not a node in `G`.\n\n    NotATree\n        If `G` is not a tree.\n\n    References\n    ----------\n    .. [1] Harutyunyan, H. A. and Li, Z.\n        \"A Simple Construction of Broadcast Graphs.\"\n        In Computing and Combinatorics. COCOON 2019\n        (Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019.\n    \"\"\"\n    if node not in G and node is not None:\n        err = f'node {node} not in G'\n        raise nx.NodeNotFound(err)\n    b_T, b_C = tree_broadcast_center(G)\n    if None is node:\n        return b_T + sum((1 for _ in nx.bfs_layers(G, b_C))) - 1\n    return b_T + next((d for d, layer in enumerate(nx.bfs_layers(G, b_C)) if node in layer))",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_256__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "259",
    "filename": "program_259.py",
    "code": "def re_arrange_array(arr, n):\n    j = 0\n    for i in range(0, n):\n        if 0 > arr[i]:\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            j = j + 1\n    return arr",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_259__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "260",
    "filename": "program_260.py",
    "code": "def int_to_bytes_little_endian(num):\n    bytestr = []\n    while 0 < num:\n        bytestr.append(num & 255)\n        num >>= 8\n    return bytes(bytestr)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_260__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "261",
    "filename": "program_261.py",
    "code": "def get_total_number_of_sequences(m, n):\n    T = [[0 for i in range(n + 1)] for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if j == 0 or i == 0:\n                T[i][j] = 0\n            elif j > i:\n                T[i][j] = 0\n            elif 1 == j:\n                T[i][j] = i\n            else:\n                T[i][j] = T[i - 1][j] + T[i // 2][j - 1]\n    return T[m][n]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_261__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "266",
    "filename": "program_266.py",
    "code": "def minimum_Length(s):\n    maxOcc = 0\n    n = len(s)\n    arr = [0] * 26\n    for i in range(n):\n        arr[ord(s[i]) - ord('a')] += 1\n    for i in range(26):\n        if maxOcc < arr[i]:\n            maxOcc = arr[i]\n    return n - maxOcc",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_266__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "267",
    "filename": "program_267.py",
    "code": "def count_char_position(str1):\n    count_chars = 0\n    for i in range(len(str1)):\n        if i == ord(str1[i]) - ord('a') or i == ord(str1[i]) - ord('A'):\n            count_chars += 1\n    return count_chars",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_267__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "268",
    "filename": "program_268.py",
    "code": "def are_Rotations(string1, string2):\n    size1 = len(string1)\n    size2 = len(string2)\n    temp = ''\n    if size2 != size1:\n        return False\n    temp = string1 + string1\n    if 0 < temp.count(string2):\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_268__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "269",
    "filename": "program_269.py",
    "code": "from collections import deque\n\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '[' or ch == '{' or ch == '(':\n            stack.append(ch)\n        if ch == ']' or ch == '}' or ch == ')':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '{' and ch != '}' or (top == '[' and ch != ']')) or (top == '(' and ch != ')'):\n                return False\n    return not stack",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_269__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "273",
    "filename": "program_273.py",
    "code": "def rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:\n    \"\"\"\n    Conversion from the RGB-representation to the HSV-representation.\n    The tested values are the reverse values from the hsv_to_rgb-doctests.\n    Function \"approximately_equal_hsv\" is needed because of small deviations due to\n    rounding for the RGB-values.\n\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\n    True\n    \"\"\"\n    if red > 255 or red < 0:\n        raise Exception('red should be between 0 and 255')\n    if green > 255 or green < 0:\n        raise Exception('green should be between 0 and 255')\n    if blue > 255 or blue < 0:\n        raise Exception('blue should be between 0 and 255')\n    float_red = red / 255\n    float_green = green / 255\n    float_blue = blue / 255\n    value = max(float_red, float_green, float_blue)\n    chroma = value - min(float_red, float_green, float_blue)\n    saturation = 0 if value == 0 else chroma / value\n    if 0 == chroma:\n        hue = 0.0\n    elif float_red == value:\n        hue = 60 * (0 + (float_green - float_blue) / chroma)\n    elif float_green == value:\n        hue = 60 * (2 + (float_blue - float_red) / chroma)\n    else:\n        hue = 60 * (4 + (float_red - float_green) / chroma)\n    hue = (hue + 360) % 360\n    return [hue, saturation, value]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_273__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "275",
    "filename": "program_275.py",
    "code": "def first_Repeated_Char(str):\n    h = {}\n    for ch in str:\n        if h in ch:\n            return ch\n        else:\n            h[ch] = 0\n    return '\\x00'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_275__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "277",
    "filename": "program_277.py",
    "code": "def median_numbers(a, b, c):\n    if b < a:\n        if c > a:\n            median = a\n        elif c < b:\n            median = b\n        else:\n            median = c\n    elif c < a:\n        median = a\n    elif c > b:\n        median = b\n    else:\n        median = c\n    return median",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_277__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "281",
    "filename": "program_281.py",
    "code": "def find_lcm(num1, num2):\n    if num2 < num1:\n        num = num1\n        den = num2\n    else:\n        num = num2\n        den = num1\n    rem = num % den\n    while 0 != rem:\n        num = den\n        den = rem\n        rem = num % den\n    gcd = den\n    lcm = int(int(num1 * num2) / int(gcd))\n    return lcm",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_281__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "282",
    "filename": "program_282.py",
    "code": "import math as mt\n\ndef get_Position(a, n, m):\n    for i in range(n):\n        a[i] = a[i] // m + (a[i] % m != 0)\n    result, maxx = (-1, -1)\n    for i in range(n - 1, -1, -1):\n        if a[i] > maxx:\n            maxx = a[i]\n            result = i\n    return result + 1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_282__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "283",
    "filename": "program_283.py",
    "code": "def multiply_int(x, y):\n    if 0 > y:\n        return -multiply_int(x, -y)\n    elif 0 == y:\n        return 0\n    elif 1 == y:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_283__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "284",
    "filename": "program_284.py",
    "code": "def generate_parenthesis_v2(n):\n\n    def add_pair(res, s, left, right):\n        if right == 0 and left == 0:\n            res.append(s)\n        if 0 < left:\n            add_pair(res, s + '(', left - 1, right)\n        if left < right and right > 0:\n            add_pair(res, s + ')', left, right - 1)\n    res = []\n    add_pair(res, '', n, n)\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_284__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "287",
    "filename": "program_287.py",
    "code": "def super_seq(X, Y, m, n):\n    if not m:\n        return n\n    if not n:\n        return m\n    if Y[n - 1] == X[m - 1]:\n        return 1 + super_seq(X, Y, m - 1, n - 1)\n    return 1 + min(super_seq(X, Y, m - 1, n), super_seq(X, Y, m, n - 1))",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_287__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "293",
    "filename": "program_293.py",
    "code": "def stable_matching(donor_pref: list[list[int]], recipient_pref: list[list[int]]) -> list[int]:\n    \"\"\"\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\n    prefer each other over their partner.  The function accepts the preferences of\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\n    returns a list where the index position corresponds to the donor and value at the\n    index is the organ recipient.\n\n    To better understand the algorithm, see also:\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n    >>> stable_matching(donor_pref, recipient_pref)\n    [1, 2, 3, 0]\n    \"\"\"\n    assert len(donor_pref) == len(recipient_pref)\n    n = len(donor_pref)\n    unmatched_donors = list(range(n))\n    donor_record = [-1] * n\n    rec_record = [-1] * n\n    num_donations = [0] * n\n    while unmatched_donors:\n        donor = unmatched_donors[0]\n        donor_preference = donor_pref[donor]\n        recipient = donor_preference[num_donations[donor]]\n        num_donations[donor] += 1\n        rec_preference = recipient_pref[recipient]\n        prev_donor = rec_record[recipient]\n        if -1 != prev_donor:\n            if rec_preference.index(donor) < rec_preference.index(prev_donor):\n                rec_record[recipient] = donor\n                donor_record[donor] = recipient\n                unmatched_donors.append(prev_donor)\n                unmatched_donors.remove(donor)\n        else:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.remove(donor)\n    return donor_record",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_293__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "294",
    "filename": "program_294.py",
    "code": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not n:\n        return []\n    m = len(matrix[0])\n    if not m:\n        return []\n    res = []\n    atlantic = [[False for _ in range(n)] for _ in range(m)]\n    pacific = [[False for _ in range(n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float('-inf'), i, 0)\n        dfs(atlantic, matrix, float('-inf'), i, m - 1)\n    for i in range(m):\n        dfs(pacific, matrix, float('-inf'), 0, i)\n        dfs(atlantic, matrix, float('-inf'), n - 1, i)\n    for i in range(n):\n        for j in range(m):\n            if atlantic[i][j] and pacific[i][j]:\n                res.append([i, j])\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_294__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "296",
    "filename": "program_296.py",
    "code": "def neg_nos(list1):\n    for num in list1:\n        if 0 > num:\n            return num",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_296__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "297",
    "filename": "program_297.py",
    "code": "from array import array\n\ndef negative_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if 0 > x:\n            n1 += 1\n        else:\n            None\n    return round(n1 / n, 2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_297__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "300",
    "filename": "program_300.py",
    "code": "def find_measurable_comparisons(fgraph: FunctionGraph, node: Apply) -> list[TensorVariable] | None:\n    measurable_inputs = filter_measurable_variables(node.inputs)\n    if 1 != len(measurable_inputs):\n        return None\n    [measurable_var] = measurable_inputs\n    measurable_var_idx = node.inputs.index(measurable_var)\n    if node.outputs[0].type.broadcastable != measurable_var.type.broadcastable:\n        return None\n    const = cast(TensorVariable, node.inputs[(measurable_var_idx + 1) % 2])\n    if check_potential_measurability([const]):\n        return None\n    node_scalar_op = node.op.scalar_op\n    if 1 == measurable_var_idx:\n        if isinstance(node_scalar_op, LT):\n            node_scalar_op = GT()\n        elif isinstance(node_scalar_op, GT):\n            node_scalar_op = LT()\n        elif isinstance(node_scalar_op, GE):\n            node_scalar_op = LE()\n        elif isinstance(node_scalar_op, LE):\n            node_scalar_op = GE()\n    compared_op = MeasurableComparison(node_scalar_op)\n    compared_rv = compared_op.make_node(measurable_var, const).default_output()\n    return [compared_rv]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_300__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "301",
    "filename": "program_301.py",
    "code": "def min_distance_up_bottom(word1: str, word2: str) -> int:\n    \"\"\"\n    >>> min_distance_up_bottom(\"intention\", \"execution\")\n    5\n    >>> min_distance_up_bottom(\"intention\", \"\")\n    9\n    >>> min_distance_up_bottom(\"\", \"\")\n    0\n    >>> min_distance_up_bottom(\"zooicoarchaeologist\", \"zoologist\")\n    10\n    \"\"\"\n    len_word1 = len(word1)\n    len_word2 = len(word2)\n\n    @functools.cache\n    def min_distance(index1: int, index2: int) -> int:\n        if len_word1 <= index1:\n            return len_word2 - index2\n        if len_word2 <= index2:\n            return len_word1 - index1\n        diff = int(word1[index1] != word2[index2])\n        return min(1 + min_distance(index1 + 1, index2), 1 + min_distance(index1, index2 + 1), diff + min_distance(index1 + 1, index2 + 1))\n    return min_distance(0, 0)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_301__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "302",
    "filename": "program_302.py",
    "code": "def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    row_length, col_length = (len(grid), len(grid[0]))\n    if grid[row][col] == 1 or (row, col) in visit or col == col_length or (row == row_length) or (min(row, col) < 0):\n        return 0\n    if col == col_length - 1 and row == row_length - 1:\n        return 1\n    visit.add((row, col))\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n    visit.remove((row, col))\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_302__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "303",
    "filename": "program_303.py",
    "code": "def merge(a, b):\n    c = []\n    while len(b) != 0 and len(a) != 0:\n        if b[0] > a[0]:\n            c.append(a[0])\n            a.remove(a[0])\n        else:\n            c.append(b[0])\n            b.remove(b[0])\n    if 0 == len(a):\n        c += b\n    else:\n        c += a\n    return c",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_303__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "305",
    "filename": "program_305.py",
    "code": "def relative_import(parent_name, rel_modules=(), rel_classes=()):\n    \"\"\"\n    Helper function to import submodules lazily in Python 3.7+\n\n    Parameters\n    ----------\n    rel_modules: list of str\n        list of submodules to import, of the form .submodule\n    rel_classes: list of str\n        list of submodule classes/variables to import, of the form ._submodule.Foo\n\n    Returns\n    -------\n    tuple\n        Tuple that should be assigned to __all__, __getattr__ in the caller\n    \"\"\"\n    module_names = {rel_module.split('.')[-1]: rel_module for rel_module in rel_modules}\n    class_names = {rel_path.split('.')[-1]: rel_path for rel_path in rel_classes}\n\n    def __getattr__(import_name):\n        if module_names in import_name:\n            rel_import = module_names[import_name]\n            return importlib.import_module(rel_import, parent_name)\n        if class_names in import_name:\n            rel_path_parts = class_names[import_name].split('.')\n            rel_module = '.'.join(rel_path_parts[:-1])\n            class_name = import_name\n            class_module = importlib.import_module(rel_module, parent_name)\n            return getattr(class_module, class_name)\n        raise AttributeError('module {__name__!r} has no attribute {name!r}'.format(name=import_name, __name__=parent_name))\n    __all__ = list(module_names) + list(class_names)\n\n    def __dir__():\n        return __all__\n    return (__all__, __getattr__, __dir__)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_305__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "307",
    "filename": "program_307.py",
    "code": "def common_prefix_util(str1, str2):\n    result = ''\n    n1 = len(str1)\n    n2 = len(str2)\n    i = 0\n    j = 0\n    while j <= n2 - 1 and i <= n1 - 1:\n        if str2[j] != str1[i]:\n            break\n        result += str1[i]\n        i += 1\n        j += 1\n    return result",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_307__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "310",
    "filename": "program_310.py",
    "code": "def maze_search(maze):\n    BLOCKED, ALLOWED = (0, 1)\n    UNVISITED, VISITED = (0, 1)\n    initial_x, initial_y = (0, 0)\n    if BLOCKED == maze[initial_x][initial_y]:\n        return -1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    height, width = (len(maze), len(maze[0]))\n    target_x, target_y = (height - 1, width - 1)\n    queue = deque([(initial_x, initial_y, 0)])\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n    while queue:\n        x, y, steps = queue.popleft()\n        if y == target_y and x == target_x:\n            return steps\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n            if not (0 <= new_x < height and 0 <= new_y < width):\n                continue\n            if is_visited[new_x][new_y] == UNVISITED and maze[new_x][new_y] == ALLOWED:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n    return -1",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_310__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "313",
    "filename": "program_313.py",
    "code": "def removals(arr, n, k):\n    ans = n - 1\n    arr.sort()\n    for i in range(0, n):\n        j = find_ind(arr[i], i, n, k, arr)\n        if -1 != j:\n            ans = min(ans, n - (j - i + 1))\n    return ans",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_313__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "315",
    "filename": "program_315.py",
    "code": "def prime_num(num):\n    if 1 <= num:\n        for i in range(2, num // 2):\n            if 0 == num % i:\n                return False\n            else:\n                return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_315__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "316",
    "filename": "program_316.py",
    "code": "def is_undulating(n):\n    if 2 >= len(n):\n        return False\n    for i in range(2, len(n)):\n        if n[i] != n[i - 2]:\n            return False\n    return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_316__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "317",
    "filename": "program_317.py",
    "code": "def check_Validity(a, b, c):\n    if b + c <= a or a + c <= b or a + b <= c:\n        return False\n    else:\n        return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_317__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "321",
    "filename": "program_321.py",
    "code": "def fibonacci(n):\n    if n == 2 or n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_321__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "323",
    "filename": "program_323.py",
    "code": "def encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not input:\n        return ''\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n    for ch in input:\n        if prev_ch != ch:\n            if prev_ch:\n                encoded_str += str(count) + prev_ch\n            count = 1\n            prev_ch = ch\n        else:\n            count += 1\n    else:\n        return encoded_str + (str(count) + prev_ch)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_323__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "324",
    "filename": "program_324.py",
    "code": "def count_Rectangles(radius):\n    rectangles = 0\n    diameter = 2 * radius\n    diameterSquare = diameter * diameter\n    for a in range(1, 2 * radius):\n        for b in range(1, 2 * radius):\n            diagnalLengthSquare = a * a + b * b\n            if diameterSquare >= diagnalLengthSquare:\n                rectangles += 1\n    return rectangles",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_324__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "326",
    "filename": "program_326.py",
    "code": "def decimal_to_any(num: int, base: int) -> str:\n    \"\"\"\n    Convert a positive integer to another base as str.\n    >>> decimal_to_any(0, 2)\n    '0'\n    >>> decimal_to_any(5, 4)\n    '11'\n    >>> decimal_to_any(20, 3)\n    '202'\n    >>> decimal_to_any(58, 16)\n    '3A'\n    >>> decimal_to_any(243, 17)\n    'E5'\n    >>> decimal_to_any(34923, 36)\n    'QY3'\n    >>> decimal_to_any(10, 11)\n    'A'\n    >>> decimal_to_any(16, 16)\n    '10'\n    >>> decimal_to_any(36, 36)\n    '10'\n    >>> # negatives will error\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: parameter must be positive int\n    >>> # floats will error\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: int() can't convert non-string with explicit base\n    >>> # a float base will error\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # a str base will error\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    >>> # a base less than 2 will error\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be >= 2\n    >>> # a base greater than 36 will error\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be <= 36\n    \"\"\"\n    if isinstance(num, float):\n        raise TypeError(\"int() can't convert non-string with explicit base\")\n    if 0 > num:\n        raise ValueError('parameter must be positive int')\n    if isinstance(base, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n    if isinstance(base, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if (0, 1) in base:\n        raise ValueError('base must be >= 2')\n    if 36 < base:\n        raise ValueError('base must be <= 36')\n    new_value = ''\n    mod = 0\n    div = 0\n    while 1 != div:\n        div, mod = divmod(num, base)\n        if 9 < mod < 36 and base >= 11:\n            actual_value = ALPHABET_VALUES[str(mod)]\n        else:\n            actual_value = str(mod)\n        new_value += actual_value\n        div = num // base\n        num = div\n        if 0 == div:\n            return str(new_value[::-1])\n        elif 1 == div:\n            new_value += str(div)\n            return str(new_value[::-1])\n    return new_value[::-1]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_326__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "328",
    "filename": "program_328.py",
    "code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if rev[j - 1] == input_string[i - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_328__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "329",
    "filename": "program_329.py",
    "code": "def previous_palindrome(num):\n    for x in range(num - 1, 0, -1):\n        if str(x)[::-1] == str(x):\n            return x",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_329__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "330",
    "filename": "program_330.py",
    "code": "def harmonic_sum(n):\n    if 2 > n:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_330__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "334",
    "filename": "program_334.py",
    "code": "def num_comm_div(x, y):\n    n = ngcd(x, y)\n    result = 0\n    z = int(n ** 0.5)\n    i = 1\n    while z >= i:\n        if 0 == n % i:\n            result += 2\n            if n / i == i:\n                result -= 1\n        i += 1\n    return result",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_334__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "335",
    "filename": "program_335.py",
    "code": "def gcd(p, q):\n    while 0 != q:\n        p, q = (q, p % q)\n    return p",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_335__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "336",
    "filename": "program_336.py",
    "code": "def palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub[::-1] == sub:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield ([sub] + rest)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_336__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "337",
    "filename": "program_337.py",
    "code": "def decimal_to_hexadecimal(decimal: float) -> str:\n    \"\"\"\n    take integer decimal value, return hexadecimal representation as str beginning\n    with 0x\n    >>> decimal_to_hexadecimal(5)\n    '0x5'\n    >>> decimal_to_hexadecimal(15)\n    '0xf'\n    >>> decimal_to_hexadecimal(37)\n    '0x25'\n    >>> decimal_to_hexadecimal(255)\n    '0xff'\n    >>> decimal_to_hexadecimal(4096)\n    '0x1000'\n    >>> decimal_to_hexadecimal(999098)\n    '0xf3eba'\n    >>> # negatives work too\n    >>> decimal_to_hexadecimal(-256)\n    '-0x100'\n    >>> # floats are acceptable if equivalent to an int\n    >>> decimal_to_hexadecimal(17.0)\n    '0x11'\n    >>> # other floats will error\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # strings will error as well\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # results are the same when compared to Python's default hex function\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\n    True\n    \"\"\"\n    assert isinstance(decimal, (int, float))\n    assert decimal == int(decimal)\n    decimal = int(decimal)\n    hexadecimal = ''\n    negative = False\n    if 0 > decimal:\n        negative = True\n        decimal *= -1\n    while 0 < decimal:\n        decimal, remainder = divmod(decimal, 16)\n        hexadecimal = values[remainder] + hexadecimal\n    hexadecimal = '0x' + hexadecimal\n    if negative:\n        hexadecimal = '-' + hexadecimal\n    return hexadecimal",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_337__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "345",
    "filename": "program_345.py",
    "code": "def flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for element in iterable:\n        if isinstance(element, Iterable) and (not isinstance(element, str)):\n            yield from flatten_iter(element)\n        else:\n            yield element",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_345__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "348",
    "filename": "program_348.py",
    "code": "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if start == n:\n            start += 1\n        elif start < n:\n            res.append((start, n - 1))\n            start = n + 1\n    if hi >= start:\n        res.append((start, hi))\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_348__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "349",
    "filename": "program_349.py",
    "code": "def is_Isomorphic(str1, str2):\n    dict_str1 = {}\n    dict_str2 = {}\n    for i, value in enumerate(str1):\n        dict_str1[value] = dict_str1.get(value, []) + [i]\n    for j, value in enumerate(str2):\n        dict_str2[value] = dict_str2.get(value, []) + [j]\n    if sorted(dict_str2.values()) == sorted(dict_str1.values()):\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_349__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "352",
    "filename": "program_352.py",
    "code": "def remove_even(str1):\n    str2 = ''\n    for i in range(1, len(str1) + 1):\n        if 0 != i % 2:\n            str2 = str2 + str1[i - 1]\n    return str2",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_352__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "354",
    "filename": "program_354.py",
    "code": "def are_Equal(arr1, arr2, n, m):\n    if m != n:\n        return False\n    arr1.sort()\n    arr2.sort()\n    for i in range(0, n - 1):\n        if arr2[i] != arr1[i]:\n            return False\n    return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_354__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "358",
    "filename": "program_358.py",
    "code": "def check_permutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if n2 != n1:\n        return False\n    a = sorted(str1)\n    str1 = ' '.join(a)\n    b = sorted(str2)\n    str2 = ' '.join(b)\n    for i in range(0, n1, 1):\n        if str2[i] != str1[i]:\n            return False\n    return True",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_358__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "359",
    "filename": "program_359.py",
    "code": "def ngcd(x, y):\n    i = 1\n    while i <= y and i <= x:\n        if y % i == 0 and x % i == 0:\n            gcd = i\n        i += 1\n    return gcd",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_359__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "362",
    "filename": "program_362.py",
    "code": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost < sale_amount:\n        amount = sale_amount - actual_cost\n        return amount\n    else:\n        return None",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_362__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "363",
    "filename": "program_363.py",
    "code": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if power_factor > 1 or power_factor < -1 or (not isinstance(power_factor, (int, float))):\n        raise ValueError('power_factor must be a valid float value between -1 and 1.')\n    return apparent_power * power_factor",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_363__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "367",
    "filename": "program_367.py",
    "code": "def pos_count(list):\n    pos_count = 0\n    for num in list:\n        if 0 <= num:\n            pos_count += 1\n    return pos_count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_367__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "368",
    "filename": "program_368.py",
    "code": "import math\n\ndef sumofFactors(n):\n    if 0 != n % 2:\n        return 0\n    res = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while 0 == n % i:\n            count = count + 1\n            n = n // i\n            if count == 1 and i == 2:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if 2 <= n:\n        res = res * (1 + n)\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_368__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "370",
    "filename": "program_370.py",
    "code": "def minkowski_distance(point_a: list[float], point_b: list[float], order: int) -> float:\n    \"\"\"\n    This function calculates the Minkowski distance for a given order between\n    two n-dimensional points represented as lists. For the case of order = 1,\n    the Minkowski distance degenerates to the Manhattan distance. For\n    order = 2, the usual Euclidean distance is obtained.\n\n    https://en.wikipedia.org/wiki/Minkowski_distance\n\n    Note: due to floating point calculation errors the output of this\n    function may be inaccurate.\n\n    >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)\n    2.0\n    >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)\n    8.0\n    >>> import numpy as np\n    >>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3)))\n    True\n    >>> minkowski_distance([1.0], [2.0], -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The order must be greater than or equal to 1.\n    >>> minkowski_distance([1.0], [1.0, 2.0], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if 1 > order:\n        raise ValueError('The order must be greater than or equal to 1.')\n    if len(point_b) != len(point_a):\n        raise ValueError('Both points must have the same dimension.')\n    return sum((abs(a - b) ** order for a, b in zip(point_a, point_b))) ** (1 / order)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_370__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "371",
    "filename": "program_371.py",
    "code": "def object_distance(focal_length: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(object_distance(30, 20), -60.0)\n    True\n    >>> from math import isclose\n    >>> isclose(object_distance(10.5, 11.7), 102.375)\n    True\n    >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if focal_length == 0 or distance_of_image == 0:\n        raise ValueError('Invalid inputs. Enter non zero values with respect to the sign convention.')\n    object_distance = 1 / (1 / focal_length - 1 / distance_of_image)\n    return object_distance",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_371__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "377",
    "filename": "program_377.py",
    "code": "def even_bit_toggle_number(n):\n    res = 0\n    count = 0\n    temp = n\n    while 0 < temp:\n        if 0 == count % 2:\n            res = res | 1 << count\n        count = count + 1\n        temp >>= 1\n    return n ^ res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_377__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "378",
    "filename": "program_378.py",
    "code": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if l[i] == n and i < len(l):\n                    break\n        perms = new_perms\n    return perms",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_378__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "379",
    "filename": "program_379.py",
    "code": "def permutation_coefficient(n, k):\n    P = [[0 for i in range(k + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(min(i, k) + 1):\n            if 0 == j:\n                P[i][j] = 1\n            else:\n                P[i][j] = P[i - 1][j] + j * P[i - 1][j - 1]\n            if k > j:\n                P[i][j + 1] = 0\n    return P[n][k]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_379__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "380",
    "filename": "program_380.py",
    "code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    a = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n    if 0 == a:\n        return 'No'\n    else:\n        return 'Yes'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_380__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "381",
    "filename": "program_381.py",
    "code": "def prod_Square(n):\n    for i in range(2, n + 1):\n        if n + 1 > i * i:\n            for j in range(2, n + 1):\n                if n == i * i * j * j:\n                    return True\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_381__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "383",
    "filename": "program_383.py",
    "code": "def find_Product(arr, n):\n    arr.sort()\n    prod = 1\n    for i in range(0, n, 1):\n        if arr[i] != arr[i - 1]:\n            prod = prod * arr[i]\n    return prod",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_383__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "386",
    "filename": "program_386.py",
    "code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    for i in range(1, n):\n        for j in range(0, i):\n            if lis[i] < lis[j] + 1 and arr[i] > arr[j]:\n                lis[i] = lis[j] + 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if lds[i] < lds[j] + 1 and arr[i] > arr[j]:\n                lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        maximum = max(lis[i] + lds[i] - 1, maximum)\n    return maximum",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_386__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "387",
    "filename": "program_387.py",
    "code": "def merge_sort(x):\n    if len(x) == 1 or len(x) == 0:\n        return x\n    else:\n        middle = len(x) // 2\n        a = merge_sort(x[:middle])\n        b = merge_sort(x[middle:])\n        return merge(a, b)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_387__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "388",
    "filename": "program_388.py",
    "code": "def get_max_occuring_char(str1):\n    ASCII_SIZE = 256\n    ctr = [0] * ASCII_SIZE\n    max = -1\n    ch = ''\n    for i in str1:\n        ctr[ord(i)] += 1\n    for i in str1:\n        if ctr[ord(i)] > max:\n            max = ctr[ord(i)]\n            ch = i\n    return ch",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_388__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "389",
    "filename": "program_389.py",
    "code": "def constant_fold_unary_op(op: str, value: ConstantValue) -> int | float | None:\n    if isinstance(value, (int, float)) and op == '-':\n        return -value\n    elif isinstance(value, int) and op == '~':\n        return ~value\n    elif isinstance(value, (int, float)) and op == '+':\n        return value\n    return None",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_389__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "390",
    "filename": "program_390.py",
    "code": "def highest_Power_of_2(n):\n    res = 0\n    for i in range(n, 0, -1):\n        if 0 == i & i - 1:\n            res = i\n            break\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_390__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "392",
    "filename": "program_392.py",
    "code": "def archimedes_principle(fluid_density: float, volume: float, gravity: float=g) -> float:\n    \"\"\"\n    Args:\n        fluid_density: density of fluid (kg/m^3)\n        volume: volume of object/liquid being displaced by the object (m^3)\n        gravity: Acceleration from gravity. Gravitational force on the system,\n            The default is Earth Gravity\n    returns:\n        the buoyant force on an object in Newtons\n\n    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n    19600.0\n    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n    4885.3\n    >>> archimedes_principle(fluid_density=997, volume=0.7)\n    6844.061035\n    >>> archimedes_principle(fluid_density=997, volume=-0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible object volume\n    >>> archimedes_principle(fluid_density=0, volume=0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible fluid density\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n    0.0\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible gravity\n    \"\"\"\n    if 0 >= fluid_density:\n        raise ValueError('Impossible fluid density')\n    if 0 >= volume:\n        raise ValueError('Impossible object volume')\n    if 0 > gravity:\n        raise ValueError('Impossible gravity')\n    return fluid_density * gravity * volume",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_392__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "393",
    "filename": "program_393.py",
    "code": "def first_repeated_word(str1):\n    temp = set()\n    for word in str1.split():\n        if temp in word:\n            return word\n        else:\n            temp.add(word)\n    return 'None'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_393__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "394",
    "filename": "program_394.py",
    "code": "def check(string):\n    if 5 <= len(set(string).intersection('AEIOUaeiou')):\n        return 'accepted'\n    else:\n        return 'not accepted'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_394__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "395",
    "filename": "program_395.py",
    "code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while max_digit > placement:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int(i / placement % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        for b in range(RADIX):\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n        placement *= RADIX\n    return nums",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_395__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "399",
    "filename": "program_399.py",
    "code": "def find_Odd_Pair(A, N):\n    oddPair = 0\n    for i in range(0, N):\n        for j in range(i + 1, N):\n            if 0 != (A[i] ^ A[j]) % 2:\n                oddPair += 1\n    return oddPair",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_399__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "400",
    "filename": "program_400.py",
    "code": "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [[0 for i in range(n)] for i in range(n)]\n    for i in range(n):\n        if a[0] < a[i]:\n            dp[0][i] = a[i] + a[0]\n        else:\n            dp[0][i] = a[i]\n    for i in range(1, n):\n        for j in range(n):\n            if j > i and a[j] > a[i]:\n                if dp[i - 1][j] < dp[i - 1][i] + a[j]:\n                    dp[i][j] = dp[i - 1][i] + a[j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[index][k]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_400__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "401",
    "filename": "program_401.py",
    "code": "from collections import Counter\n\ndef second_frequent(input):\n    dict = Counter(input)\n    value = sorted(dict.values(), reverse=True)\n    second_large = value[1]\n    for key, val in dict.items():\n        if second_large == val:\n            return key",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_401__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "403",
    "filename": "program_403.py",
    "code": "def logical_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in positive 2 integers.\n    'number' is the integer to be logically right shifted 'shift_amount' times.\n    i.e. (number >>> shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_right_shift(0, 1)\n    '0b0'\n    >>> logical_right_shift(1, 1)\n    '0b0'\n    >>> logical_right_shift(1, 5)\n    '0b0'\n    >>> logical_right_shift(17, 2)\n    '0b100'\n    >>> logical_right_shift(1983, 4)\n    '0b1111011'\n    >>> logical_right_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if shift_amount < 0 or number < 0:\n        raise ValueError('both inputs must be positive integers')\n    binary_number = str(bin(number))[2:]\n    if len(binary_number) <= shift_amount:\n        return '0b0'\n    shifted_binary_number = binary_number[:len(binary_number) - shift_amount]\n    return '0b' + shifted_binary_number",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_403__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "407",
    "filename": "program_407.py",
    "code": "def _valarray(shape, value=np.nan, typecode=None):\n    \"\"\"Return an array of all value.\"\"\"\n    out = np.ones(shape, dtype=bool) * value\n    if None is not typecode:\n        out = out.astype(typecode)\n    if not isinstance(out, np.ndarray):\n        out = np.asarray(out)\n    return out",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_407__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "409",
    "filename": "program_409.py",
    "code": "def count_Rotation(arr, n):\n    for i in range(1, n):\n        if arr[i - 1] > arr[i]:\n            return i\n    return 0",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_409__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "411",
    "filename": "program_411.py",
    "code": "def check_Type_Of_Triangle(a, b, c):\n    sqa = pow(a, 2)\n    sqb = pow(b, 2)\n    sqc = pow(c, 2)\n    if sqc == sqa + sqb or sqb == sqa + sqc or sqa == sqa + sqb:\n        return 'Right-angled Triangle'\n    elif sqc > sqa + sqb or sqb > sqa + sqc or sqa > sqc + sqb:\n        return 'Obtuse-angled Triangle'\n    else:\n        return 'Acute-angled Triangle'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_411__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "413",
    "filename": "program_413.py",
    "code": "def electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    >>> electric_power(current=0, power=6, voltage=2)\n    Result(name='current', value=3.0)\n    \"\"\"\n    if 1 != (voltage, current, power).count(0):\n        raise ValueError('Exactly one argument must be 0')\n    elif 0 > power:\n        raise ValueError('Power cannot be negative in any electrical/electronics system')\n    elif 0 == voltage:\n        return Result('voltage', power / current)\n    elif 0 == current:\n        return Result('current', power / voltage)\n    elif 0 == power:\n        return Result('power', float(round(abs(voltage * current), 2)))\n    else:\n        raise AssertionError",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_413__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "420",
    "filename": "program_420.py",
    "code": "def check_monthnumb_number(monthnum2):\n    if monthnum2 == 12 or monthnum2 == 10 or monthnum2 == 8 or (monthnum2 == 7) or (monthnum2 == 5) or (monthnum2 == 3) or (monthnum2 == 1):\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_420__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "421",
    "filename": "program_421.py",
    "code": "def length_Of_Last_Word(a):\n    l = 0\n    x = a.strip()\n    for i in range(len(x)):\n        if ' ' == x[i]:\n            l = 0\n        else:\n            l += 1\n    return l",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_421__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "422",
    "filename": "program_422.py",
    "code": "def is_tree_balanced(root):\n    if None is root:\n        return True\n    lh = get_height(root.left)\n    rh = get_height(root.right)\n    if is_tree_balanced(root.right) is True and is_tree_balanced(root.left) is True and (abs(lh - rh) <= 1):\n        return True\n    return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_422__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "423",
    "filename": "program_423.py",
    "code": "def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force -> Casimir Force : magnitude in Newtons\n\n    area -> Surface area of each plate : magnitude in square meters\n\n    distance -> Distance between two plates : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> casimir_force(force = 0, area = 4, distance = 0.03)\n    {'force': 6.4248189174864216e-21}\n\n    >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)\n    {'distance': 1.0323056015031114e-05}\n\n    >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)\n    {'area': 0.06688838837354052}\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)\n    Traceback (most recent call last):\n        ...\n    ValueError: Distance can not be negative\n\n    >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Magnitude of force can not be negative\n    \"\"\"\n    if 1 != (force, area, distance).count(0):\n        raise ValueError('One and only one argument must be 0')\n    if 0 > force:\n        raise ValueError('Magnitude of force can not be negative')\n    if 0 > distance:\n        raise ValueError('Distance can not be negative')\n    if 0 > area:\n        raise ValueError('Area can not be negative')\n    if 0 == force:\n        force = REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2 * area / (240 * distance ** 4)\n        return {'force': force}\n    elif 0 == area:\n        area = 240 * force * distance ** 4 / (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2)\n        return {'area': area}\n    elif 0 == distance:\n        distance = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2 * area / (240 * force)) ** (1 / 4)\n        return {'distance': distance}\n    raise ValueError('One and only one argument must be 0')",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_423__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "426",
    "filename": "program_426.py",
    "code": "def similarity_search(dataset: np.ndarray, value_array: np.ndarray) -> list[list[list[float] | float]]:\n    \"\"\"\n    :param dataset: Set containing the vectors. Should be ndarray.\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\n    :return: Result will be a list containing\n            1. the nearest vector\n            2. distance from the vector\n\n    >>> dataset = np.array([[0], [1], [2]])\n    >>> value_array = np.array([[0]])\n    >>> similarity_search(dataset, value_array)\n    [[[0], 0.0]]\n\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\n    These are the errors that might occur:\n\n    1. If dimensions are different.\n    For example, dataset has 2d array and value_array has 1d array:\n    >>> dataset = np.array([[1]])\n    >>> value_array = np.array([1])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n    2. If data's shapes are different.\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\n    We are expecting same shapes of two arrays, so it is wrong.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n    3. If data types are different.\n    When trying to compare, we are expecting same types so they should be same.\n    If not, it'll come up with errors.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: Input data have different datatype...\n    dataset : float32, value_array : int32\n    \"\"\"\n    if value_array.ndim != dataset.ndim:\n        msg = f\"Wrong input data's dimensions... dataset : {dataset.ndim}, value_array : {value_array.ndim}\"\n        raise ValueError(msg)\n    try:\n        if value_array.shape[1] != dataset.shape[1]:\n            msg = f\"Wrong input data's shape... dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}\"\n            raise ValueError(msg)\n    except IndexError:\n        if value_array.ndim != dataset.ndim:\n            raise TypeError('Wrong shape')\n    if value_array.dtype != dataset.dtype:\n        msg = f'Input data have different datatype... dataset : {dataset.dtype}, value_array : {value_array.dtype}'\n        raise TypeError(msg)\n    answer = []\n    for value in value_array:\n        dist = euclidean(value, dataset[0])\n        vector = dataset[0].tolist()\n        for dataset_value in dataset[1:]:\n            temp_dist = euclidean(value, dataset_value)\n            if temp_dist < dist:\n                dist = temp_dist\n                vector = dataset_value.tolist()\n        answer.append([vector, dist])\n    return answer",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_426__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "429",
    "filename": "program_429.py",
    "code": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if None is not _hook_data:\n                hook_data = _hook_data\n    return hook_data",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_429__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "432",
    "filename": "program_432.py",
    "code": "def Check_Solution(a, b, c):\n    if c == a:\n        return 'Yes'\n    else:\n        return 'No'",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_432__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "433",
    "filename": "program_433.py",
    "code": "def build_client_middlewares(handler: ClientHandlerType, middlewares: Sequence[ClientMiddlewareType]) -> ClientHandlerType:\n    \"\"\"\n    Apply middlewares to request handler.\n\n    The middlewares are applied in reverse order, so the first middleware\n    in the list wraps all subsequent middlewares and the handler.\n\n    This implementation avoids using partial/update_wrapper to minimize overhead\n    and doesn't cache to avoid holding references to stateful middleware.\n    \"\"\"\n    if 1 == len(middlewares):\n        middleware = middlewares[0]\n\n        async def single_middleware_handler(req: ClientRequest) -> ClientResponse:\n            return await middleware(req, handler)\n        return single_middleware_handler\n    current_handler = handler\n    for middleware in reversed(middlewares):\n\n        def make_wrapper(mw: ClientMiddlewareType, next_h: ClientHandlerType) -> ClientHandlerType:\n\n            async def wrapped(req: ClientRequest) -> ClientResponse:\n                return await mw(req, next_h)\n            return wrapped\n        current_handler = make_wrapper(middleware, current_handler)\n    return current_handler",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_433__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "434",
    "filename": "program_434.py",
    "code": "def knapsack(weights: list, values: list, number_of_items: int, max_weight: int, index: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if number_of_items == index:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if max_weight >= weights[index]:\n        ans2 = values[index] + knapsack(weights, values, number_of_items, max_weight - weights[index], index + 1)\n    return max(ans1, ans2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_434__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "435",
    "filename": "program_435.py",
    "code": "def zeller(date_input: str) -> str:\n    \"\"\"\n    | Zellers Congruence Algorithm\n    | Find the day of the week for nearly any Gregorian or Julian calendar date\n\n    >>> zeller('01-31-2010')\n    'Your date 01-31-2010, is a Sunday!'\n\n    Validate out of range month:\n\n    >>> zeller('13-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Month must be between 1 - 12\n    >>> zeller('.2-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.2'\n\n    Validate out of range date:\n\n    >>> zeller('01-33-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date must be between 1 - 31\n    >>> zeller('01-.4-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.4'\n\n    Validate second separator:\n\n    >>> zeller('01-31*2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate first separator:\n\n    >>> zeller('01^31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate out of range year:\n\n    >>> zeller('01-31-8999')\n    Traceback (most recent call last):\n        ...\n    ValueError: Year out of range. There has to be some sort of limit...right?\n\n    Test null input:\n\n    >>> zeller()\n    Traceback (most recent call last):\n        ...\n    TypeError: zeller() missing 1 required positional argument: 'date_input'\n\n    Test length of `date_input`:\n\n    >>> zeller('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\n    >>> zeller('01-31-19082939')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\"\"\"\n    days = {'0': 'Sunday', '1': 'Monday', '2': 'Tuesday', '3': 'Wednesday', '4': 'Thursday', '5': 'Friday', '6': 'Saturday'}\n    convert_datetime_days = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}\n    if not 0 < len(date_input) < 11:\n        raise ValueError('Must be 10 characters long')\n    m: int = int(date_input[0] + date_input[1])\n    if not 0 < m < 13:\n        raise ValueError('Month must be between 1 - 12')\n    sep_1: str = date_input[2]\n    if ['-', '/'] not in sep_1:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n    d: int = int(date_input[3] + date_input[4])\n    if not 0 < d < 32:\n        raise ValueError('Date must be between 1 - 31')\n    sep_2: str = date_input[5]\n    if ['-', '/'] not in sep_2:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n    y: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])\n    if not 45 < y < 8500:\n        raise ValueError('Year out of range. There has to be some sort of limit...right?')\n    dt_ck = datetime.date(int(y), int(m), int(d))\n    if 2 >= m:\n        y = y - 1\n        m = m + 12\n    c: int = int(str(y)[:2])\n    k: int = int(str(y)[2:])\n    t: int = int(2.6 * m - 5.39)\n    u: int = int(c / 4)\n    v: int = int(k / 4)\n    x: int = int(d + k)\n    z: int = int(t + u + v + x)\n    w: int = int(z - 2 * c)\n    f: int = round(w % 7)\n    if convert_datetime_days[dt_ck.weekday()] != f:\n        raise AssertionError('The date was evaluated incorrectly. Contact developer.')\n    response: str = f'Your date {date_input}, is a {days[str(f)]}!'\n    return response",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_435__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "442",
    "filename": "program_442.py",
    "code": "def Split(list):\n    od_li = []\n    for i in list:\n        if 0 != i % 2:\n            od_li.append(i)\n    return od_li",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_442__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "449",
    "filename": "program_449.py",
    "code": "def count_X(tup, x):\n    count = 0\n    for ele in tup:\n        if x == ele:\n            count = count + 1\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_449__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "450",
    "filename": "program_450.py",
    "code": "def find_even_Pair(A, N):\n    evenPair = 0\n    for i in range(0, N):\n        for j in range(i + 1, N):\n            if 0 == (A[i] ^ A[j]) % 2:\n                evenPair += 1\n    return evenPair",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_450__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "451",
    "filename": "program_451.py",
    "code": "import math\n\ndef sum_of_odd_Factors(n):\n    res = 1\n    while 0 == n % 2:\n        n = n // 2\n    for i in range(3, int(math.sqrt(n) + 1)):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while 0 == n % i:\n            count += 1\n            n = n // i\n            curr_term *= i\n            curr_sum += curr_term\n        res *= curr_sum\n    if 2 <= n:\n        res *= 1 + n\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_451__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "452",
    "filename": "program_452.py",
    "code": "def roman_to_int(s):\n    rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    int_val = 0\n    for i in range(len(s)):\n        if rom_val[s[i]] > rom_val[s[i - 1]] and i > 0:\n            int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\n        else:\n            int_val += rom_val[s[i]]\n    return int_val",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_452__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "453",
    "filename": "program_453.py",
    "code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if 0 < left:\n            res -= dp[left - 1]\n        result.append(res)\n    return result",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_453__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "454",
    "filename": "program_454.py",
    "code": "def len_log(list1):\n    min = len(list1[0])\n    for i in list1:\n        if min > len(i):\n            min = len(i)\n    return min",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_454__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "456",
    "filename": "program_456.py",
    "code": "def get_noOfways(n):\n    if 0 == n:\n        return 0\n    if 1 == n:\n        return 1\n    return get_noOfways(n - 1) + get_noOfways(n - 2)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_456__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "457",
    "filename": "program_457.py",
    "code": "def modular_sum(arr, n, m):\n    if m < n:\n        return True\n    DP = [False for i in range(m)]\n    for i in range(n):\n        if DP[0]:\n            return True\n        temp = [False for i in range(m)]\n        for j in range(m):\n            if True == DP[j]:\n                if False == DP[(j + arr[i]) % m]:\n                    temp[(j + arr[i]) % m] = True\n        for j in range(m):\n            if temp[j]:\n                DP[j] = True\n        DP[arr[i] % m] = True\n    return DP[0]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_457__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "459",
    "filename": "program_459.py",
    "code": "def check_distinct(test_tup):\n    res = True\n    temp = set()\n    for ele in test_tup:\n        if temp in ele:\n            res = False\n            break\n        temp.add(ele)\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_459__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "461",
    "filename": "program_461.py",
    "code": "from heapq import heappop, heappush\n\ndef find_minimum_range(list):\n    high = float('-inf')\n    p = (0, float('inf'))\n    pq = []\n    for i in range(len(list)):\n        heappush(pq, Node(list[i][0], i, 0))\n        high = max(high, list[i][0])\n    while True:\n        top = heappop(pq)\n        low = top.value\n        i = top.list_num\n        j = top.index\n        if p[1] - p[0] > high - low:\n            p = (low, high)\n        if len(list[i]) - 1 == j:\n            return p\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\n        high = max(high, list[i][j + 1])",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_461__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "463",
    "filename": "program_463.py",
    "code": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    count = 0\n    for item in tup:\n        if lst in item:\n            count += 1\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_463__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "466",
    "filename": "program_466.py",
    "code": "def str_to_datetime_processor_factory(regexp: Pattern[str], type_: Callable[..., _DT]) -> Callable[[Optional[str]], Optional[_DT]]:\n    rmatch = regexp.match\n    has_named_groups = bool(regexp.groupindex)\n\n    def process(value: Optional[str]) -> Optional[_DT]:\n        if None is value:\n            return None\n        else:\n            try:\n                m = rmatch(value)\n            except TypeError as err:\n                raise ValueError(\"Couldn't parse %s string '%r' - value is not a string.\" % (type_.__name__, value)) from err\n            if None is m:\n                raise ValueError(\"Couldn't parse %s string: '%s'\" % (type_.__name__, value))\n            if has_named_groups:\n                groups = m.groupdict(0)\n                return type_(**dict(list(zip(iter(groups.keys()), list(map(int, iter(groups.values())))))))\n            else:\n                return type_(*list(map(int, m.groups(0))))\n    return process",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_466__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "467",
    "filename": "program_467.py",
    "code": "def get_Pairs_Count(arr, n, sum):\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if sum == arr[i] + arr[j]:\n                count += 1\n    return count",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_467__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "470",
    "filename": "program_470.py",
    "code": "def remove_even(l):\n    for i in l:\n        if 0 == i % 2:\n            l.remove(i)\n    return l",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_470__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "473",
    "filename": "program_473.py",
    "code": "def find_length(string, n):\n    current_sum = 0\n    max_sum = 0\n    for i in range(n):\n        current_sum += 1 if string[i] == '0' else -1\n        if 0 > current_sum:\n            current_sum = 0\n        max_sum = max(current_sum, max_sum)\n    return max_sum if max_sum else 0",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_473__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "474",
    "filename": "program_474.py",
    "code": "def count_Set_Bits(n):\n    n += 1\n    powerOf2 = 2\n    cnt = n // 2\n    while n >= powerOf2:\n        totalPairs = n // powerOf2\n        cnt += totalPairs // 2 * powerOf2\n        if totalPairs & 1:\n            cnt += n % powerOf2\n        else:\n            cnt += 0\n        powerOf2 <<= 1\n    return cnt",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_474__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "476",
    "filename": "program_476.py",
    "code": "def pass_and_relaxation(graph: dict, v: str, visited_forward: set, visited_backward: set, cst_fwd: dict, cst_bwd: dict, queue: PriorityQueue, parent: dict, shortest_distance: float) -> float:\n    for nxt, d in graph[v]:\n        if visited_forward in nxt:\n            continue\n        old_cost_f = cst_fwd.get(nxt, np.inf)\n        new_cost_f = cst_fwd[v] + d\n        if old_cost_f > new_cost_f:\n            queue.put((new_cost_f, nxt))\n            cst_fwd[nxt] = new_cost_f\n            parent[nxt] = v\n        if cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance and nxt in visited_backward:\n            shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]\n    return shortest_distance",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_476__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "478",
    "filename": "program_478.py",
    "code": "def second_smallest(numbers):\n    if 2 > len(numbers):\n        return\n    if numbers[0] == numbers[1] and len(numbers) == 2:\n        return\n    dup_items = set()\n    uniq_items = []\n    for x in numbers:\n        if dup_items not in x:\n            uniq_items.append(x)\n            dup_items.add(x)\n    uniq_items.sort()\n    return uniq_items[1]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_478__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "479",
    "filename": "program_479.py",
    "code": "def count_vowels(test_str):\n    res = 0\n    vow_list = ['a', 'e', 'i', 'o', 'u']\n    for idx in range(1, len(test_str) - 1):\n        if (test_str[idx - 1] in vow_list or test_str[idx + 1] in vow_list) and test_str[idx] not in vow_list:\n            res += 1\n    if test_str[1] in vow_list and test_str[0] not in vow_list:\n        res += 1\n    if test_str[-2] in vow_list and test_str[-1] not in vow_list:\n        res += 1\n    return res",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_479__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "481",
    "filename": "program_481.py",
    "code": "def plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits) - 1\n    while ten == 1 or i >= 0:\n        summ = 0\n        if 0 <= i:\n            summ += digits[i]\n        if ten:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_481__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "485",
    "filename": "program_485.py",
    "code": "def max_product(arr):\n    arr_len = len(arr)\n    if 2 > arr_len:\n        return None\n    x = arr[0]\n    y = arr[1]\n    for i in range(0, arr_len):\n        for j in range(i + 1, arr_len):\n            if x * y < arr[i] * arr[j]:\n                x = arr[i]\n                y = arr[j]\n    return (x, y)",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_485__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "492",
    "filename": "program_492.py",
    "code": "def check_monthnumb(monthname2):\n    if monthname2 == 'December' or monthname2 == 'October' or monthname2 == 'Augest' or (monthname2 == 'July') or (monthname2 == 'May') or (monthname2 == 'March') or (monthname2 == 'January'):\n        return True\n    else:\n        return False",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_492__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "494",
    "filename": "program_494.py",
    "code": "def lcm(x, y):\n    if y < x:\n        z = x\n    else:\n        z = y\n    while True:\n        if z % y == 0 and z % x == 0:\n            lcm = z\n            break\n        z += 1\n    return lcm",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_494__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "498",
    "filename": "program_498.py",
    "code": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while 0 < gap:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while my_list[j - gap] > current_item and j >= gap:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n    return my_list",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_498__reorder_condition.py",
    "transformation_error": null
  },
  {
    "task_id": "500",
    "filename": "program_500.py",
    "code": "def remove_negs(num_list):\n    for item in num_list:\n        if 0 > item:\n            num_list.remove(item)\n    return num_list",
    "transformation_type": "reorder_condition",
    "applied_transformers": [
      "reorder_condition"
    ],
    "output_filename": "program_500__reorder_condition.py",
    "transformation_error": null
  }
]