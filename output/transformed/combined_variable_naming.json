[
  {
    "task_id": "001",
    "filename": "program_001.py",
    "code": "import re\n\ndef check_alphanumeric(string):\n    if re.search(regex, string):\n        return 'Accept'\n    else:\n        return 'Discard'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "002",
    "filename": "program_002.py",
    "code": "def find_triplet_array(A, arr_size, sum):\n    for var_0 in range(0, arr_size - 2):\n        for var_1 in range(var_0 + 1, arr_size - 1):\n            for var_2 in range(var_1 + 1, arr_size):\n                if A[var_0] + A[var_1] + A[var_2] == sum:\n                    return (A[var_0], A[var_1], A[var_2])\n                    return True\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "003",
    "filename": "program_003.py",
    "code": "def octal_To_Decimal(n):\n    var_0 = n\n    var_1 = 0\n    var_2 = 1\n    var_3 = var_0\n    while var_3:\n        var_4 = var_3 % 10\n        var_3 = int(var_3 / 10)\n        var_1 += var_4 * var_2\n        var_2 = var_2 * 8\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "004",
    "filename": "program_004.py",
    "code": "import re\n\ndef is_valid_URL(str):\n    var_0 = '((http|https)://)(www.)?' + '[a-zA-Z0-9@:%._\\\\+~#?&//=]' + '{2,256}\\\\.[a-z]' + '{2,6}\\\\b([-a-zA-Z0-9@:%' + '._\\\\+~#?&//=]*)'\n    var_1 = re.compile(var_0)\n    if str == None:\n        return False\n    if re.search(var_1, str):\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "005",
    "filename": "program_005.py",
    "code": "def dig_let(s):\n    var_0 = var_1 = 0\n    for var_2 in s:\n        if var_2.isdigit():\n            var_0 = var_0 + 1\n        elif var_2.isalpha():\n            var_1 = var_1 + 1\n        else:\n            pass\n    return (var_1, var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "006",
    "filename": "program_006.py",
    "code": "def multi_list(rownum, colnum):\n    var_0 = [[0 for var_1 in range(colnum)] for var_2 in range(rownum)]\n    for var_2 in range(rownum):\n        for var_1 in range(colnum):\n            var_0[var_2][var_1] = var_2 * var_1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "007",
    "filename": "program_007.py",
    "code": "import re\n\ndef multiple_split(text):\n    return re.split('; |, |\\\\*|\\n', text)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "008",
    "filename": "program_008.py",
    "code": "import re\n\ndef extract_max(input):\n    var_0 = re.findall('\\\\d+', input)\n    var_0 = map(int, var_0)\n    return max(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "009",
    "filename": "program_009.py",
    "code": "def find_Min_Sum(num):\n    var_0 = 0\n    var_1 = 2\n    while var_1 * var_1 <= num:\n        while num % var_1 == 0:\n            var_0 += var_1\n            var_2 /= var_1\n        var_1 += 1\n    var_0 += var_2\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "010",
    "filename": "program_010.py",
    "code": "def count_char(string, char):\n    var_0 = 0\n    for var_1 in range(len(string)):\n        if string[var_1] == char:\n            var_0 = var_0 + 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "011",
    "filename": "program_011.py",
    "code": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    var_0 = set()\n    array.sort()\n    for var_1 in range(len(array) - 2):\n        if var_1 > 0 and array[var_1] == array[var_1 - 1]:\n            continue\n        var_2, var_3 = (var_1 + 1, len(array) - 1)\n        while var_2 < var_3:\n            var_4 = array[var_1] + array[var_2] + array[var_3]\n            if var_4 > 0:\n                var_3 -= 1\n            elif var_4 < 0:\n                var_2 += 1\n            else:\n                var_0.add((array[var_1], array[var_2], array[var_3]))\n                while var_2 < var_3 and array[var_2] == array[var_2 + 1]:\n                    var_2 += 1\n                while var_2 < var_3 and array[var_3] == array[var_3 - 1]:\n                    var_3 -= 1\n                var_2 += 1\n                var_3 -= 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "012",
    "filename": "program_012.py",
    "code": "def take_L_and_F_set_bits(n):\n    var_0 = var_0 | var_0 >> 1\n    var_0 = var_0 | var_0 >> 2\n    var_0 = var_0 | var_0 >> 4\n    var_0 = var_0 | var_0 >> 8\n    var_0 = var_0 | var_0 >> 16\n    return (var_0 + 1 >> 1) + 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "013",
    "filename": "program_013.py",
    "code": "import re\n\ndef text_match_wordz(text):\n    var_0 = '\\\\w*z.\\\\w*'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "014",
    "filename": "program_014.py",
    "code": "def is_coprime(x, y):\n    return gcd(x, y) == 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "015",
    "filename": "program_015.py",
    "code": "def min_Swaps(s1, s2):\n    var_0 = 0\n    var_1 = 0\n    for var_2 in range(len(s1)):\n        if s1[var_2] == '0' and s2[var_2] == '1':\n            var_0 += 1\n        elif s1[var_2] == '1' and s2[var_2] == '0':\n            var_1 += 1\n    var_3 = var_0 // 2 + var_1 // 2\n    if var_0 % 2 == 0 and var_1 % 2 == 0:\n        return var_3\n    elif (var_0 + var_1) % 2 == 0:\n        return var_3 + 2\n    else:\n        return -1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "016",
    "filename": "program_016.py",
    "code": "import re\n\ndef find_literals(text, pattern):\n    var_0 = re.search(pattern, text)\n    var_1 = var_0.start()\n    var_2 = var_0.end()\n    return (var_0.re.pattern, var_1, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "017",
    "filename": "program_017.py",
    "code": "import math\n\ndef find_Digits(n):\n    if n < 0:\n        return 0\n    if n <= 1:\n        return 1\n    var_0 = n * math.log10(n / math.e) + math.log10(2 * math.pi * n) / 2.0\n    return math.floor(var_0) + 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "018",
    "filename": "program_018.py",
    "code": "def first_Element(arr, n, k):\n    var_0 = {}\n    for var_1 in range(0, n):\n        if arr[var_1] in var_0.keys():\n            var_0[arr[var_1]] += 1\n        else:\n            var_0[arr[var_1]] = 1\n        var_1 += 1\n    for var_1 in range(0, n):\n        if var_0[arr[var_1]] == k:\n            return arr[var_1]\n        var_1 += 1\n    return -1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "019",
    "filename": "program_019.py",
    "code": "def count_no(A, N, L, R):\n    var_0 = 0\n    for var_1 in range(L, R + 1):\n        if var_1 % A != 0:\n            var_0 += 1\n        if var_0 == N:\n            break\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "020",
    "filename": "program_020.py",
    "code": "def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    var_0 = []\n    for var_1 in range(len(cells)):\n        var_2 = []\n        for var_3 in range(len(cells[var_1])):\n            var_4 = 0\n            if var_1 > 0 and var_3 > 0:\n                var_4 += cells[var_1 - 1][var_3 - 1]\n            if var_1 > 0:\n                var_4 += cells[var_1 - 1][var_3]\n            if var_1 > 0 and var_3 < len(cells[var_1]) - 1:\n                var_4 += cells[var_1 - 1][var_3 + 1]\n            if var_3 > 0:\n                var_4 += cells[var_1][var_3 - 1]\n            if var_3 < len(cells[var_1]) - 1:\n                var_4 += cells[var_1][var_3 + 1]\n            if var_1 < len(cells) - 1 and var_3 > 0:\n                var_4 += cells[var_1 + 1][var_3 - 1]\n            if var_1 < len(cells) - 1:\n                var_4 += cells[var_1 + 1][var_3]\n            if var_1 < len(cells) - 1 and var_3 < len(cells[var_1]) - 1:\n                var_4 += cells[var_1 + 1][var_3 + 1]\n            var_5 = cells[var_1][var_3] == 1\n            if var_5 and 2 <= var_4 <= 3 or (not var_5 and var_4 == 3):\n                var_2.append(1)\n            else:\n                var_2.append(0)\n        var_0.append(var_2)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "021",
    "filename": "program_021.py",
    "code": "def tn_ap(a, n, d):\n    var_0 = a + (n - 1) * d\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "022",
    "filename": "program_022.py",
    "code": "def _xor_table() -> List[bytes]:\n    return [bytes((a ^ b for var_0 in range(256))) for var_1 in range(256)]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "023",
    "filename": "program_023.py",
    "code": "def even_or_odd(N):\n    var_0 = len(N)\n    if N[var_0 - 1] == '0' or N[var_0 - 1] == '2' or N[var_0 - 1] == '4' or (N[var_0 - 1] == '6') or (N[var_0 - 1] == '8') or (N[var_0 - 1] == 'A') or (N[var_0 - 1] == 'C') or (N[var_0 - 1] == 'E'):\n        return 'Even'\n    else:\n        return 'Odd'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "024",
    "filename": "program_024.py",
    "code": "def octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not octal_number:\n        raise ValueError('Empty string was passed to the function')\n    var_0 = ''\n    var_1 = '01234567'\n    for var_2 in octal_number:\n        if var_2 not in var_1:\n            raise ValueError('Non-octal value was passed to the function')\n        var_3 = ''\n        var_4 = int(var_2)\n        for var_5 in range(3):\n            var_3 = str(var_4 % 2) + var_3\n            var_4 //= 2\n        var_0 += var_3\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "025",
    "filename": "program_025.py",
    "code": "def magic_square_test(my_matrix):\n    var_0 = len(my_matrix[0])\n    var_1 = []\n    var_1.extend([sum(lines) for var_2 in my_matrix])\n    for var_3 in range(var_0):\n        var_1.append(sum((row[var_3] for var_4 in my_matrix)))\n    var_5 = 0\n    for var_6 in range(0, var_0):\n        var_5 += my_matrix[var_6][var_6]\n    var_1.append(var_5)\n    var_7 = 0\n    for var_6 in range(var_0 - 1, -1, -1):\n        var_7 += my_matrix[var_6][var_6]\n    var_1.append(var_7)\n    if len(set(var_1)) > 1:\n        return False\n    return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "026",
    "filename": "program_026.py",
    "code": "def Extract(lst):\n    return [item[-1] for var_0 in lst]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "027",
    "filename": "program_027.py",
    "code": "def remove_odd(str1):\n    var_0 = ''\n    for var_1 in range(1, len(str1) + 1):\n        if var_1 % 2 == 0:\n            var_0 = var_0 + str1[var_1 - 1]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "028",
    "filename": "program_028.py",
    "code": "def max_Product(arr):\n    var_0 = len(arr)\n    if var_0 < 2:\n        return 'No pairs exists'\n    var_1 = arr[0]\n    var_2 = arr[1]\n    for var_3 in range(0, var_0):\n        for var_4 in range(var_3 + 1, var_0):\n            if arr[var_3] * arr[var_4] > var_1 * var_2:\n                var_1 = arr[var_3]\n                var_2 = arr[var_4]\n    return (var_1, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "029",
    "filename": "program_029.py",
    "code": "def max_of_two(x, y):\n    if x > y:\n        return x\n    return y",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "030",
    "filename": "program_030.py",
    "code": "import heapq as hq\n\ndef heap_sort(iterable):\n    var_0 = []\n    for var_1 in iterable:\n        hq.heappush(var_0, var_1)\n    return [hq.heappop(var_0) for var_2 in range(len(var_0))]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "031",
    "filename": "program_031.py",
    "code": "def mul_list(nums1, nums2):\n    var_0 = map(lambda x, y: x * y, nums1, nums2)\n    return list(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "032",
    "filename": "program_032.py",
    "code": "def common_prefix(arr, n):\n    var_0 = arr[0]\n    for var_1 in range(1, n):\n        var_0 = common_prefix_util(var_0, arr[var_1])\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "033",
    "filename": "program_033.py",
    "code": "def no_of_subsequences(arr, k):\n    var_0 = len(arr)\n    var_1 = [[0 for var_2 in range(var_0 + 1)] for var_3 in range(k + 1)]\n    for var_2 in range(1, k + 1):\n        for var_3 in range(1, var_0 + 1):\n            var_1[var_2][var_3] = var_1[var_2][var_3 - 1]\n            if arr[var_3 - 1] <= var_2 and arr[var_3 - 1] > 0:\n                var_1[var_2][var_3] += var_1[var_2 // arr[var_3 - 1]][var_3 - 1] + 1\n    return var_1[k][var_0]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "034",
    "filename": "program_034.py",
    "code": "def swap_count(s):\n    var_0 = s\n    var_1 = 0\n    var_2 = 0\n    var_3 = 0\n    var_4 = 0\n    for var_5 in range(len(var_0)):\n        if var_0[var_5] == '[':\n            var_1 += 1\n            if var_4 > 0:\n                var_3 += var_4\n                var_4 -= 1\n        elif var_0[var_5] == ']':\n            var_2 += 1\n            var_4 = var_2 - var_1\n    return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "035",
    "filename": "program_035.py",
    "code": "def is_response_to_head(response: httplib.HTTPResponse) -> bool:\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    var_0 = response._method\n    return var_0.upper() == 'HEAD'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "036",
    "filename": "program_036.py",
    "code": "def flatten_list(list1):\n    var_0 = []\n    if not list1:\n        return var_0\n    var_1 = [list(list1)]\n    while var_1:\n        var_2 = var_1.pop()\n        var_3 = var_2.pop()\n        if var_2:\n            var_1.append(var_2)\n        if isinstance(var_3, list):\n            if var_3:\n                var_1.append(list(var_3))\n        else:\n            var_0.append(var_3)\n    var_0.reverse()\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "037",
    "filename": "program_037.py",
    "code": "def find_Nth_Digit(p, q, N):\n    while N > 0:\n        var_0 -= 1\n        var_1 *= 10\n        var_2 = var_1 // q\n        var_1 %= q\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "038",
    "filename": "program_038.py",
    "code": "def convert_list_dictionary(l1, l2, l3):\n    var_0 = [{x: {y: z}} for var_1, var_2, var_3 in zip(l1, l2, l3)]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "039",
    "filename": "program_039.py",
    "code": "def find_missing_number(nums):\n    var_0 = 0\n    for var_1, var_2 in enumerate(nums):\n        var_0 ^= var_2\n        var_0 ^= var_1 + 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "040",
    "filename": "program_040.py",
    "code": "def differ_At_One_Bit_Pos(a, b):\n    return is_Power_Of_Two(a ^ b)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "041",
    "filename": "program_041.py",
    "code": "def count_bidirectional(test_list):\n    var_0 = 0\n    for var_1 in range(0, len(test_list)):\n        for var_2 in range(var_1 + 1, len(test_list)):\n            if test_list[var_2][0] == test_list[var_1][1] and test_list[var_1][1] == test_list[var_2][0]:\n                var_0 += 1\n    return str(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "042",
    "filename": "program_042.py",
    "code": "def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    var_0 = []\n    var_1 = 1\n    for var_2 in range(len(text)):\n        if var_2 + 1 < len(text) and text[var_2] == text[var_2 + 1]:\n            var_1 += 1\n        else:\n            var_0.append((text[var_2], var_1))\n            var_1 = 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "043",
    "filename": "program_043.py",
    "code": "def longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if string is None:\n        return 0\n    var_0, var_1 = (0, 0)\n    var_2 = {}\n    for var_3, var_4 in enumerate(string):\n        if var_4 in var_2 and var_0 <= var_2[var_4]:\n            var_0 = var_2[var_4] + 1\n        else:\n            var_1 = max(var_1, var_3 - var_0 + 1)\n        var_2[var_4] = var_3\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "044",
    "filename": "program_044.py",
    "code": "def find_demlo(s):\n    var_0 = len(s)\n    var_1 = ''\n    for var_2 in range(1, var_0 + 1):\n        var_1 = var_1 + str(var_2)\n    for var_2 in range(var_0 - 1, 0, -1):\n        var_1 = var_1 + str(var_2)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "045",
    "filename": "program_045.py",
    "code": "def nth_nums(nums, n):\n    var_0 = list(map(lambda x: x ** n, nums))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "046",
    "filename": "program_046.py",
    "code": "def timeout(seconds: Optional[float]) -> ContextManager[None]:\n    \"\"\"**(Provisional)** Apply the given timeout for a block of operations.\n\n    .. note:: :func:`~pymongo.timeout` is currently provisional. Backwards\n       incompatible changes may occur before becoming officially supported.\n\n    Use :func:`~pymongo.timeout` in a with-statement::\n\n      with pymongo.timeout(5):\n          client.db.coll.insert_one({})\n          client.db.coll2.insert_one({})\n\n    When the with-statement is entered, a deadline is set for the entire\n    block. When that deadline is exceeded, any blocking pymongo operation\n    will raise a timeout exception. For example::\n\n      try:\n          with pymongo.timeout(5):\n              client.db.coll.insert_one({})\n              time.sleep(5)\n              # The deadline has now expired, the next operation will raise\n              # a timeout exception.\n              client.db.coll2.insert_one({})\n      except PyMongoError as exc:\n          if exc.timeout:\n              print(f\"block timed out: {exc!r}\")\n          else:\n              print(f\"failed with non-timeout error: {exc!r}\")\n\n    When nesting :func:`~pymongo.timeout`, the nested deadline is capped by\n    the outer deadline. The deadline can only be shortened, not extended.\n    When exiting the block, the previous deadline is restored::\n\n      with pymongo.timeout(5):\n          coll.find_one()  # Uses the 5 second deadline.\n          with pymongo.timeout(3):\n              coll.find_one() # Uses the 3 second deadline.\n          coll.find_one()  # Uses the original 5 second deadline.\n          with pymongo.timeout(10):\n              coll.find_one()  # Still uses the original 5 second deadline.\n          coll.find_one()  # Uses the original 5 second deadline.\n\n    :param seconds: A non-negative floating point number expressing seconds, or None.\n\n    :raises: :py:class:`ValueError`: When `seconds` is negative.\n\n    See :ref:`timeout-example` for more examples.\n\n    .. versionadded:: 4.2\n    \"\"\"\n    if not isinstance(seconds, (int, float, type(None))):\n        raise TypeError(f'timeout must be None, an int, or a float, not {type(seconds)}')\n    if seconds and seconds < 0:\n        raise ValueError('timeout cannot be negative')\n    if seconds is not None:\n        var_0 = float(var_0)\n    return _csot._TimeoutContext(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "047",
    "filename": "program_047.py",
    "code": "def solve(needed_sum: int, power: int) -> int:\n    \"\"\"\n    >>> solve(13, 2)\n    1\n    >>> solve(10, 2)\n    1\n    >>> solve(10, 3)\n    0\n    >>> solve(20, 2)\n    1\n    >>> solve(15, 10)\n    0\n    >>> solve(16, 2)\n    1\n    >>> solve(20, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    >>> solve(-10, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    \"\"\"\n    if not (1 <= needed_sum <= 1000 and 2 <= power <= 10):\n        raise ValueError('Invalid input\\nneeded_sum must be between 1 and 1000, power between 2 and 10.')\n    return backtrack(needed_sum, power, 1, 0, 0)[1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "048",
    "filename": "program_048.py",
    "code": "def max_logprob_discrete(op, values, base_rv, **kwargs):\n    \"\"\"Compute the log-likelihood graph for the `Max` operation.\n\n    The formula that we use here is :\n    .. math::\n        \\\\ln(P_{(n)}(x)) = \\\\ln(F(x)^n - F(x-1)^n)\n    where $P_{(n)}(x)$ represents the p.m.f of the maximum statistic and $F(x)$ represents the c.d.f of the i.i.d. variables.\n    \"\"\"\n    var_0, = values\n    var_1 = constant_fold(tuple(base_rv.shape), raise_not_constant=False)\n    var_2 = pt.broadcast_to(var_0, var_1)\n    var_3 = _logcdf_helper(base_rv, var_2)[0]\n    var_4 = _logcdf_helper(base_rv, var_2 - 1)[0]\n    var_5 = pt.prod(var_1)\n    return logdiffexp(var_5 * var_3, var_5 * var_4)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "049",
    "filename": "program_049.py",
    "code": "def prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns prime factors of n as a list.\n\n    >>> prime_factors(0)\n    []\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(2560)\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n    >>> prime_factors(10**-2)\n    []\n    >>> prime_factors(0.02)\n    []\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n    >>> x == [2]*241 + [5]*241\n    True\n    >>> prime_factors(10**-354)\n    []\n    >>> prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n\n    \"\"\"\n    var_0 = 2\n    var_1 = []\n    while var_0 * var_0 <= n:\n        if n % var_0:\n            var_0 += 1\n        else:\n            var_2 //= var_0\n            var_1.append(var_0)\n    if var_2 > 1:\n        var_1.append(var_2)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "050",
    "filename": "program_050.py",
    "code": "def bin_coff(n, r):\n    var_0 = 1\n    if r > n - r:\n        var_1 = n - var_1\n    for var_2 in range(0, var_1):\n        var_0 *= n - var_2\n        var_0 //= var_2 + 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "051",
    "filename": "program_051.py",
    "code": "def int_to_roman(num):\n    var_0 = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var_1 = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    var_2 = ''\n    var_3 = 0\n    while num > 0:\n        for var_4 in range(num // var_0[var_3]):\n            var_2 += var_1[var_3]\n            var_5 -= var_0[var_3]\n        var_3 += 1\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "052",
    "filename": "program_052.py",
    "code": "def connection_requires_http_tunnel(proxy_url: Url | None=None, proxy_config: ProxyConfig | None=None, destination_scheme: str | None=None) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:\n        Proxy configuration from poolmanager.py\n    :param str destination_scheme:\n        The scheme of the destination. (i.e https, http, etc)\n    \"\"\"\n    if proxy_url is None:\n        return False\n    if destination_scheme == 'http':\n        return False\n    if proxy_url.scheme == 'https' and proxy_config and proxy_config.use_forwarding_for_https:\n        return False\n    return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "053",
    "filename": "program_053.py",
    "code": "def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    >>> # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    >>> # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    >>> # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    >>> # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    var_0, var_1 = np.shape(table)\n    if var_0 != var_1:\n        var_2 = f\"'table' has to be of square shaped array but got a {var_0}x{var_1} array:\\n{table}\"\n        raise ValueError(var_2)\n    var_3 = np.zeros((var_0, var_1))\n    var_4 = np.zeros((var_0, var_1))\n    for var_5 in range(var_1):\n        for var_6 in range(var_5):\n            var_7 = np.sum(var_3[var_5, :var_5] * var_4[:var_5, var_6])\n            if var_4[var_6][var_6] == 0:\n                raise ArithmeticError('No LU decomposition exists')\n            var_3[var_5][var_6] = (table[var_5][var_6] - var_7) / var_4[var_6][var_6]\n        var_3[var_5][var_5] = 1\n        for var_6 in range(var_5, var_1):\n            var_7 = np.sum(var_3[var_5, :var_5] * var_4[:var_5, var_6])\n            var_4[var_5][var_6] = table[var_5][var_6] - var_7\n    return (var_3, var_4)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "054",
    "filename": "program_054.py",
    "code": "def coin_change(S, m, n):\n    var_0 = [[0 for var_1 in range(m)] for var_1 in range(n + 1)]\n    for var_2 in range(m):\n        var_0[0][var_2] = 1\n    for var_2 in range(1, n + 1):\n        for var_3 in range(m):\n            var_1 = var_0[var_2 - S[var_3]][var_3] if var_2 - S[var_3] >= 0 else 0\n            var_4 = var_0[var_2][var_3 - 1] if var_3 >= 1 else 0\n            var_0[var_2][var_3] = var_1 + var_4\n    return var_0[n][m - 1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "055",
    "filename": "program_055.py",
    "code": "def issort_list(list1):\n    var_0 = all((list1[i] <= list1[i + 1] for var_1 in range(len(list1) - 1)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "056",
    "filename": "program_056.py",
    "code": "def div_list(nums1, nums2):\n    var_0 = map(lambda x, y: x / y, nums1, nums2)\n    return list(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "057",
    "filename": "program_057.py",
    "code": "def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:\n    \"\"\"\n    The main function. For list of numbers 'nums' find the subsets with sum\n    equal to 'max_sum'\n\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9)\n    [[3, 4, 2], [4, 5]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3)\n    [[3]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1)\n    []\n    \"\"\"\n    var_0: list[list[int]] = []\n    var_1: list[int] = []\n    var_2 = 0\n    var_3 = sum(nums)\n    create_state_space_tree(nums, max_sum, var_2, var_1, var_0, var_3)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "058",
    "filename": "program_058.py",
    "code": "def largest_pow_of_two_le_num(number: int) -> int:\n    \"\"\"\n    Return the largest power of two less than or equal to a number.\n\n    >>> largest_pow_of_two_le_num(0)\n    0\n    >>> largest_pow_of_two_le_num(1)\n    1\n    >>> largest_pow_of_two_le_num(-1)\n    0\n    >>> largest_pow_of_two_le_num(3)\n    2\n    >>> largest_pow_of_two_le_num(15)\n    8\n    >>> largest_pow_of_two_le_num(99)\n    64\n    >>> largest_pow_of_two_le_num(178)\n    128\n    >>> largest_pow_of_two_le_num(999999)\n    524288\n    >>> largest_pow_of_two_le_num(99.9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    \"\"\"\n    if isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    if number <= 0:\n        return 0\n    var_0 = 1\n    while var_0 << 1 <= number:\n        var_0 <<= 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "059",
    "filename": "program_059.py",
    "code": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode('ascii')\n        return True\n    except UnicodeEncodeError:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "060",
    "filename": "program_060.py",
    "code": "def sum_series(n):\n    if n < 1:\n        return 0\n    else:\n        return n + sum_series(n - 2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "061",
    "filename": "program_061.py",
    "code": "def check_isosceles(x, y, z):\n    if x != y & y != z & z != x:\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "062",
    "filename": "program_062.py",
    "code": "def reverse_Array_Upto_K(input, k):\n    return input[k - 1::-1] + input[k:]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "063",
    "filename": "program_063.py",
    "code": "def rotate_left(list1, m, n):\n    var_0 = list1[m:] + list1[:n]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "064",
    "filename": "program_064.py",
    "code": "def longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError('longest_common_substring() takes two strings for inputs')\n    if not text1 or not text2:\n        return ''\n    var_0 = len(text1)\n    var_1 = len(text2)\n    var_2 = [[0] * (var_1 + 1) for var_3 in range(var_0 + 1)]\n    var_4 = 0\n    var_5 = 0\n    for var_6 in range(1, var_0 + 1):\n        for var_7 in range(1, var_1 + 1):\n            if text1[var_6 - 1] == text2[var_7 - 1]:\n                var_2[var_6][var_7] = 1 + var_2[var_6 - 1][var_7 - 1]\n                if var_2[var_6][var_7] > var_5:\n                    var_4 = var_6\n                    var_5 = var_2[var_6][var_7]\n    return text1[var_4 - var_5:var_4]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "065",
    "filename": "program_065.py",
    "code": "def count_Unset_Bits(n):\n    var_0 = 0\n    for var_1 in range(1, n + 1):\n        var_2 = var_1\n        while var_2:\n            if var_2 % 2 == 0:\n                var_0 += 1\n            var_2 = var_2 // 2\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "066",
    "filename": "program_066.py",
    "code": "def longest_increasing_subsequence(arr):\n    var_0 = len(arr)\n    var_1 = [1] * var_0\n    for var_2 in range(1, var_0):\n        for var_3 in range(0, var_2):\n            if arr[var_2] > arr[var_3] and var_1[var_2] < var_1[var_3] + 1:\n                var_1[var_2] = var_1[var_3] + 1\n    var_4 = 0\n    for var_2 in range(var_0):\n        var_4 = max(var_4, var_1[var_2])\n    return var_4",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "067",
    "filename": "program_067.py",
    "code": "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    var_0 = [1]\n\n    def gen(prime):\n        for var_1 in var_0:\n            yield (var_1 * prime)\n    var_2 = heapq.merge(*map(gen, primes))\n    while len(var_0) < n:\n        var_1 = next(var_2)\n        if var_1 != var_0[-1]:\n            var_0.append(var_1)\n    return var_0[-1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "068",
    "filename": "program_068.py",
    "code": "def find_longest_conseq_subseq(arr, n):\n    var_0 = 0\n    var_1 = 0\n    arr.sort()\n    var_2 = []\n    var_2.append(arr[0])\n    for var_3 in range(1, n):\n        if arr[var_3] != arr[var_3 - 1]:\n            var_2.append(arr[var_3])\n    for var_3 in range(len(var_2)):\n        if var_3 > 0 and var_2[var_3] == var_2[var_3 - 1] + 1:\n            var_1 += 1\n        else:\n            var_1 = 1\n        var_0 = max(var_0, var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "069",
    "filename": "program_069.py",
    "code": "def validity_triangle(a, b, c):\n    var_0 = a + b + c\n    if var_0 == 180:\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "070",
    "filename": "program_070.py",
    "code": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            var_0 += 1\n        return combis\n    return factor(n, 2, [], [])",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "071",
    "filename": "program_071.py",
    "code": "def tuple_to_dict(test_tup):\n    var_0 = dict((test_tup[idx:idx + 2] for var_1 in range(0, len(test_tup), 2)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "072",
    "filename": "program_072.py",
    "code": "def change_contrast(img: Image, level: int) -> Image:\n    \"\"\"\n\n    Function to change contrast\n\n    \"\"\"\n    var_0 = 259 * (level + 255) / (255 * (259 - level))\n\n    def contrast(c: int) -> int:\n        \"\"\"\n\n        Fundamental Transformation/Operation that'll be performed on\n\n        every bit.\n\n        \"\"\"\n        return int(128 + var_0 * (c - 128))\n    return img.point(contrast)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "073",
    "filename": "program_073.py",
    "code": "import collections as ct\n\ndef merge_dictionaries(dict1, dict2):\n    var_0 = dict(ct.ChainMap({}, dict1, dict2))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "074",
    "filename": "program_074.py",
    "code": "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for var_0 in range(index, len(nums)):\n            dfs(nums, target - nums[var_0], var_0, path + [nums[var_0]], res)\n    var_1 = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], var_1)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "075",
    "filename": "program_075.py",
    "code": "def multiples_of_num(m, n):\n    var_0 = list(range(n, (m + 1) * n, n))\n    return list(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "076",
    "filename": "program_076.py",
    "code": "def get_item(tup1, index):\n    var_0 = tup1[index]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "077",
    "filename": "program_077.py",
    "code": "def smallest_Divisor(n):\n    if n % 2 == 0:\n        return 2\n    var_0 = 3\n    while var_0 * var_0 <= n:\n        if n % var_0 == 0:\n            return var_0\n        var_0 += 2\n    return n",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "078",
    "filename": "program_078.py",
    "code": "import math\nimport sys\n\ndef sd_calc(data):\n    var_0 = len(data)\n    if var_0 <= 1:\n        return 0.0\n    var_1, var_2 = (avg_calc(data), 0.0)\n    for var_3 in data:\n        var_2 += (float(var_3) - var_1) ** 2\n    var_2 = math.sqrt(var_2 / float(var_0 - 1))\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "079",
    "filename": "program_079.py",
    "code": "def pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n\n    Conversion between pressure units.\n\n    >>> pressure_conversion(4, \"atm\", \"pascal\")\n\n    405300\n\n    >>> pressure_conversion(1, \"pascal\", \"psi\")\n\n    0.00014401981999999998\n\n    >>> pressure_conversion(1, \"bar\", \"atm\")\n\n    0.986923\n\n    >>> pressure_conversion(3, \"kilopascal\", \"bar\")\n\n    0.029999991892499998\n\n    >>> pressure_conversion(2, \"megapascal\", \"psi\")\n\n    290.074434314\n\n    >>> pressure_conversion(4, \"psi\", \"torr\")\n\n    206.85984\n\n    >>> pressure_conversion(1, \"inHg\", \"atm\")\n\n    0.0334211\n\n    >>> pressure_conversion(1, \"torr\", \"psi\")\n\n    0.019336718261000002\n\n    >>> pressure_conversion(4, \"wrongUnit\", \"atm\")\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\n\n    \"\"\"\n    if from_type not in PRESSURE_CONVERSION:\n        raise ValueError(f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\" + ', '.join(PRESSURE_CONVERSION))\n    if to_type not in PRESSURE_CONVERSION:\n        raise ValueError(f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\" + ', '.join(PRESSURE_CONVERSION))\n    return value * PRESSURE_CONVERSION[from_type].from_factor * PRESSURE_CONVERSION[to_type].to_factor",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "080",
    "filename": "program_080.py",
    "code": "def maximum(a, b):\n    if a >= b:\n        return a\n    else:\n        return b",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "081",
    "filename": "program_081.py",
    "code": "def shear_stress(stress: float, tangential_force: float, area: float) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError('You cannot supply more or less than 2 values')\n    elif stress < 0:\n        raise ValueError('Stress cannot be negative')\n    elif tangential_force < 0:\n        raise ValueError('Tangential Force cannot be negative')\n    elif area < 0:\n        raise ValueError('Area cannot be negative')\n    elif stress == 0:\n        return ('stress', tangential_force / area)\n    elif tangential_force == 0:\n        return ('tangential_force', stress * area)\n    else:\n        return ('area', tangential_force / stress)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "082",
    "filename": "program_082.py",
    "code": "def find_longest_repeating_subseq(str):\n    var_0 = len(str)\n    var_1 = [[0 for var_2 in range(var_0 + 1)] for var_3 in range(var_0 + 1)]\n    for var_4 in range(1, var_0 + 1):\n        for var_5 in range(1, var_0 + 1):\n            if str[var_4 - 1] == str[var_5 - 1] and var_4 != var_5:\n                var_1[var_4][var_5] = 1 + var_1[var_4 - 1][var_5 - 1]\n            else:\n                var_1[var_4][var_5] = max(var_1[var_4][var_5 - 1], var_1[var_4 - 1][var_5])\n    return var_1[var_0][var_0]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "083",
    "filename": "program_083.py",
    "code": "def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    \"\"\"\n    Recur for all neighbours.\n    If any neighbour is visited and in rec_stk then graph is cyclic.\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n    >>> vertex, visited, rec_stk = 0, set(), set()\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\n    False\n    \"\"\"\n    visited.add(vertex)\n    rec_stk.add(vertex)\n    for var_0 in graph[vertex]:\n        if var_0 not in visited:\n            if depth_first_search(graph, var_0, visited, rec_stk):\n                return True\n        elif var_0 in rec_stk:\n            return True\n    rec_stk.remove(vertex)\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "084",
    "filename": "program_084.py",
    "code": "def mul_even_odd(list1):\n    var_0 = next((el for var_1 in list1 if var_1 % 2 == 0), -1)\n    var_2 = next((var_1 for var_1 in list1 if var_1 % 2 != 0), -1)\n    return var_0 * var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "085",
    "filename": "program_085.py",
    "code": "import re\n\ndef text_match(text):\n    var_0 = '^[a-z]+_[a-z]+$'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "086",
    "filename": "program_086.py",
    "code": "def get_factors(n):\n    \"\"\"[summary]\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n\n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n\n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                var_0 += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], var_0)\n            var_1 += 1\n        return var_0\n    return factor(n, 2, [], [])",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "087",
    "filename": "program_087.py",
    "code": "def is_valid_parenthese(str1):\n    var_0, var_1 = ([], {'(': ')', '{': '}', '[': ']'})\n    for var_2 in str1:\n        if var_2 in var_1:\n            var_0.append(var_2)\n        elif len(var_0) == 0 or var_1[var_0.pop()] != var_2:\n            return False\n    return len(var_0) == 0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "088",
    "filename": "program_088.py",
    "code": "def supports_feature(target_versions: set[TargetVersion], feature: Feature) -> bool:\n    return all((feature in VERSION_TO_FEATURES[version] for var_0 in target_versions))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "089",
    "filename": "program_089.py",
    "code": "def find_Element(arr, ranges, rotations, index):\n    for var_0 in range(rotations - 1, -1, -1):\n        var_1 = ranges[var_0][0]\n        var_2 = ranges[var_0][1]\n        if var_1 <= index and var_2 >= index:\n            if index == var_1:\n                var_3 = var_2\n            else:\n                var_3 = var_3 - 1\n    return arr[var_3]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "090",
    "filename": "program_090.py",
    "code": "def rectangle_area(l, b):\n    var_0 = l * b\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "091",
    "filename": "program_091.py",
    "code": "def closest_num(N):\n    return N - 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "092",
    "filename": "program_092.py",
    "code": "from collections import defaultdict\n\ndef grouping_dictionary(l):\n    var_0 = defaultdict(list)\n    for var_1, var_2 in l:\n        var_0[var_1].append(var_2)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "093",
    "filename": "program_093.py",
    "code": "def equated_monthly_installments(principal: float, rate_per_annum: float, years_to_repay: int) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if principal <= 0:\n        raise Exception('Principal borrowed must be > 0')\n    if rate_per_annum < 0:\n        raise Exception('Rate of interest must be >= 0')\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\n        raise Exception('Years to repay must be an integer > 0')\n    var_0 = rate_per_annum / 12\n    var_1 = years_to_repay * 12\n    return principal * var_0 * (1 + var_0) ** var_1 / ((1 + var_0) ** var_1 - 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "094",
    "filename": "program_094.py",
    "code": "def toggle_F_and_L_bits(n):\n    if n == 1:\n        return 0\n    return n ^ take_L_and_F_set_bits(n)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "095",
    "filename": "program_095.py",
    "code": "def string_length(str1):\n    var_0 = 0\n    for var_1 in str1:\n        var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "096",
    "filename": "program_096.py",
    "code": "def ncr_modp(n, r, p):\n    var_0 = [0 for var_1 in range(r + 1)]\n    var_0[0] = 1\n    for var_1 in range(1, n + 1):\n        for var_2 in range(min(var_1, r), 0, -1):\n            var_0[var_2] = (var_0[var_2] + var_0[var_2 - 1]) % p\n    return var_0[r]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "097",
    "filename": "program_097.py",
    "code": "def _extract_argument_name(expr: Expression) -> str | None:\n    if isinstance(expr, NameExpr) and expr.name == 'None':\n        return None\n    elif isinstance(expr, StrExpr):\n        return expr.value\n    else:\n        raise TypeTranslationError()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "098",
    "filename": "program_098.py",
    "code": "def max_height(node):\n    if node is None:\n        return 0\n    else:\n        var_0 = max_height(node.left)\n        var_1 = max_height(node.right)\n        if var_0 > var_1:\n            return var_0 + 1\n        else:\n            return var_1 + 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "099",
    "filename": "program_099.py",
    "code": "def pancake_sort(nums):\n    var_0 = len(nums)\n    while var_0 > 1:\n        var_1 = nums.index(max(nums[0:var_0]))\n        var_2 = var_2[var_1::-1] + var_2[var_1 + 1:len(var_2)]\n        var_2 = var_2[var_0 - 1::-1] + var_2[var_0:len(var_2)]\n        var_0 -= 1\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "100",
    "filename": "program_100.py",
    "code": "def node_boundary(G, nbunch1, nbunch2=None):\n    \"\"\"Returns the node boundary of `nbunch1`.\n\n    The *node boundary* of a set *S* with respect to a set *T* is the\n    set of nodes *v* in *T* such that for some *u* in *S*, there is an\n    edge joining *u* to *v*. If *T* is not specified, it is assumed to\n    be the set of all nodes not in *S*.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    nbunch1 : iterable\n        Iterable of nodes in the graph representing the set of nodes\n        whose node boundary will be returned. (This is the set *S* from\n        the definition above.)\n\n    nbunch2 : iterable\n        Iterable of nodes representing the target (or \"exterior\") set of\n        nodes. (This is the set *T* from the definition above.) If not\n        specified, this is assumed to be the set of all nodes in `G`\n        not in `nbunch1`.\n\n    Returns\n    -------\n    set\n        The node boundary of `nbunch1` with respect to `nbunch2`.\n\n    Examples\n    --------\n    >>> G = nx.wheel_graph(6)\n\n    When nbunch2=None:\n\n    >>> list(nx.node_boundary(G, (3, 4)))\n    [0, 2, 5]\n\n    When nbunch2 is given:\n\n    >>> list(nx.node_boundary(G, (3, 4), (0, 1, 5)))\n    [0, 5]\n\n    Notes\n    -----\n    Any element of `nbunch` that is not in the graph `G` will be\n    ignored.\n\n    `nbunch1` and `nbunch2` are usually meant to be disjoint, but in\n    the interest of speed and generality, that is not required here.\n\n    \"\"\"\n    var_0 = {n for var_1 in nbunch1 if var_1 in G}\n    var_2 = set(chain.from_iterable((G[v] for var_3 in var_0))) - var_0\n    if nbunch2 is not None:\n        var_2 &= set(nbunch2)\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "101",
    "filename": "program_101.py",
    "code": "def rearrange_bigger(n):\n    var_0 = list(str(n))\n    for var_1 in range(len(var_0) - 2, -1, -1):\n        if var_0[var_1] < var_0[var_1 + 1]:\n            var_2 = var_0[var_1:]\n            var_3 = min(filter(lambda x: x > var_2[0], var_2))\n            var_2.remove(var_3)\n            var_2.sort()\n            var_0[var_1:] = [var_3] + var_2\n            return int(''.join(var_0))\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "102",
    "filename": "program_102.py",
    "code": "def frequency_Of_Smallest(n, arr):\n    var_0 = arr[0]\n    var_1 = 1\n    for var_2 in range(1, n):\n        if arr[var_2] < var_0:\n            var_0 = arr[var_2]\n            var_1 = 1\n        elif arr[var_2] == var_0:\n            var_1 += 1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "103",
    "filename": "program_103.py",
    "code": "def closest(x):\n    var_0 = 0\n    while var_0 * 10 + 9 <= x:\n        var_0 = var_0 * 10 + 9\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "104",
    "filename": "program_104.py",
    "code": "def limit(arr, min_lim=None, max_lim=None):\n    if len(arr) == 0:\n        return arr\n    if min_lim is None:\n        var_0 = min(arr)\n    if max_lim is None:\n        var_1 = max(arr)\n    return list(filter(lambda x: var_0 <= x <= var_1, arr))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "105",
    "filename": "program_105.py",
    "code": "def find_Min_Diff(arr, n):\n    var_0 = sorted(var_0)\n    var_1 = 10 ** 20\n    for var_2 in range(n - 1):\n        if var_0[var_2 + 1] - var_0[var_2] < var_1:\n            var_1 = var_0[var_2 + 1] - var_0[var_2]\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "106",
    "filename": "program_106.py",
    "code": "def extract_symmetric(test_list):\n    var_0 = set(test_list) & {(b, a) for var_1, var_2 in test_list}\n    var_3 = {(var_1, var_2) for var_1, var_2 in var_0 if var_1 < var_2}\n    return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "107",
    "filename": "program_107.py",
    "code": "def float_sort(price):\n    var_0 = sorted(price, key=lambda x: float(x[1]), reverse=True)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "108",
    "filename": "program_108.py",
    "code": "def get_median(arr1, arr2, n):\n    var_0 = 0\n    var_1 = 0\n    var_2 = -1\n    var_3 = -1\n    var_4 = 0\n    while var_4 < n + 1:\n        var_4 += 1\n        if var_0 == n:\n            var_2 = var_3\n            var_3 = arr2[0]\n            break\n        elif var_1 == n:\n            var_2 = var_3\n            var_3 = arr1[0]\n            break\n        if arr1[var_0] <= arr2[var_1]:\n            var_2 = var_3\n            var_3 = arr1[var_0]\n            var_0 += 1\n        else:\n            var_2 = var_3\n            var_3 = arr2[var_1]\n            var_1 += 1\n    return (var_2 + var_3) / 2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "109",
    "filename": "program_109.py",
    "code": "def substract_elements(test_tup1, test_tup2):\n    var_0 = tuple((tuple((a - b for var_1, var_2 in zip(tup1, tup2))) for var_3, var_4 in zip(test_tup1, test_tup2)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "110",
    "filename": "program_110.py",
    "code": "from collections import defaultdict\n\ndef most_occurrences(test_list):\n    var_0 = defaultdict(int)\n    for var_1 in test_list:\n        for var_2 in var_1.split():\n            var_0[var_2] += 1\n    var_3 = max(var_0, key=var_0.get)\n    return str(var_3)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "111",
    "filename": "program_111.py",
    "code": "from itertools import groupby\n\ndef extract_elements(numbers, n):\n    var_0 = [i for var_1, var_2 in groupby(numbers) if len(list(var_2)) == n]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "112",
    "filename": "program_112.py",
    "code": "def get_maxgold(gold, m, n):\n    var_0 = [[0 for var_1 in range(n)] for var_2 in range(m)]\n    for var_3 in range(n - 1, -1, -1):\n        for var_4 in range(m):\n            if var_3 == n - 1:\n                var_5 = 0\n            else:\n                var_5 = var_0[var_4][var_3 + 1]\n            if var_4 == 0 or var_3 == n - 1:\n                var_6 = 0\n            else:\n                var_6 = var_0[var_4 - 1][var_3 + 1]\n            if var_4 == m - 1 or var_3 == n - 1:\n                var_7 = 0\n            else:\n                var_7 = var_0[var_4 + 1][var_3 + 1]\n            var_0[var_4][var_3] = gold[var_4][var_3] + max(var_5, var_6, var_7)\n    var_8 = var_0[0][0]\n    for var_1 in range(1, m):\n        var_8 = max(var_8, var_0[var_1][0])\n    return var_8",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "113",
    "filename": "program_113.py",
    "code": "def convert(list):\n    var_0 = [str(i) for var_1 in list]\n    var_2 = int(''.join(var_0))\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "114",
    "filename": "program_114.py",
    "code": "def does_Contain_B(a, b, c):\n    if a == b:\n        return True\n    if (b - a) * c > 0 and (b - a) % c == 0:\n        return True\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "115",
    "filename": "program_115.py",
    "code": "def newman_prime(n):\n    if n == 0 or n == 1:\n        return 1\n    return 2 * newman_prime(n - 1) + newman_prime(n - 2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "116",
    "filename": "program_116.py",
    "code": "def count_Set_Bits(n):\n    var_0 = 0\n    while n:\n        var_0 += n & 1\n        var_1 >>= 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "117",
    "filename": "program_117.py",
    "code": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if string is None:\n        return 0\n    var_0 = {}\n    var_1 = 0\n    var_2 = 0\n    for var_3 in range(len(string)):\n        if string[var_3] in var_0:\n            var_2 = max(var_0[string[var_3]], var_2)\n        var_0[string[var_3]] = var_3 + 1\n        var_1 = max(var_1, var_3 - var_2 + 1)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "118",
    "filename": "program_118.py",
    "code": "def factorial(start, end):\n    var_0 = 1\n    for var_1 in range(start, end + 1):\n        var_0 *= var_1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "119",
    "filename": "program_119.py",
    "code": "def reverse_floyd(n):\n    \"\"\"\n\n    Print the lower half of a diamond pattern with '*' characters.\n\n    Args:\n\n        n (int): Size of the pattern.\n\n    Examples:\n\n        >>> reverse_floyd(3)\n\n        '* * * \\\\n * * \\\\n  * \\\\n   '\n\n        >>> reverse_floyd(5)\n\n        '* * * * * \\\\n * * * * \\\\n  * * * \\\\n   * * \\\\n    * \\\\n     '\n\n    \"\"\"\n    var_0 = ''\n    for var_1 in range(n, 0, -1):\n        for var_2 in range(var_1, 0, -1):\n            var_0 += '* '\n        var_0 += '\\n'\n        for var_2 in range(n - var_1 + 1, 0, -1):\n            var_0 += ' '\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "120",
    "filename": "program_120.py",
    "code": "def fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError('iterations must be defined as integers')\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError('starting number must be\\n                         and integer and be more than 0')\n    if not iterations >= 1:\n        raise ValueError('Iterations must be done more than 0 times to play FizzBuzz')\n    var_0 = ''\n    while number <= iterations:\n        if number % 3 == 0:\n            var_0 += 'Fizz'\n        if number % 5 == 0:\n            var_0 += 'Buzz'\n        if 0 not in (number % 3, number % 5):\n            var_0 += str(number)\n        var_1 += 1\n        var_0 += ' '\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "121",
    "filename": "program_121.py",
    "code": "import math\n\ndef degree_radian(radian):\n    var_0 = radian * (180 / math.pi)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "122",
    "filename": "program_122.py",
    "code": "def pytest_warns(warning: type[Warning] | tuple[type[Warning], ...] | None) -> WarningsChecker | NoWarningsChecker:\n    \"\"\"\n\n    Parameters\n    ----------\n    warning : {None, Warning, Tuple[Warning]}\n        None if no warning is produced, or a single or multiple Warnings\n\n    Returns\n    -------\n    cm\n\n    \"\"\"\n    if warning is None:\n        return NoWarningsChecker()\n    else:\n        assert warning is not None\n        return warns(warning)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "123",
    "filename": "program_123.py",
    "code": "def _from_ctypes_union(t):\n    import ctypes\n    var_0 = []\n    var_1 = []\n    var_2 = []\n    for var_3, var_4 in t._fields_:\n        var_2.append(var_3)\n        var_0.append(dtype_from_ctypes_type(var_4))\n        var_1.append(0)\n    return np.dtype({'formats': var_0, 'offsets': var_1, 'names': var_2, 'itemsize': ctypes.sizeof(t)})",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "124",
    "filename": "program_124.py",
    "code": "def check_K(test_tup, K):\n    var_0 = False\n    for var_1 in test_tup:\n        if var_1 == K:\n            var_0 = True\n            break\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "125",
    "filename": "program_125.py",
    "code": "def ensure_unique(iterable, key=lambda x: x):\n    \"\"\"\n    Wrap an iterable to raise a ValueError if non-unique values are encountered.\n\n    >>> list(ensure_unique('abc'))\n    ['a', 'b', 'c']\n    >>> consume(ensure_unique('abca'))\n    Traceback (most recent call last):\n    ...\n    ValueError: Duplicate element 'a' encountered.\n    \"\"\"\n    var_0 = set()\n    var_1 = var_0.add\n    for var_2 in iterable:\n        var_3 = key(var_2)\n        if var_3 in var_0:\n            raise ValueError(f'Duplicate element {var_2!r} encountered.')\n        var_1(var_3)\n        yield var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "126",
    "filename": "program_126.py",
    "code": "def heapify(arr):\n    var_0 = len(arr) // 2\n    while var_0 >= 0:\n        shift_down(arr, var_0, len(arr) - 1)\n        var_0 -= 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "127",
    "filename": "program_127.py",
    "code": "def find_Min_Swaps(arr, n):\n    var_0 = [0] * n\n    var_1 = 0\n    var_0[n - 1] = 1 - arr[n - 1]\n    for var_2 in range(n - 2, -1, -1):\n        var_0[var_2] = var_0[var_2 + 1]\n        if arr[var_2] == 0:\n            var_0[var_2] = var_0[var_2] + 1\n    for var_2 in range(0, n):\n        if arr[var_2] == 1:\n            var_1 = var_1 + var_0[var_2]\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "128",
    "filename": "program_128.py",
    "code": "def find_ind(key, i, n, k, arr):\n    var_0 = -1\n    var_1 = i + 1\n    var_2 = n - 1\n    while var_1 < var_2:\n        var_3 = int(var_1 + (var_2 - var_1) / 2)\n        if arr[var_3] - key <= k:\n            var_0 = var_3\n            var_1 = var_3 + 1\n        else:\n            var_2 = var_3\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "129",
    "filename": "program_129.py",
    "code": "def max_volume(s):\n    var_0 = 0\n    var_1 = 1\n    for var_1 in range(s - 1):\n        var_2 = 1\n        for var_2 in range(s):\n            var_3 = s - var_1 - var_2\n            var_0 = max(var_0, var_1 * var_2 * var_3)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "130",
    "filename": "program_130.py",
    "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        var_0 = pattern[pattern_index]\n        if var_0 in pattern_map:\n            var_1 = pattern_map[var_0]\n            if input_string.startswith(var_1, str_index):\n                return backtrack(pattern_index + 1, str_index + len(var_1))\n            else:\n                return False\n        for var_2 in range(str_index + 1, len(input_string) + 1):\n            var_3 = input_string[str_index:var_2]\n            if var_3 in str_map:\n                continue\n            pattern_map[var_0] = var_3\n            str_map[var_3] = var_0\n            if backtrack(pattern_index + 1, var_2):\n                return True\n            del pattern_map[var_0]\n            del str_map[var_3]\n        return False\n    var_4: dict[str, str] = {}\n    var_5: dict[str, str] = {}\n    return backtrack(0, 0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "131",
    "filename": "program_131.py",
    "code": "def get_Inv_Count(arr, n):\n    var_0 = 0\n    for var_1 in range(n):\n        for var_2 in range(var_1 + 1, n):\n            if arr[var_1] > arr[var_2]:\n                var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "132",
    "filename": "program_132.py",
    "code": "def get_equal(Input, k):\n    if find_equal_tuple(Input, k) == 1:\n        return 'All tuples have same length'\n    else:\n        return 'All tuples do not have same length'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "133",
    "filename": "program_133.py",
    "code": "def frequency_Of_Largest(n, arr):\n    var_0 = arr[0]\n    var_1 = 1\n    for var_2 in range(1, n):\n        if arr[var_2] > var_0:\n            var_0 = arr[var_2]\n            var_1 = 1\n        elif arr[var_2] == var_0:\n            var_1 += 1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "134",
    "filename": "program_134.py",
    "code": "def surfacearea_cuboid(l, w, h):\n    var_0 = 2 * (l * w + l * h + w * h)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "135",
    "filename": "program_135.py",
    "code": "def surfacearea_cube(l):\n    var_0 = 6 * l * l\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "136",
    "filename": "program_136.py",
    "code": "def check_monthnum(monthname1):\n    if monthname1 == 'February':\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "137",
    "filename": "program_137.py",
    "code": "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    var_0 = dict(ct.ChainMap({}, dict1, dict2, dict3))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "138",
    "filename": "program_138.py",
    "code": "def show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show phase response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_phase_response(filt, 48000)\n    \"\"\"\n    var_0 = 512\n    var_1 = [1] + [0] * (var_0 - 1)\n    var_2 = [filter_type.process(item) for var_3 in var_1]\n    var_4 = [0] * (samplerate - var_0)\n    var_2 += var_4\n    var_5 = np.angle(np.fft.fft(var_2))\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel('Frequency (Hz)')\n    plt.xscale('log')\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel('Phase shift (Radians)')\n    plt.plot(np.unwrap(var_5, -2 * pi))\n    plt.show()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "139",
    "filename": "program_139.py",
    "code": "import math\n\ndef sum_gp(a, n, r):\n    var_0 = a * (1 - math.pow(r, n)) / (1 - r)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "140",
    "filename": "program_140.py",
    "code": "def count(s, c):\n    var_0 = 0\n    for var_1 in range(len(s)):\n        if s[var_1] == c:\n            var_0 = var_0 + 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "141",
    "filename": "program_141.py",
    "code": "def find_Max_Len_Even(str):\n    var_0 = len(str)\n    var_1 = 0\n    var_2 = 0\n    var_3 = 0\n    var_4 = -1\n    while var_1 < var_0:\n        if str[var_1] == ' ':\n            if var_2 % 2 == 0:\n                if var_3 < var_2:\n                    var_3 = var_2\n                    var_4 = var_1 - var_2\n            var_2 = 0\n        else:\n            var_2 += 1\n        var_1 += 1\n    if var_2 % 2 == 0:\n        if var_3 < var_2:\n            var_3 = var_2\n            var_4 = var_1 - var_2\n    if var_4 == -1:\n        return '-1'\n    return str[var_4:var_4 + var_3]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "142",
    "filename": "program_142.py",
    "code": "def unique_Characters(str):\n    for var_0 in range(len(str)):\n        for var_1 in range(var_0 + 1, len(str)):\n            if str[var_0] == str[var_1]:\n                return False\n    return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "143",
    "filename": "program_143.py",
    "code": "def rear_extract(test_list):\n    var_0 = [lis[-1] for var_1 in test_list]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "144",
    "filename": "program_144.py",
    "code": "def glob_to_regex_pattern(glob: str) -> str:\n    var_0 = ['^']\n    var_1 = False\n    var_2 = 0\n    while var_2 < len(glob):\n        var_3 = glob[var_2]\n        if var_3 == '\\\\' and var_2 + 1 < len(glob):\n            var_4 = glob[var_2 + 1]\n            var_0.append('\\\\' + var_4 if var_4 in escaped_chars else var_4)\n            var_2 += 1\n        elif var_3 == '*':\n            var_5 = glob[var_2 - 1] if var_2 > 0 else None\n            var_6 = 1\n            while var_2 + 1 < len(glob) and glob[var_2 + 1] == '*':\n                var_6 += 1\n                var_2 += 1\n            var_7 = glob[var_2 + 1] if var_2 + 1 < len(glob) else None\n            var_8 = var_6 > 1 and (var_5 == '/' or var_5 is None) and (var_7 == '/' or var_7 is None)\n            if var_8:\n                var_0.append('((?:[^/]*(?:/|$))*)')\n                var_2 += 1\n            else:\n                var_0.append('([^/]*)')\n        elif var_3 == '{':\n            var_1 = True\n            var_0.append('(')\n        elif var_3 == '}':\n            var_1 = False\n            var_0.append(')')\n        elif var_3 == ',':\n            if var_1:\n                var_0.append('|')\n            else:\n                var_0.append('\\\\' + var_3)\n        else:\n            var_0.append('\\\\' + var_3 if var_3 in escaped_chars else var_3)\n        var_2 += 1\n    var_0.append('$')\n    return ''.join(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "145",
    "filename": "program_145.py",
    "code": "def min_Swaps(str1, str2):\n    var_0 = 0\n    for var_1 in range(len(str1)):\n        if str1[var_1] != str2[var_1]:\n            var_0 += 1\n    if var_0 % 2 == 0:\n        return var_0 // 2\n    else:\n        return 'Not Possible'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "146",
    "filename": "program_146.py",
    "code": "def recur_gcd(a, b):\n    var_0 = min(a, b)\n    var_1 = max(a, b)\n    if var_0 == 0:\n        return var_1\n    elif var_0 == 1:\n        return 1\n    else:\n        return recur_gcd(var_0, var_1 % var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "147",
    "filename": "program_147.py",
    "code": "def dfs(graph: dict, vert: int, visited: list) -> list:\n    \"\"\"\n    Use depth first search to find all vertices\n    being in the same component as initial vertex\n    >>> dfs(test_graph_1, 0, 5 * [False])\n    [0, 1, 3, 2]\n    >>> dfs(test_graph_2, 0, 6 * [False])\n    [0, 1, 3, 2]\n    \"\"\"\n    visited[vert] = True\n    var_0 = []\n    for var_1 in graph[vert]:\n        if not visited[var_1]:\n            var_0 += dfs(graph, var_1, visited)\n    return [vert, *var_0]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "148",
    "filename": "program_148.py",
    "code": "def rsafactor(d: int, e: int, n: int) -> list[int]:\n    \"\"\"\n\n    This function returns the factors of N, where p*q=N\n\n    Return: [p, q]\n\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\n\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\n\n    encrypt messages.\n\n    The pair (N, d) is the secret key or private key and is known only to the recipient\n\n    of encrypted messages.\n\n    >>> rsafactor(3, 16971, 25777)\n\n    [149, 173]\n\n    >>> rsafactor(7331, 11, 27233)\n\n    [113, 241]\n\n    >>> rsafactor(4021, 13, 17711)\n\n    [89, 199]\n\n    \"\"\"\n    var_0 = d * e - 1\n    var_1 = 0\n    var_2 = 0\n    while var_1 == 0:\n        var_3 = random.randint(2, n - 1)\n        var_4 = var_0\n        while True:\n            if var_4 % 2 == 0:\n                var_4 = var_4 // 2\n                var_5 = var_3 ** var_4 % n\n                var_6 = math.gcd(var_5 - 1, n)\n                if var_5 > 1 and var_6 > 1:\n                    var_1 = var_6\n                    var_2 = n // var_6\n                    break\n            else:\n                break\n    return sorted([var_1, var_2])",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "149",
    "filename": "program_149.py",
    "code": "import re\n\ndef removezero_ip(ip):\n    var_0 = re.sub('\\\\.[0]*', '.', ip)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "150",
    "filename": "program_150.py",
    "code": "def binomial_Coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "151",
    "filename": "program_151.py",
    "code": "def find_platform(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    var_0 = 1\n    var_1 = 1\n    var_2 = 1\n    var_3 = 0\n    while var_2 < n and var_3 < n:\n        if arr[var_2] <= dep[var_3]:\n            var_0 += 1\n            var_2 += 1\n        elif arr[var_2] > dep[var_3]:\n            var_0 -= 1\n            var_3 += 1\n        if var_0 > var_1:\n            var_1 = var_0\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "152",
    "filename": "program_152.py",
    "code": "def check_element(test_tup, check_list):\n    var_0 = False\n    for var_1 in check_list:\n        if var_1 in test_tup:\n            var_0 = True\n            break\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "153",
    "filename": "program_153.py",
    "code": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    var_0 = 0\n    var_1 = len(column_title) - 1\n    var_2 = 0\n    while var_1 >= 0:\n        var_3 = (ord(column_title[var_1]) - 64) * pow(26, var_2)\n        var_0 += var_3\n        var_2 += 1\n        var_1 -= 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "154",
    "filename": "program_154.py",
    "code": "def upper_ctr(str):\n    var_0 = 0\n    for var_1 in range(len(str)):\n        if str[var_1] >= 'A' and str[var_1] <= 'Z':\n            var_0 += 1\n        return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "155",
    "filename": "program_155.py",
    "code": "def extract_column(list1, n):\n    var_0 = [i.pop(n) for var_1 in list1]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "156",
    "filename": "program_156.py",
    "code": "def sort_tuple(tup):\n    var_0 = len(tup)\n    for var_1 in range(0, var_0):\n        for var_2 in range(0, var_0 - var_1 - 1):\n            if tup[var_2][-1] > tup[var_2 + 1][-1]:\n                var_3 = tup[var_2]\n                tup[var_2] = tup[var_2 + 1]\n                tup[var_2 + 1] = var_3\n    return tup",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "157",
    "filename": "program_157.py",
    "code": "import math\n\ndef get_Pos_Of_Right_most_Set_Bit(n):\n    return int(math.log2(n & -n) + 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "158",
    "filename": "program_158.py",
    "code": "def rencontres_number(n, m):\n    if n == 0 and m == 0:\n        return 1\n    if n == 1 and m == 0:\n        return 0\n    if m == 0:\n        return (n - 1) * (rencontres_number(n - 1, 0) + rencontres_number(n - 2, 0))\n    return binomial_coeffi(n, m) * rencontres_number(n - m, 0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "159",
    "filename": "program_159.py",
    "code": "def division_elements(test_tup1, test_tup2):\n    var_0 = tuple((ele1 // ele2 for var_1, var_2 in zip(test_tup1, test_tup2)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "160",
    "filename": "program_160.py",
    "code": "def diff_consecutivenums(nums):\n    var_0 = [b - a for var_1, var_2 in zip(nums[:-1], nums[1:])]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "161",
    "filename": "program_161.py",
    "code": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "162",
    "filename": "program_162.py",
    "code": "def bin_to_octal(bin_string: str) -> str:\n    if not all((char in '01' for var_0 in bin_string)):\n        raise ValueError('Non-binary value was passed to the function')\n    if not bin_string:\n        raise ValueError('Empty string was passed to the function')\n    var_1 = ''\n    while len(bin_string) % 3 != 0:\n        var_2 = '0' + var_2\n    var_3 = [var_2[index:index + 3] for var_4 in range(len(var_2)) if var_4 % 3 == 0]\n    for var_5 in var_3:\n        var_6 = 0\n        for var_4, var_7 in enumerate(var_5):\n            var_6 += int(2 ** (2 - var_4) * int(var_7))\n        var_1 += str(var_6)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "163",
    "filename": "program_163.py",
    "code": "import re\n\ndef is_decimal(num):\n    var_0 = re.compile('^[0-9]+(\\\\.[0-9]{1,2})?$')\n    var_1 = var_0.search(num)\n    return bool(var_1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "164",
    "filename": "program_164.py",
    "code": "def remove_elements(list1, list2):\n    var_0 = [x for var_1 in list1 if var_1 not in list2]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "165",
    "filename": "program_165.py",
    "code": "def perfect_cube_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_cube_binary_search(27)\n    True\n    >>> perfect_cube_binary_search(64)\n    True\n    >>> perfect_cube_binary_search(4)\n    False\n    >>> perfect_cube_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    >>> perfect_cube_binary_search(0.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError('perfect_cube_binary_search() only accepts integers')\n    if n < 0:\n        var_0 = -var_0\n    var_1 = 0\n    var_2 = var_0\n    while var_1 <= var_2:\n        var_3 = var_1 + (var_2 - var_1) // 2\n        if var_3 * var_3 * var_3 == var_0:\n            return True\n        elif var_3 * var_3 * var_3 < var_0:\n            var_1 = var_3 + 1\n        else:\n            var_2 = var_3 - 1\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "166",
    "filename": "program_166.py",
    "code": "def is_success(code):\n    return 200 <= code <= 299",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "167",
    "filename": "program_167.py",
    "code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    var_0 = (1 << r) - 1 ^ (1 << l - 1) - 1\n    var_1 = n & var_0\n    if var_1 == 0:\n        return True\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "168",
    "filename": "program_168.py",
    "code": "def numeric_dtype_min_max(dtype):\n    \"\"\"Return minimum and maximum representable value for a given dtype.\n\n    A convenient wrapper around `numpy.finfo` and `numpy.iinfo` that\n    additionally supports numpy.bool as well.\n\n    Parameters\n    ----------\n    dtype : numpy.dtype\n        The dtype. Tries to convert Python \"types\" such as int or float, to\n        the corresponding NumPy dtype.\n\n    Returns\n    -------\n    min, max : number\n        Minimum and maximum of the given `dtype`. These scalars are themselves\n        of the given `dtype`.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> numeric_dtype_min_max(np.uint8)\n    (0, 255)\n    >>> numeric_dtype_min_max(bool)\n    (False, True)\n    >>> numeric_dtype_min_max(np.float64)\n    (-1.7976931348623157e+308, 1.7976931348623157e+308)\n    >>> numeric_dtype_min_max(int)\n    (-9223372036854775808, 9223372036854775807)\n    \"\"\"\n    var_0 = np.dtype(var_0)\n    if np.issubdtype(var_0, np.integer):\n        var_1 = np.iinfo(var_0)\n        var_2 = var_0.type(var_1.min)\n        var_3 = var_0.type(var_1.max)\n    elif np.issubdtype(var_0, np.inexact):\n        var_1 = np.finfo(var_0)\n        var_2 = var_1.min\n        var_3 = var_1.max\n    elif np.issubdtype(var_0, np.dtype(bool)):\n        var_2 = var_0.type(False)\n        var_3 = var_0.type(True)\n    else:\n        raise ValueError(f'unsupported dtype {var_0!r}')\n    return (var_2, var_3)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "169",
    "filename": "program_169.py",
    "code": "def maximum_segments(n, a, b, c):\n    var_0 = [-1] * (n + 10)\n    var_0[0] = 0\n    for var_1 in range(0, n):\n        if var_0[var_1] != -1:\n            if var_1 + a <= n:\n                var_0[var_1 + a] = max(var_0[var_1] + 1, var_0[var_1 + a])\n            if var_1 + b <= n:\n                var_0[var_1 + b] = max(var_0[var_1] + 1, var_0[var_1 + b])\n            if var_1 + c <= n:\n                var_0[var_1 + c] = max(var_0[var_1] + 1, var_0[var_1 + c])\n    return var_0[n]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "170",
    "filename": "program_170.py",
    "code": "def ascii_value(k):\n    var_0 = k\n    return ord(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "171",
    "filename": "program_171.py",
    "code": "def get_index_of_rightmost_set_bit(number: int) -> int:\n    \"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError('Input must be a non-negative integer')\n    var_0 = number & ~(number - 1)\n    var_1 = 0\n    while var_0:\n        var_0 >>= 1\n        var_1 += 1\n    return var_1 - 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "172",
    "filename": "program_172.py",
    "code": "def circle_circumference(r):\n    var_0 = 2 * 3.1415 * r\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "173",
    "filename": "program_173.py",
    "code": "def sub_list(nums1, nums2):\n    var_0 = map(lambda x, y: x - y, nums1, nums2)\n    return list(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "174",
    "filename": "program_174.py",
    "code": "def dealnnoy_num(n, m):\n    if m == 0 or n == 0:\n        return 1\n    return dealnnoy_num(m - 1, n) + dealnnoy_num(m - 1, n - 1) + dealnnoy_num(m, n - 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "175",
    "filename": "program_175.py",
    "code": "def decimal_to_Octal(deciNum):\n    var_0 = 0\n    var_1 = 1\n    var_2 = deciNum\n    while deciNum != 0:\n        var_3 = deciNum % 8\n        var_0 += var_3 * var_1\n        var_1 = var_1 * 10\n        var_4 //= 8\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "176",
    "filename": "program_176.py",
    "code": "def first_Missing_Positive(arr, n):\n    var_0 = 0\n    for var_1 in range(n):\n        if arr[var_1] == 1:\n            var_0 = 1\n            break\n    if var_0 == 0:\n        return 1\n    for var_1 in range(n):\n        if arr[var_1] <= 0 or arr[var_1] > n:\n            arr[var_1] = 1\n    for var_1 in range(n):\n        arr[(arr[var_1] - 1) % n] += n\n    for var_1 in range(n):\n        if arr[var_1] <= n:\n            return var_1 + 1\n    return n + 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "177",
    "filename": "program_177.py",
    "code": "def letter_combinations(digits):\n    if digits == '':\n        return []\n    var_0 = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    var_1 = ['']\n    for var_2 in digits:\n        var_3 = []\n        for var_4 in var_1:\n            for var_5 in var_0[var_2]:\n                var_3.append(var_4 + var_5)\n        var_1 = var_3\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "178",
    "filename": "program_178.py",
    "code": "import math\n\ndef volume_sphere(r):\n    var_0 = 4 / 3 * math.pi * r * r * r\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "179",
    "filename": "program_179.py",
    "code": "def big_diff(nums):\n    var_0 = max(nums) - min(nums)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "180",
    "filename": "program_180.py",
    "code": "def add_str(test_tup, K):\n    var_0 = [ele for var_1 in test_tup for var_2 in (var_1, K)]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "181",
    "filename": "program_181.py",
    "code": "def get_output_shapes(model_data):\n    \"\"\"Returns a list of output shapes in the tflite model data.\"\"\"\n    var_0 = schema_fb.Model.GetRootAsModel(model_data, 0)\n    var_1 = []\n    for var_2 in range(var_0.SubgraphsLength()):\n        var_3 = var_0.Subgraphs(var_2)\n        for var_4 in range(var_3.OutputsLength()):\n            var_5 = var_3.Outputs(var_4)\n            var_6 = var_3.Tensors(var_5)\n            var_1.append(var_6.ShapeAsNumpy().tolist())\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "182",
    "filename": "program_182.py",
    "code": "def list_tuple(listx):\n    var_0 = tuple(listx)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "183",
    "filename": "program_183.py",
    "code": "def toggle_string(string):\n    var_0 = string.swapcase()\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "184",
    "filename": "program_184.py",
    "code": "def even_num(x):\n    if x % 2 == 0:\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "185",
    "filename": "program_185.py",
    "code": "def sum_Natural(n):\n    var_0 = n * (n + 1)\n    return int(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "186",
    "filename": "program_186.py",
    "code": "def mincost_tickets(days: list[int], costs: list[int]) -> int:\n    \"\"\"\n    >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])\n    11\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])\n    17\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    24\n\n    >>> mincost_tickets([2], [2, 90, 150])\n    2\n\n    >>> mincost_tickets([], [2, 90, 150])\n    0\n\n    >>> mincost_tickets('hello', [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([], 'world')\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be greater than 0\n\n    >>> mincost_tickets([2, 367], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be less than 366\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n    \"\"\"\n    if not isinstance(days, list) or not all((isinstance(day, int) for var_0 in days)):\n        raise ValueError('The parameter days should be a list of integers')\n    if len(costs) != 3 or not all((isinstance(cost, int) for var_1 in costs)):\n        raise ValueError('The parameter costs should be a list of three integers')\n    if len(days) == 0:\n        return 0\n    if min(days) <= 0:\n        raise ValueError('All days elements should be greater than 0')\n    if max(days) >= 366:\n        raise ValueError('All days elements should be less than 366')\n    var_2 = set(days)\n\n    @functools.cache\n    def dynamic_programming(index: int) -> int:\n        if index > 365:\n            return 0\n        if index not in var_2:\n            return dynamic_programming(index + 1)\n        return min(costs[0] + dynamic_programming(index + 1), costs[1] + dynamic_programming(index + 7), costs[2] + dynamic_programming(index + 30))\n    return dynamic_programming(1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "187",
    "filename": "program_187.py",
    "code": "def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:\n    \"\"\"\n    Perform topological sorting of a Directed Acyclic Graph (DAG)\n    using Kahn's Algorithm via Breadth-First Search (BFS).\n\n    Topological sorting is a linear ordering of vertices in a graph such that for\n    every directed edge u \u2192 v, vertex u comes before vertex v in the ordering.\n\n    Parameters:\n    graph: Adjacency list representing the directed graph where keys are\n           vertices, and values are lists of adjacent vertices.\n\n    Returns:\n    The topologically sorted order of vertices if the graph is a DAG.\n    Returns None if the graph contains a cycle.\n\n    Example:\n    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n    >>> topological_sort(graph)\n    [0, 1, 2, 3, 4, 5]\n\n    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n    >>> topological_sort(graph_with_cycle)\n    \"\"\"\n    var_0 = [0] * len(graph)\n    var_1 = []\n    var_2 = []\n    var_3 = 0\n    for var_4 in graph.values():\n        for var_5 in var_4:\n            var_0[var_5] += 1\n    for var_5 in range(len(var_0)):\n        if var_0[var_5] == 0:\n            var_1.append(var_5)\n    while var_1:\n        var_6 = var_1.pop(0)\n        var_3 += 1\n        var_2.append(var_6)\n        for var_7 in graph[var_6]:\n            var_0[var_7] -= 1\n            if var_0[var_7] == 0:\n                var_1.append(var_7)\n    if var_3 != len(graph):\n        return None\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "188",
    "filename": "program_188.py",
    "code": "def flatten_tuple(test_list):\n    var_0 = ' '.join([idx for var_1 in test_list for var_2 in var_1])\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "189",
    "filename": "program_189.py",
    "code": "import math\n\ndef max_Prime_Factors(n):\n    var_0 = -1\n    while n % 2 == 0:\n        var_0 = 2\n        var_1 >>= 1\n    for var_2 in range(3, int(math.sqrt(var_1)) + 1, 2):\n        while var_1 % var_2 == 0:\n            var_0 = var_2\n            var_1 = var_1 / var_2\n    if var_1 > 2:\n        var_0 = var_1\n    return int(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "190",
    "filename": "program_190.py",
    "code": "def find_Divisor(x, y):\n    if x == y:\n        return y\n    return 2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "191",
    "filename": "program_191.py",
    "code": "def count_Squares(m, n):\n    if n < m:\n        var_0 = m\n        var_1 = n\n        var_2 = var_0\n    return var_1 * (var_1 + 1) * (2 * var_1 + 1) / 6 + (var_2 - var_1) * var_1 * (var_1 + 1) / 2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "192",
    "filename": "program_192.py",
    "code": "def is_upper(string):\n    return string.upper()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "193",
    "filename": "program_193.py",
    "code": "def list_of_submasks(mask: int) -> list[int]:\n    \"\"\"\n    Args:\n        mask : number which shows mask ( always integer > 0, zero does not have any\n            submasks )\n\n    Returns:\n        all_submasks : the list of submasks of mask (mask s is called submask of mask\n        m if only bits that were included in original mask are set\n\n    Raises:\n        AssertionError: mask not positive integer\n\n    >>> list_of_submasks(15)\n    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    >>> list_of_submasks(13)\n    [13, 12, 9, 8, 5, 4, 1]\n    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input -7\n    >>> list_of_submasks(0)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input 0\n\n    \"\"\"\n    assert isinstance(mask, int) and mask > 0, f'mask needs to be positive integer, your input {mask}'\n    '\\n    first submask iterated will be mask itself then operation will be performed\\n    to get other submasks till we reach empty submask that is zero ( zero is not\\n    included in final submasks list )\\n    '\n    var_0 = []\n    var_1 = mask\n    while var_1:\n        var_0.append(var_1)\n        var_1 = var_1 - 1 & mask\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "194",
    "filename": "program_194.py",
    "code": "def func(nums, k):\n    import collections\n    var_0 = collections.defaultdict(int)\n    for var_1 in nums:\n        for var_2 in var_1:\n            var_0[var_2] += 1\n    var_3 = []\n    import heapq\n    for var_4, var_5 in var_0.items():\n        if len(var_3) < k:\n            var_3.append((var_5, var_4))\n            if len(var_3) == k:\n                heapq.heapify(var_3)\n        elif var_5 > var_3[0][0]:\n            heapq.heappop(var_3)\n            heapq.heappush(var_3, (var_5, var_4))\n    var_6 = []\n    while var_3:\n        var_5, var_4 = heapq.heappop(var_3)\n        var_6.append(var_4)\n    return var_6",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "195",
    "filename": "program_195.py",
    "code": "def rectangle_perimeter(l, b):\n    var_0 = 2 * (l + b)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "196",
    "filename": "program_196.py",
    "code": "def invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    var_0, var_1 = extended_euclid(a, n)\n    if var_0 < 0:\n        var_0 = (var_0 % n + n) % n\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "197",
    "filename": "program_197.py",
    "code": "import math\n\ndef min_Operations(A, B):\n    if A > B:\n        swap(A, B)\n    var_0 = var_0 // math.gcd(A, var_0)\n    return var_0 - 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "198",
    "filename": "program_198.py",
    "code": "def sample_nam(sample_names):\n    var_0 = list(filter(lambda el: el[0].isupper() and el[1:].islower(), var_0))\n    return len(''.join(var_0))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "199",
    "filename": "program_199.py",
    "code": "def sum_Square(n):\n    var_0 = 1\n    while var_0 * var_0 <= n:\n        var_1 = 1\n        while var_1 * var_1 <= n:\n            if var_0 * var_0 + var_1 * var_1 == n:\n                return True\n            var_1 = var_1 + 1\n        var_0 = var_0 + 1\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "200",
    "filename": "program_200.py",
    "code": "def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if partitions <= 0:\n        raise ValueError('partitions must be a positive number!')\n    if partitions > number_of_bytes:\n        raise ValueError('partitions can not > number_of_bytes!')\n    var_0 = number_of_bytes // partitions\n    var_1 = []\n    for var_2 in range(partitions):\n        var_3 = var_2 * var_0 + 1\n        var_4 = number_of_bytes if var_2 == partitions - 1 else (var_2 + 1) * var_0\n        var_1.append(f'{var_3}-{var_4}')\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "201",
    "filename": "program_201.py",
    "code": "def listify_list(list1):\n    var_0 = list(map(list, list1))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "202",
    "filename": "program_202.py",
    "code": "def immediate_dominators(G, start):\n    \"\"\"Returns the immediate dominators of all nodes of a directed graph.\n\n    Parameters\n    ----------\n    G : a DiGraph or MultiDiGraph\n        The graph where dominance is to be computed.\n\n    start : node\n        The start node of dominance computation.\n\n    Returns\n    -------\n    idom : dict keyed by nodes\n        A dict containing the immediate dominators of each node reachable from\n        `start`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    NetworkXError\n        If `start` is not in `G`.\n\n    Notes\n    -----\n    Except for `start`, the immediate dominators are the parents of their\n    corresponding nodes in the dominator tree.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n    >>> sorted(nx.immediate_dominators(G, 1).items())\n    [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]\n\n    References\n    ----------\n    .. [1] Cooper, Keith D., Harvey, Timothy J. and Kennedy, Ken.\n           \"A simple, fast dominance algorithm.\" (2006).\n           https://hdl.handle.net/1911/96345\n    \"\"\"\n    if start not in G:\n        raise nx.NetworkXError('start is not in G')\n    var_0 = {start: start}\n    var_1 = list(nx.dfs_postorder_nodes(G, start))\n    var_2 = {u: i for var_3, var_4 in enumerate(var_1)}\n    var_1.pop()\n    var_1.reverse()\n\n    def intersect(u, v):\n        while var_4 != v:\n            while var_2[var_4] < var_2[v]:\n                var_4 = var_0[var_4]\n            while var_2[var_4] > var_2[v]:\n                var_5 = var_0[var_5]\n        return var_4\n    var_6 = True\n    while var_6:\n        var_6 = False\n        for var_4 in var_1:\n            var_7 = reduce(intersect, (var_5 for var_5 in G.pred[var_4] if var_5 in var_0))\n            if var_4 not in var_0 or var_0[var_4] != var_7:\n                var_0[var_4] = var_7\n                var_6 = True\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "203",
    "filename": "program_203.py",
    "code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return 'Input is not an integer!'\n    if limit < 1:\n        return 'Input must be bigger than 0!'\n    var_0 = set()\n    for var_1 in range(2, limit + 1):\n        if var_1 in var_0:\n            continue\n        var_2 = sum([fact for var_3 in range(1, var_1) if var_1 % var_3 == 0])\n        var_4 = sum([var_3 for var_3 in range(1, var_2) if var_2 % var_3 == 0])\n        if var_1 == var_4 and var_1 != var_2:\n            var_0.add(var_1)\n            var_0.add(var_4)\n    return sum(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "204",
    "filename": "program_204.py",
    "code": "def solve_maze(maze: list[list[int]], source_row: int, source_column: int, destination_row: int, destination_column: int) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    var_0 = len(maze)\n    if not (0 <= source_row <= var_0 - 1 and 0 <= source_column <= var_0 - 1) or not (0 <= destination_row <= var_0 - 1 and 0 <= destination_column <= var_0 - 1):\n        raise ValueError('Invalid source or destination coordinates')\n    var_1 = [[1 for var_2 in range(var_0)] for var_2 in range(var_0)]\n    var_3 = run_maze(maze, source_row, source_column, destination_row, destination_column, var_1)\n    if var_3:\n        return var_1\n    else:\n        raise ValueError('No solution exists!')",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "205",
    "filename": "program_205.py",
    "code": "def is_odd(n):\n    if n ^ 1 == n - 1:\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "206",
    "filename": "program_206.py",
    "code": "def lcp_w_suffix_str(array, s):\n    var_0 = len(array)\n    var_1 = [0] * var_0\n    var_2 = [0] * var_0\n    for var_3 in range(var_0):\n        var_2[array[var_3]] = var_3\n    var_4 = 0\n    for var_3 in range(var_0):\n        if var_2[var_3] == var_0 - 1:\n            var_4 = 0\n            continue\n        var_5 = array[var_2[var_3] + 1]\n        while var_3 + var_4 < var_0 and var_5 + var_4 < var_0 and (s[var_3 + var_4] == s[var_5 + var_4]):\n            var_4 += 1\n        var_1[var_2[var_3]] = var_4\n        if var_4 > 0:\n            var_4 -= 1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "207",
    "filename": "program_207.py",
    "code": "def neg_count(list):\n    var_0 = 0\n    for var_1 in list:\n        if var_1 <= 0:\n            var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "208",
    "filename": "program_208.py",
    "code": "def divisor(n):\n    for var_0 in range(n):\n        var_1 = len([var_0 for var_0 in range(1, n + 1) if not n % var_0])\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "209",
    "filename": "program_209.py",
    "code": "import re\n\ndef match_num(string):\n    var_0 = re.compile('^5')\n    if var_0.match(string):\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "210",
    "filename": "program_210.py",
    "code": "def toggle_middle_bits(n):\n    if n == 1:\n        return 1\n    return n ^ set_middle_bits(n)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "211",
    "filename": "program_211.py",
    "code": "import re\n\ndef text_match_one(text):\n    var_0 = 'ab+?'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "212",
    "filename": "program_212.py",
    "code": "def min_difference(test_list):\n    var_0 = [abs(b - a) for var_1, var_2 in test_list]\n    var_3 = min(var_0)\n    return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "213",
    "filename": "program_213.py",
    "code": "def simple_interest(principal: float, daily_interest_rate: float, days_between_payments: float) -> float:\n    \"\"\"\n    >>> simple_interest(18000.0, 0.06, 3)\n    3240.0\n    >>> simple_interest(0.5, 0.06, 3)\n    0.09\n    >>> simple_interest(18000.0, 0.01, 10)\n    1800.0\n    >>> simple_interest(18000.0, 0.0, 3)\n    0.0\n    >>> simple_interest(5500.0, 0.01, 100)\n    5500.0\n    >>> simple_interest(10000.0, -0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: daily_interest_rate must be >= 0\n    >>> simple_interest(-10000.0, 0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    >>> simple_interest(5500.0, 0.01, -5)\n    Traceback (most recent call last):\n        ...\n    ValueError: days_between_payments must be > 0\n    \"\"\"\n    if days_between_payments <= 0:\n        raise ValueError('days_between_payments must be > 0')\n    if daily_interest_rate < 0:\n        raise ValueError('daily_interest_rate must be >= 0')\n    if principal <= 0:\n        raise ValueError('principal must be > 0')\n    return principal * daily_interest_rate * days_between_payments",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "214",
    "filename": "program_214.py",
    "code": "import re\n\ndef replace_spaces(text):\n    var_0 = var_0.replace(' ', '_')\n    return var_0\n    var_0 = var_0.replace('_', ' ')\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "215",
    "filename": "program_215.py",
    "code": "def get_1s_count(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError('Input must be a non-negative integer')\n    var_0 = 0\n    while number:\n        var_1 &= var_1 - 1\n        var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "216",
    "filename": "program_216.py",
    "code": "import math\n\ndef surfacearea_sphere(r):\n    var_0 = 4 * math.pi * r * r\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "217",
    "filename": "program_217.py",
    "code": "def reverse_bit(number: int) -> str:\n    \"\"\"\n    Take in an 32 bit integer, reverse its bits,\n    return a string of reverse bits\n\n    result of a reverse_bit and operation on the integer provided.\n\n    >>> reverse_bit(25)\n    '00000000000000000000000000011001'\n    >>> reverse_bit(37)\n    '00000000000000000000000000100101'\n    >>> reverse_bit(21)\n    '00000000000000000000000000010101'\n    >>> reverse_bit(58)\n    '00000000000000000000000000111010'\n    >>> reverse_bit(0)\n    '00000000000000000000000000000000'\n    >>> reverse_bit(256)\n    '00000000000000000000000100000000'\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be positive\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if number < 0:\n        raise ValueError('the value of input must be positive')\n    elif isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    elif isinstance(number, str):\n        raise TypeError(\"'<' not supported between instances of 'str' and 'int'\")\n    var_0 = 0\n    for var_1 in range(1, 33):\n        var_0 = var_0 << 1\n        var_2 = number % 2\n        var_3 = var_3 >> 1\n        var_0 = var_0 | var_2\n    return get_reverse_bit_string(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "218",
    "filename": "program_218.py",
    "code": "def count_elim(num):\n    var_0 = 0\n    for var_1 in num:\n        if isinstance(var_1, tuple):\n            break\n        var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "219",
    "filename": "program_219.py",
    "code": "def swap_List(newList):\n    var_0 = len(newList)\n    var_1 = newList[0]\n    newList[0] = newList[var_0 - 1]\n    newList[var_0 - 1] = var_1\n    return newList",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "220",
    "filename": "program_220.py",
    "code": "import re\n\ndef road_rd(street):\n    return re.sub('Road$', 'Rd.', street)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "221",
    "filename": "program_221.py",
    "code": "import re\n\ndef check_substring(string, sample):\n    if sample in string:\n        var_0 = '\\\\A' + sample\n        var_1 = re.search(var_0, string)\n        if var_1:\n            return 'string starts with the given substring'\n        else:\n            return 'string doesnt start with the given substring'\n    else:\n        return 'entered string isnt a substring'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "222",
    "filename": "program_222.py",
    "code": "def make_flip(ch):\n    return '1' if ch == '0' else '0'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "223",
    "filename": "program_223.py",
    "code": "def excess_3_code(number: int) -> str:\n    \"\"\"\n    Find excess-3 code of integer base 10.\n    Add 3 to all digits in a decimal number then convert to a binary-coded decimal.\n    https://en.wikipedia.org/wiki/Excess-3\n\n    >>> excess_3_code(0)\n    '0b0011'\n    >>> excess_3_code(3)\n    '0b0110'\n    >>> excess_3_code(2)\n    '0b0101'\n    >>> excess_3_code(20)\n    '0b01010011'\n    >>> excess_3_code(120)\n    '0b010001010011'\n    \"\"\"\n    var_0 = ''\n    for var_1 in str(max(0, number)):\n        var_0 += str(bin(int(var_1) + 3))[2:].zfill(4)\n    return '0b' + var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "224",
    "filename": "program_224.py",
    "code": "import sys\n\ndef next_smallest_palindrome(num):\n    var_0 = str(num)\n    for var_1 in range(num + 1, sys.maxsize):\n        if str(var_1) == str(var_1)[::-1]:\n            return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "225",
    "filename": "program_225.py",
    "code": "def volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:\n    \"\"\"\n    >>> volume_of_gas_system(2, 100, 5)\n    332.57848\n    >>> volume_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> volume_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or kelvin < 0 or pressure < 0:\n        raise ValueError('Invalid inputs. Enter positive value.')\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "226",
    "filename": "program_226.py",
    "code": "import re\n\ndef check_literals(text, patterns):\n    for var_0 in patterns:\n        if re.search(var_0, text):\n            return 'Matched!'\n        else:\n            return 'Not Matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "227",
    "filename": "program_227.py",
    "code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n    if number <= 0:\n        var_0 = f'n must be greater than 0. Got n = {number}'\n        raise ValueError(var_0)\n    var_1 = [number + 1] * (number + 1)\n    var_1[1] = 0\n    for var_2 in range(1, number):\n        var_1[var_2 + 1] = min(var_1[var_2 + 1], var_1[var_2] + 1)\n        if var_2 * 2 <= number:\n            var_1[var_2 * 2] = min(var_1[var_2 * 2], var_1[var_2] + 1)\n        if var_2 * 3 <= number:\n            var_1[var_2 * 3] = min(var_1[var_2 * 3], var_1[var_2] + 1)\n    return var_1[number]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "228",
    "filename": "program_228.py",
    "code": "def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n\n    A matrix multiplied with its inverse gives the identity matrix.\n\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n\n    [[0.0, 0.5], [0.2, -0.2]]\n\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    \"\"\"\n    var_0 = Decimal\n    if len(matrix) == 2 and len(matrix[0]) == 2 and (len(matrix[1]) == 2):\n        var_1 = float(var_0(matrix[0][0]) * var_0(matrix[1][1]) - var_0(matrix[1][0]) * var_0(matrix[0][1]))\n        if var_1 == 0:\n            raise ValueError('This matrix has no inverse.')\n        var_2 = [[0.0, 0.0], [0.0, 0.0]]\n        var_2[0][0], var_2[1][1] = (matrix[1][1], matrix[0][0])\n        var_2[1][0], var_2[0][1] = (-matrix[1][0], -matrix[0][1])\n        return [[float(var_0(n)) / var_1 or 0.0 for var_3 in row] for var_4 in var_2]\n    elif len(matrix) == 3 and len(matrix[0]) == 3 and (len(matrix[1]) == 3) and (len(matrix[2]) == 3):\n        var_1 = float(var_0(matrix[0][0]) * var_0(matrix[1][1]) * var_0(matrix[2][2]) + var_0(matrix[0][1]) * var_0(matrix[1][2]) * var_0(matrix[2][0]) + var_0(matrix[0][2]) * var_0(matrix[1][0]) * var_0(matrix[2][1]) - (var_0(matrix[0][2]) * var_0(matrix[1][1]) * var_0(matrix[2][0]) + var_0(matrix[0][1]) * var_0(matrix[1][0]) * var_0(matrix[2][2]) + var_0(matrix[0][0]) * var_0(matrix[1][2]) * var_0(matrix[2][1])))\n        if var_1 == 0:\n            raise ValueError('This matrix has no inverse.')\n        var_5 = [[var_0(0.0), var_0(0.0), var_0(0.0)], [var_0(0.0), var_0(0.0), var_0(0.0)], [var_0(0.0), var_0(0.0), var_0(0.0)]]\n        var_5[0][0] = var_0(matrix[1][1]) * var_0(matrix[2][2]) - var_0(matrix[1][2]) * var_0(matrix[2][1])\n        var_5[0][1] = -(var_0(matrix[1][0]) * var_0(matrix[2][2]) - var_0(matrix[1][2]) * var_0(matrix[2][0]))\n        var_5[0][2] = var_0(matrix[1][0]) * var_0(matrix[2][1]) - var_0(matrix[1][1]) * var_0(matrix[2][0])\n        var_5[1][0] = -(var_0(matrix[0][1]) * var_0(matrix[2][2]) - var_0(matrix[0][2]) * var_0(matrix[2][1]))\n        var_5[1][1] = var_0(matrix[0][0]) * var_0(matrix[2][2]) - var_0(matrix[0][2]) * var_0(matrix[2][0])\n        var_5[1][2] = -(var_0(matrix[0][0]) * var_0(matrix[2][1]) - var_0(matrix[0][1]) * var_0(matrix[2][0]))\n        var_5[2][0] = var_0(matrix[0][1]) * var_0(matrix[1][2]) - var_0(matrix[0][2]) * var_0(matrix[1][1])\n        var_5[2][1] = -(var_0(matrix[0][0]) * var_0(matrix[1][2]) - var_0(matrix[0][2]) * var_0(matrix[1][0]))\n        var_5[2][2] = var_0(matrix[0][0]) * var_0(matrix[1][1]) - var_0(matrix[0][1]) * var_0(matrix[1][0])\n        var_6 = array(var_5)\n        for var_7 in range(3):\n            for var_8 in range(3):\n                var_6[var_7][var_8] = var_5[var_8][var_7]\n        var_9 = array(var_5)\n        for var_7 in range(3):\n            for var_8 in range(3):\n                var_9[var_7][var_8] /= var_0(var_1)\n        return [[float(var_0(var_3)) or 0.0 for var_3 in var_4] for var_4 in var_9]\n    raise ValueError('Please provide a matrix of size 2x2 or 3x3.')",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "229",
    "filename": "program_229.py",
    "code": "def num_islands(grid):\n    var_0 = 0\n    for var_1 in range(len(grid)):\n        for var_2, var_3 in enumerate(grid[var_1]):\n            if var_3 == 1:\n                dfs(grid, var_1, var_2)\n                var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "230",
    "filename": "program_230.py",
    "code": "def max_ones_index(arr):\n    var_0 = len(arr)\n    var_1 = 0\n    var_2 = 0\n    var_3 = -1\n    var_4 = -1\n    for var_5 in range(var_0):\n        if arr[var_5] == 0:\n            if var_5 - var_4 > var_1:\n                var_1 = var_5 - var_4\n                var_2 = var_3\n            var_4 = var_3\n            var_3 = var_5\n    if var_0 - var_4 > var_1:\n        var_2 = var_3\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "231",
    "filename": "program_231.py",
    "code": "def is_nonagonal(n):\n    return int(n * (7 * n - 5) / 2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "232",
    "filename": "program_232.py",
    "code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    var_0 = len(arr)\n    var_1 = [[False] * (required_sum + 1) for var_2 in range(var_0 + 1)]\n    for var_3 in range(var_0 + 1):\n        var_1[var_3][0] = True\n    for var_3 in range(1, required_sum + 1):\n        var_1[0][var_3] = False\n    for var_3 in range(1, var_0 + 1):\n        for var_4 in range(1, required_sum + 1):\n            if arr[var_3 - 1] > var_4:\n                var_1[var_3][var_4] = var_1[var_3 - 1][var_4]\n            if arr[var_3 - 1] <= var_4:\n                var_1[var_3][var_4] = var_1[var_3 - 1][var_4] or var_1[var_3 - 1][var_4 - arr[var_3 - 1]]\n    return var_1[var_0][required_sum]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "233",
    "filename": "program_233.py",
    "code": "def round_logprob(op, values, base_rv, **kwargs):\n    \"\"\"Logprob of a rounded censored distribution.\n\n    The probability of a distribution rounded to the nearest integer is given by\n    .. math::\n        \\\\begin{cases}\n            \\\\text{CDF}(x+\\\\frac{1}{2}, dist) - \\\\text{CDF}(x-\\\\frac{1}{2}, dist) & \\\\text{for } x \\\\in \\\\mathbb{Z}, \\\\\\\\\n            0 & \\\\text{otherwise},\n        \\\\end{cases}\n\n    The probability of a distribution rounded up is given by\n    .. math::\n        \\\\begin{cases}\n            \\\\text{CDF}(x, dist) - \\\\text{CDF}(x-1, dist) & \\\\text{for } x \\\\in \\\\mathbb{Z}, \\\\\\\\\n            0 & \\\\text{otherwise},\n        \\\\end{cases}\n\n    The probability of a distribution rounded down is given by\n    .. math::\n        \\\\begin{cases}\n            \\\\text{CDF}(x+1, dist) - \\\\text{CDF}(x, dist) & \\\\text{for } x \\\\in \\\\mathbb{Z}, \\\\\\\\\n            0 & \\\\text{otherwise},\n        \\\\end{cases}\n\n    \"\"\"\n    var_0, = values\n    if isinstance(op.scalar_op, RoundHalfToEven):\n        var_0 = pt.round(var_0)\n        var_1 = var_0 + 0.5\n        var_2 = var_0 - 0.5\n    elif isinstance(op.scalar_op, Floor):\n        var_0 = pt.floor(var_0)\n        var_1 = var_0 + 1.0\n        var_2 = var_0\n    elif isinstance(op.scalar_op, Ceil):\n        var_0 = pt.ceil(var_0)\n        var_1 = var_0\n        var_2 = var_0 - 1.0\n    else:\n        raise TypeError(f'Unsupported scalar_op {op.scalar_op}')\n    var_3 = base_rv.owner.op\n    var_4 = base_rv.owner.inputs\n    var_5 = _logcdf(var_3, var_1, *var_4, **kwargs)\n    var_6 = _logcdf(var_3, var_2, *var_4, **kwargs)\n    if var_3.name:\n        var_5.name = f'{var_3}_logcdf_upper'\n        var_6.name = f'{var_3}_logcdf_lower'\n    from pymc.math import logdiffexp\n    return logdiffexp(var_5, var_6)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "234",
    "filename": "program_234.py",
    "code": "import re\n\ndef remove_lowercase(str1):\n    var_0 = lambda text: re.sub('[a-z]', '', text)\n    var_1 = var_0(str1)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "235",
    "filename": "program_235.py",
    "code": "def factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    var_0: list[int] = []\n    if num < 1:\n        return var_0\n    var_0.append(1)\n    if num == 1:\n        return var_0\n    var_0.append(num)\n    for var_1 in range(2, int(sqrt(num)) + 1):\n        if num % var_1 == 0:\n            var_0.append(var_1)\n            var_2 = num // var_1\n            if var_2 != var_1:\n                var_0.append(var_2)\n    var_0.sort()\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "236",
    "filename": "program_236.py",
    "code": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    var_0 = {}\n    for var_1 in words:\n        var_2 = var_0\n        for var_3 in var_1:\n            if var_3 not in var_2:\n                var_2[var_3] = {}\n            var_2 = var_2[var_3]\n        var_2['#'] = '#'\n    var_4 = set()\n    var_5 = [[False] * len(board[0]) for var_6 in range(len(board))]\n    for var_7 in range(len(board)):\n        for var_8 in range(len(board[0])):\n            backtrack(board, var_7, var_8, var_0, '', var_5, var_4)\n    return list(var_4)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "237",
    "filename": "program_237.py",
    "code": "def _integ(img, r, c, rl, cl):\n    \"\"\"Integrate over the 2D integral image in the given window.\n\n    This method was created so that `hessian_det_appx` does not have to make\n    a Python call.\n\n    Parameters\n    ----------\n    img : array\n        The integral image over which to integrate.\n    r : int\n        The row number of the top left corner.\n    c : int\n        The column number of the top left corner.\n    rl : int\n        The number of rows over which to integrate.\n    cl : int\n        The number of columns over which to integrate.\n\n    Returns\n    -------\n    ans : int\n        The integral over the given window.\n    \"\"\"\n    var_0 = _clip(var_0, 0, img.shape[0] - 1)\n    var_1 = _clip(var_1, 0, img.shape[1] - 1)\n    var_2 = _clip(var_0 + rl, 0, img.shape[0] - 1)\n    var_3 = _clip(var_1 + cl, 0, img.shape[1] - 1)\n    var_4 = img[var_0, var_1] + img[var_2, var_3] - img[var_0, var_3] - img[var_2, var_1]\n    return max(0.0, var_4)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "238",
    "filename": "program_238.py",
    "code": "def multiple_to_single(L):\n    var_0 = int(''.join(map(str, L)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "239",
    "filename": "program_239.py",
    "code": "def word_len(s):\n    var_0 = var_0.split(' ')\n    for var_1 in var_0:\n        if len(var_1) % 2 == 0:\n            return True\n        else:\n            return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "240",
    "filename": "program_240.py",
    "code": "def find(n, m):\n    var_0 = n // m\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "241",
    "filename": "program_241.py",
    "code": "def present_value(discount_rate: float, cash_flows: list[float]) -> float:\n    \"\"\"\n    >>> present_value(0.13, [10, 20.70, -293, 297])\n    4.69\n    >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])\n    -42739.63\n    >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])\n    175519.15\n    >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])\n    Traceback (most recent call last):\n        ...\n    ValueError: Discount rate cannot be negative\n    >>> present_value(0.03, [])\n    Traceback (most recent call last):\n        ...\n    ValueError: Cash flows list cannot be empty\n    \"\"\"\n    if discount_rate < 0:\n        raise ValueError('Discount rate cannot be negative')\n    if not cash_flows:\n        raise ValueError('Cash flows list cannot be empty')\n    var_0 = sum((cash_flow / (1 + discount_rate) ** i for var_1, var_2 in enumerate(cash_flows)))\n    return round(var_0, ndigits=2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "242",
    "filename": "program_242.py",
    "code": "def check_Equality(str):\n    if str[0] == str[-1]:\n        return 'Equal'\n    else:\n        return 'Not Equal'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "243",
    "filename": "program_243.py",
    "code": "import sys\n\ndef tuple_size(tuple_list):\n    return sys.getsizeof(tuple_list)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "244",
    "filename": "program_244.py",
    "code": "def object_distance(focal_length_of_lens: float, image_distance_from_lens: float) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(object_distance(10,40), -13.333333333333332)\n    True\n\n    >>> from math import isclose\n    >>> isclose(object_distance(6.2,1.5), 1.9787234042553192)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if image_distance_from_lens == 0 or focal_length_of_lens == 0:\n        raise ValueError('Invalid inputs. Enter non zero values with respect to the sign convention.')\n    var_0 = 1 / (1 / image_distance_from_lens - 1 / focal_length_of_lens)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "245",
    "filename": "program_245.py",
    "code": "def max_sub_array_sum_repeated(a, n, k):\n    var_0 = -2147483648\n    var_1 = 0\n    for var_2 in range(n * k):\n        var_1 = var_1 + a[var_2 % n]\n        if var_0 < var_1:\n            var_0 = var_1\n        if var_1 < 0:\n            var_1 = 0\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "246",
    "filename": "program_246.py",
    "code": "def count_Squares(m, n):\n    if n < m:\n        var_0 = m\n        var_1 = n\n        var_2 = var_0\n    return var_2 * (var_2 + 1) * (3 * var_1 - var_2 + 1) // 6",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "247",
    "filename": "program_247.py",
    "code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    var_0 = [0] * N\n    var_0[0] = 0\n    for var_1 in range(1, N):\n        var_0[var_1] = var_0[var_1 - 1]\n        if arr[var_1] - arr[var_1 - 1] < K:\n            if var_1 >= 2:\n                var_0[var_1] = max(var_0[var_1], var_0[var_1 - 2] + arr[var_1] + arr[var_1 - 1])\n            else:\n                var_0[var_1] = max(var_0[var_1], arr[var_1] + arr[var_1 - 1])\n    return var_0[N - 1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "248",
    "filename": "program_248.py",
    "code": "def remove_empty(list1):\n    var_0 = [x for var_1 in list1 if var_1]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "249",
    "filename": "program_249.py",
    "code": "def char_frequency(str1):\n    var_0 = {}\n    for var_1 in str1:\n        var_2 = var_0.keys()\n        if var_1 in var_2:\n            var_0[var_1] += 1\n        else:\n            var_0[var_1] = 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "250",
    "filename": "program_250.py",
    "code": "def first_Factorial_Divisible_Number(x):\n    var_0 = 1\n    var_1 = 1\n    for var_0 in range(1, x):\n        var_1 = var_1 * var_0\n        if var_1 % x == 0:\n            break\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "251",
    "filename": "program_251.py",
    "code": "def armstrong_number(number):\n    var_0 = 0\n    var_1 = 0\n    var_2 = number\n    while var_2 > 0:\n        var_1 = var_1 + 1\n        var_2 = var_2 // 10\n    var_2 = number\n    while var_2 > 0:\n        var_3 = var_2 % 10\n        var_0 = var_0 + var_3 ** var_1\n        var_2 //= 10\n    if number == var_0:\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "252",
    "filename": "program_252.py",
    "code": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    return 1 << n - 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "253",
    "filename": "program_253.py",
    "code": "def find_k_product(test_list, K):\n    var_0 = get_product([sub[K] for var_1 in test_list])\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "254",
    "filename": "program_254.py",
    "code": "def tuple_to_int(nums):\n    var_0 = int(''.join(map(str, nums)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "255",
    "filename": "program_255.py",
    "code": "def _has_ajaxcrawlable_meta(text: str) -> bool:\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    if 'fragment' not in text:\n        return False\n    if 'content' not in text:\n        return False\n    var_0 = html.remove_tags_with_content(var_0, ('script', 'noscript'))\n    var_0 = html.replace_entities(var_0)\n    var_0 = html.remove_comments(var_0)\n    return _ajax_crawlable_re.search(var_0) is not None",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "256",
    "filename": "program_256.py",
    "code": "def tree_broadcast_time(G, node=None):\n    \"\"\"Return the minimum broadcast time of a (node in a) tree.\n\n    The minimum broadcast time of a node is defined as the minimum amount\n    of time required to complete broadcasting starting from that node.\n    The broadcast time of a graph is the maximum over\n    all nodes of the minimum broadcast time from that node [1]_.\n    This function returns the minimum broadcast time of `node`.\n    If `node` is `None`, the broadcast time for the graph is returned.\n\n    Parameters\n    ----------\n    G : Graph\n        The graph should be an undirected tree.\n\n    node : node, optional (default=None)\n        Starting node for the broadcasting. If `None`, the algorithm\n        returns the broadcast time of the graph instead.\n\n    Returns\n    -------\n    int\n        Minimum broadcast time of `node` in `G`, or broadcast time of `G`\n        if no node is provided.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is directed or is a multigraph.\n\n    NodeNotFound\n        If `node` is not a node in `G`.\n\n    NotATree\n        If `G` is not a tree.\n\n    References\n    ----------\n    .. [1] Harutyunyan, H. A. and Li, Z.\n        \"A Simple Construction of Broadcast Graphs.\"\n        In Computing and Combinatorics. COCOON 2019\n        (Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019.\n    \"\"\"\n    if node is not None and node not in G:\n        var_0 = f'node {node} not in G'\n        raise nx.NodeNotFound(var_0)\n    var_1, var_2 = tree_broadcast_center(G)\n    if node is None:\n        return var_1 + sum((1 for var_3 in nx.bfs_layers(G, var_2))) - 1\n    return var_1 + next((d for var_4, var_5 in enumerate(nx.bfs_layers(G, var_2)) if node in var_5))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "257",
    "filename": "program_257.py",
    "code": "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    return [list(group) for var_0, var_1 in groupby(list1)]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "258",
    "filename": "program_258.py",
    "code": "def tuple_modulo(test_tup1, test_tup2):\n    var_0 = tuple((ele1 % ele2 for var_1, var_2 in zip(test_tup1, test_tup2)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "259",
    "filename": "program_259.py",
    "code": "def re_arrange_array(arr, n):\n    var_0 = 0\n    for var_1 in range(0, n):\n        if arr[var_1] < 0:\n            var_2 = arr[var_1]\n            arr[var_1] = arr[var_0]\n            arr[var_0] = var_2\n            var_0 = var_0 + 1\n    return arr",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "260",
    "filename": "program_260.py",
    "code": "def int_to_bytes_little_endian(num):\n    var_0 = []\n    while num > 0:\n        var_0.append(num & 255)\n        var_1 >>= 8\n    return bytes(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "261",
    "filename": "program_261.py",
    "code": "def get_total_number_of_sequences(m, n):\n    var_0 = [[0 for var_1 in range(n + 1)] for var_1 in range(m + 1)]\n    for var_1 in range(m + 1):\n        for var_2 in range(n + 1):\n            if var_1 == 0 or var_2 == 0:\n                var_0[var_1][var_2] = 0\n            elif var_1 < var_2:\n                var_0[var_1][var_2] = 0\n            elif var_2 == 1:\n                var_0[var_1][var_2] = var_1\n            else:\n                var_0[var_1][var_2] = var_0[var_1 - 1][var_2] + var_0[var_1 // 2][var_2 - 1]\n    return var_0[m][n]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "262",
    "filename": "program_262.py",
    "code": "import re\n\ndef remove_char(S):\n    var_0 = re.sub('[\\\\W_]+', '', S)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "263",
    "filename": "program_263.py",
    "code": "def add_tuple(test_list, test_tup):\n    var_0 += test_tup\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "264",
    "filename": "program_264.py",
    "code": "from operator import itemgetter\n\ndef index_minimum(test_list):\n    var_0 = min(test_list, key=itemgetter(1))[0]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "265",
    "filename": "program_265.py",
    "code": "def extract_string(str, l):\n    var_0 = [e for var_1 in str if len(var_1) == l]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "266",
    "filename": "program_266.py",
    "code": "def minimum_Length(s):\n    var_0 = 0\n    var_1 = len(s)\n    var_2 = [0] * 26\n    for var_3 in range(var_1):\n        var_2[ord(s[var_3]) - ord('a')] += 1\n    for var_3 in range(26):\n        if var_2[var_3] > var_0:\n            var_0 = var_2[var_3]\n    return var_1 - var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "267",
    "filename": "program_267.py",
    "code": "def count_char_position(str1):\n    var_0 = 0\n    for var_1 in range(len(str1)):\n        if var_1 == ord(str1[var_1]) - ord('A') or var_1 == ord(str1[var_1]) - ord('a'):\n            var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "268",
    "filename": "program_268.py",
    "code": "def are_Rotations(string1, string2):\n    var_0 = len(string1)\n    var_1 = len(string2)\n    var_2 = ''\n    if var_0 != var_1:\n        return False\n    var_2 = string1 + string1\n    if var_2.count(string2) > 0:\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "269",
    "filename": "program_269.py",
    "code": "from collections import deque\n\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    var_0 = deque()\n    for var_1 in exp:\n        if var_1 == '(' or var_1 == '{' or var_1 == '[':\n            var_0.append(var_1)\n        if var_1 == ')' or var_1 == '}' or var_1 == ']':\n            if not var_0:\n                return False\n            var_2 = var_0.pop()\n            if var_2 == '(' and var_1 != ')' or (var_2 == '{' and var_1 != '}' or (var_2 == '[' and var_1 != ']')):\n                return False\n    return not var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "270",
    "filename": "program_270.py",
    "code": "from collections import Counter\n\ndef most_common_elem(s, a):\n    var_0 = Counter(s).most_common(a)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "271",
    "filename": "program_271.py",
    "code": "def sum_Even(l, r):\n    return sum_Natural(int(r / 2)) - sum_Natural(int((l - 1) / 2))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "272",
    "filename": "program_272.py",
    "code": "def even_Power_Sum(n):\n    var_0 = 0\n    for var_1 in range(1, n + 1):\n        var_2 = 2 * var_1\n        var_0 = var_0 + var_2 * var_2 * var_2 * var_2 * var_2\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "273",
    "filename": "program_273.py",
    "code": "def rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:\n    \"\"\"\n    Conversion from the RGB-representation to the HSV-representation.\n    The tested values are the reverse values from the hsv_to_rgb-doctests.\n    Function \"approximately_equal_hsv\" is needed because of small deviations due to\n    rounding for the RGB-values.\n\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\n    True\n    \"\"\"\n    if red < 0 or red > 255:\n        raise Exception('red should be between 0 and 255')\n    if green < 0 or green > 255:\n        raise Exception('green should be between 0 and 255')\n    if blue < 0 or blue > 255:\n        raise Exception('blue should be between 0 and 255')\n    var_0 = red / 255\n    var_1 = green / 255\n    var_2 = blue / 255\n    var_3 = max(var_0, var_1, var_2)\n    var_4 = var_3 - min(var_0, var_1, var_2)\n    var_5 = 0 if var_3 == 0 else var_4 / var_3\n    if var_4 == 0:\n        var_6 = 0.0\n    elif var_3 == var_0:\n        var_6 = 60 * (0 + (var_1 - var_2) / var_4)\n    elif var_3 == var_1:\n        var_6 = 60 * (2 + (var_2 - var_0) / var_4)\n    else:\n        var_6 = 60 * (4 + (var_0 - var_1) / var_4)\n    var_6 = (var_6 + 360) % 360\n    return [var_6, var_5, var_3]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "274",
    "filename": "program_274.py",
    "code": "def count_no_of_ways(n, k):\n    var_0 = [0] * (n + 1)\n    var_1 = k\n    var_2 = 1000000007\n    var_0[1] = k\n    var_0[2] = k * k\n    for var_3 in range(3, n + 1):\n        var_0[var_3] = (k - 1) * (var_0[var_3 - 1] + var_0[var_3 - 2]) % var_2\n    return var_0[n]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "275",
    "filename": "program_275.py",
    "code": "def first_Repeated_Char(str):\n    var_0 = {}\n    for var_1 in str:\n        if var_1 in var_0:\n            return var_1\n        else:\n            var_0[var_1] = 0\n    return '\\x00'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "276",
    "filename": "program_276.py",
    "code": "import re\n\ndef text_match_word(text):\n    var_0 = '\\\\w+\\\\S*$'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "277",
    "filename": "program_277.py",
    "code": "def median_numbers(a, b, c):\n    if a > b:\n        if a < c:\n            var_0 = a\n        elif b > c:\n            var_0 = b\n        else:\n            var_0 = c\n    elif a > c:\n        var_0 = a\n    elif b < c:\n        var_0 = b\n    else:\n        var_0 = c\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "278",
    "filename": "program_278.py",
    "code": "def _symbol_of(arg):\n    if isinstance(arg, Declaration):\n        var_0 = var_0.variable.symbol\n    elif isinstance(var_0, Variable):\n        var_0 = var_0.symbol\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "279",
    "filename": "program_279.py",
    "code": "from itertools import groupby\n\ndef group_element(test_list):\n    var_0 = dict()\n    for var_1, var_2 in groupby(sorted(test_list, key=lambda ele: ele[1]), key=lambda ele: ele[1]):\n        var_0[var_1] = [ele[0] for var_3 in var_2]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "280",
    "filename": "program_280.py",
    "code": "def moddiv_list(nums1, nums2):\n    var_0 = map(lambda x, y: x % y, nums1, nums2)\n    return list(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "281",
    "filename": "program_281.py",
    "code": "def find_lcm(num1, num2):\n    if num1 > num2:\n        var_0 = num1\n        var_1 = num2\n    else:\n        var_0 = num2\n        var_1 = num1\n    var_2 = var_0 % var_1\n    while var_2 != 0:\n        var_0 = var_1\n        var_1 = var_2\n        var_2 = var_0 % var_1\n    var_3 = var_1\n    var_4 = int(int(num1 * num2) / int(var_3))\n    return var_4",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "282",
    "filename": "program_282.py",
    "code": "import math as mt\n\ndef get_Position(a, n, m):\n    for var_0 in range(n):\n        a[var_0] = a[var_0] // m + (a[var_0] % m != 0)\n    var_1, var_2 = (-1, -1)\n    for var_0 in range(n - 1, -1, -1):\n        if var_2 < a[var_0]:\n            var_2 = a[var_0]\n            var_1 = var_0\n    return var_1 + 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "283",
    "filename": "program_283.py",
    "code": "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "284",
    "filename": "program_284.py",
    "code": "def generate_parenthesis_v2(n):\n\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n        if left > 0:\n            add_pair(res, s + '(', left - 1, right)\n        if right > 0 and left < right:\n            add_pair(res, s + ')', left, right - 1)\n    var_0 = []\n    add_pair(var_0, '', n, n)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "285",
    "filename": "program_285.py",
    "code": "def Odd_Length_Sum(arr):\n    var_0 = 0\n    var_1 = len(arr)\n    for var_2 in range(var_1):\n        var_0 += ((var_2 + 1) * (var_1 - var_2) + 1) // 2 * arr[var_2]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "286",
    "filename": "program_286.py",
    "code": "def position_min(list1):\n    var_0 = min(list1)\n    var_1 = [i for var_2, var_3 in enumerate(list1) if var_3 == var_0]\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "287",
    "filename": "program_287.py",
    "code": "def super_seq(X, Y, m, n):\n    if not m:\n        return n\n    if not n:\n        return m\n    if X[m - 1] == Y[n - 1]:\n        return 1 + super_seq(X, Y, m - 1, n - 1)\n    return 1 + min(super_seq(X, Y, m - 1, n), super_seq(X, Y, m, n - 1))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "288",
    "filename": "program_288.py",
    "code": "def bin_to_hexadecimal(binary_str: str) -> str:\n    \"\"\"\n    Converting a binary string into hexadecimal using Grouping Method\n\n    >>> bin_to_hexadecimal('101011111')\n    '0x15f'\n    >>> bin_to_hexadecimal(' 1010   ')\n    '0x0a'\n    >>> bin_to_hexadecimal('-11101')\n    '-0x1d'\n    >>> bin_to_hexadecimal('a')\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_hexadecimal('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    var_0 = str(var_0).strip()\n    if not var_0:\n        raise ValueError('Empty string was passed to the function')\n    var_1 = var_0[0] == '-'\n    var_0 = var_0[1:] if var_1 else var_0\n    if not all((char in '01' for var_2 in var_0)):\n        raise ValueError('Non-binary value was passed to the function')\n    var_0 = '0' * (4 * (divmod(len(var_0), 4)[0] + 1) - len(var_0)) + var_0\n    var_3 = []\n    for var_4 in range(0, len(var_0), 4):\n        var_3.append(BITS_TO_HEX[var_0[var_4:var_4 + 4]])\n    var_5 = '0x' + ''.join(var_3)\n    return '-' + var_5 if var_1 else var_5",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "289",
    "filename": "program_289.py",
    "code": "def clear_lru_caches() -> None:\n    \"\"\"Clear caches holding references to AST nodes.\"\"\"\n    var_0: list[_lru_cache_wrapper[Any]] = [class_is_abstract, in_for_else_branch, infer_all, is_overload_stub, overridden_method, unimplemented_abstract_methods, safe_infer, _similar_names]\n    for var_1 in var_0:\n        var_1.cache_clear()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "290",
    "filename": "program_290.py",
    "code": "def merge_dict(d1, d2):\n    var_0 = d1.copy()\n    var_0.update(d2)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "291",
    "filename": "program_291.py",
    "code": "from collections import Counter\n\ndef sort_counter(dict1):\n    var_0 = Counter(dict1)\n    var_1 = var_0.most_common()\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "292",
    "filename": "program_292.py",
    "code": "import re\n\ndef text_match(text):\n    var_0 = 'ab*?'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "293",
    "filename": "program_293.py",
    "code": "def stable_matching(donor_pref: list[list[int]], recipient_pref: list[list[int]]) -> list[int]:\n    \"\"\"\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\n    prefer each other over their partner.  The function accepts the preferences of\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\n    returns a list where the index position corresponds to the donor and value at the\n    index is the organ recipient.\n\n    To better understand the algorithm, see also:\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n    >>> stable_matching(donor_pref, recipient_pref)\n    [1, 2, 3, 0]\n    \"\"\"\n    assert len(donor_pref) == len(recipient_pref)\n    var_0 = len(donor_pref)\n    var_1 = list(range(var_0))\n    var_2 = [-1] * var_0\n    var_3 = [-1] * var_0\n    var_4 = [0] * var_0\n    while var_1:\n        var_5 = var_1[0]\n        var_6 = donor_pref[var_5]\n        var_7 = var_6[var_4[var_5]]\n        var_4[var_5] += 1\n        var_8 = recipient_pref[var_7]\n        var_9 = var_3[var_7]\n        if var_9 != -1:\n            if var_8.index(var_9) > var_8.index(var_5):\n                var_3[var_7] = var_5\n                var_2[var_5] = var_7\n                var_1.append(var_9)\n                var_1.remove(var_5)\n        else:\n            var_3[var_7] = var_5\n            var_2[var_5] = var_7\n            var_1.remove(var_5)\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "294",
    "filename": "program_294.py",
    "code": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    var_0 = len(matrix)\n    if not var_0:\n        return []\n    var_1 = len(matrix[0])\n    if not var_1:\n        return []\n    var_2 = []\n    var_3 = [[False for var_4 in range(var_0)] for var_4 in range(var_1)]\n    var_5 = [[False for var_4 in range(var_0)] for var_4 in range(var_1)]\n    for var_6 in range(var_0):\n        dfs(var_5, matrix, float('-inf'), var_6, 0)\n        dfs(var_3, matrix, float('-inf'), var_6, var_1 - 1)\n    for var_6 in range(var_1):\n        dfs(var_5, matrix, float('-inf'), 0, var_6)\n        dfs(var_3, matrix, float('-inf'), var_0 - 1, var_6)\n    for var_6 in range(var_0):\n        for var_7 in range(var_1):\n            if var_5[var_6][var_7] and var_3[var_6][var_7]:\n                var_2.append([var_6, var_7])\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "295",
    "filename": "program_295.py",
    "code": "def sizeof(arg):\n    \"\"\" Generate of FunctionCall instance for calling 'sizeof'\n\n    Examples\n    ========\n\n    >>> from sympy.codegen.ast import real\n    >>> from sympy.codegen.cnodes import sizeof\n    >>> from sympy import ccode\n    >>> ccode(sizeof(real))\n    'sizeof(double)'\n    \"\"\"\n    return FunctionCall('sizeof', [String(arg) if isinstance(arg, str) else arg])",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "296",
    "filename": "program_296.py",
    "code": "def neg_nos(list1):\n    for var_0 in list1:\n        if var_0 < 0:\n            return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "297",
    "filename": "program_297.py",
    "code": "from array import array\n\ndef negative_count(nums):\n    var_0 = len(nums)\n    var_1 = 0\n    for var_2 in nums:\n        if var_2 < 0:\n            var_1 += 1\n        else:\n            None\n    return round(var_1 / var_0, 2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "298",
    "filename": "program_298.py",
    "code": "def tuple_int_str(tuple_str):\n    var_0 = tuple(((int(x[0]), int(x[1])) for var_1 in tuple_str))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "299",
    "filename": "program_299.py",
    "code": "def _base10_to_85(d: int) -> str:\n    return ''.join(chr(d % 85 + 33)) + _base10_to_85(d // 85) if d > 0 else ''",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "300",
    "filename": "program_300.py",
    "code": "def find_measurable_comparisons(fgraph: FunctionGraph, node: Apply) -> list[TensorVariable] | None:\n    var_0 = filter_measurable_variables(node.inputs)\n    if len(var_0) != 1:\n        return None\n    [var_1] = var_0\n    var_2 = node.inputs.index(var_1)\n    if var_1.type.broadcastable != node.outputs[0].type.broadcastable:\n        return None\n    var_3 = cast(TensorVariable, node.inputs[(var_2 + 1) % 2])\n    if check_potential_measurability([var_3]):\n        return None\n    var_4 = node.op.scalar_op\n    if var_2 == 1:\n        if isinstance(var_4, LT):\n            var_4 = GT()\n        elif isinstance(var_4, GT):\n            var_4 = LT()\n        elif isinstance(var_4, GE):\n            var_4 = LE()\n        elif isinstance(var_4, LE):\n            var_4 = GE()\n    var_5 = MeasurableComparison(var_4)\n    var_6 = var_5.make_node(var_1, var_3).default_output()\n    return [var_6]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "301",
    "filename": "program_301.py",
    "code": "def min_distance_up_bottom(word1: str, word2: str) -> int:\n    \"\"\"\n    >>> min_distance_up_bottom(\"intention\", \"execution\")\n    5\n    >>> min_distance_up_bottom(\"intention\", \"\")\n    9\n    >>> min_distance_up_bottom(\"\", \"\")\n    0\n    >>> min_distance_up_bottom(\"zooicoarchaeologist\", \"zoologist\")\n    10\n    \"\"\"\n    var_0 = len(word1)\n    var_1 = len(word2)\n\n    @functools.cache\n    def min_distance(index1: int, index2: int) -> int:\n        if index1 >= var_0:\n            return var_1 - index2\n        if index2 >= var_1:\n            return var_0 - index1\n        var_2 = int(word1[index1] != word2[index2])\n        return min(1 + min_distance(index1 + 1, index2), 1 + min_distance(index1, index2 + 1), var_2 + min_distance(index1 + 1, index2 + 1))\n    return min_distance(0, 0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "302",
    "filename": "program_302.py",
    "code": "def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    var_0, var_1 = (len(grid), len(grid[0]))\n    if min(row, col) < 0 or row == var_0 or col == var_1 or ((row, col) in visit) or (grid[row][col] == 1):\n        return 0\n    if row == var_0 - 1 and col == var_1 - 1:\n        return 1\n    visit.add((row, col))\n    var_2 = 0\n    var_2 += depth_first_search(grid, row + 1, col, visit)\n    var_2 += depth_first_search(grid, row - 1, col, visit)\n    var_2 += depth_first_search(grid, row, col + 1, visit)\n    var_2 += depth_first_search(grid, row, col - 1, visit)\n    visit.remove((row, col))\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "303",
    "filename": "program_303.py",
    "code": "def merge(a, b):\n    var_0 = []\n    while len(a) != 0 and len(b) != 0:\n        if a[0] < b[0]:\n            var_0.append(a[0])\n            a.remove(a[0])\n        else:\n            var_0.append(b[0])\n            b.remove(b[0])\n    if len(a) == 0:\n        var_0 += b\n    else:\n        var_0 += a\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "304",
    "filename": "program_304.py",
    "code": "def remove_datatype(test_tuple, data_type):\n    var_0 = []\n    for var_1 in test_tuple:\n        if not isinstance(var_1, data_type):\n            var_0.append(var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "305",
    "filename": "program_305.py",
    "code": "def relative_import(parent_name, rel_modules=(), rel_classes=()):\n    \"\"\"\n    Helper function to import submodules lazily in Python 3.7+\n\n    Parameters\n    ----------\n    rel_modules: list of str\n        list of submodules to import, of the form .submodule\n    rel_classes: list of str\n        list of submodule classes/variables to import, of the form ._submodule.Foo\n\n    Returns\n    -------\n    tuple\n        Tuple that should be assigned to __all__, __getattr__ in the caller\n    \"\"\"\n    var_0 = {rel_module.split('.')[-1]: rel_module for var_1 in rel_modules}\n    var_2 = {rel_path.split('.')[-1]: rel_path for var_3 in rel_classes}\n\n    def __getattr__(import_name):\n        if import_name in var_0:\n            var_4 = var_0[import_name]\n            return importlib.import_module(var_4, parent_name)\n        if import_name in var_2:\n            var_5 = var_2[import_name].split('.')\n            var_1 = '.'.join(var_5[:-1])\n            var_6 = import_name\n            var_7 = importlib.import_module(var_1, parent_name)\n            return getattr(var_7, var_6)\n        raise AttributeError('module {__name__!r} has no attribute {name!r}'.format(name=import_name, __name__=parent_name))\n    var_8 = list(var_0) + list(var_2)\n\n    def __dir__():\n        return var_8\n    return (var_8, __getattr__, __dir__)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "306",
    "filename": "program_306.py",
    "code": "def slope(x1, y1, x2, y2):\n    return float(y2 - y1) / (x2 - x1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "307",
    "filename": "program_307.py",
    "code": "def common_prefix_util(str1, str2):\n    var_0 = ''\n    var_1 = len(str1)\n    var_2 = len(str2)\n    var_3 = 0\n    var_4 = 0\n    while var_3 <= var_1 - 1 and var_4 <= var_2 - 1:\n        if str1[var_3] != str2[var_4]:\n            break\n        var_0 += str1[var_3]\n        var_3 += 1\n        var_4 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "308",
    "filename": "program_308.py",
    "code": "def extract_index_list(l1, l2, l3):\n    var_0 = []\n    for var_1, var_2, var_3 in zip(l1, l2, l3):\n        if var_1 == var_2 == var_3:\n            var_0.append(var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "309",
    "filename": "program_309.py",
    "code": "def is_lower(string):\n    return string.lower()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "310",
    "filename": "program_310.py",
    "code": "def maze_search(maze):\n    var_0, var_1 = (0, 1)\n    var_2, var_3 = (0, 1)\n    var_4, var_5 = (0, 0)\n    if maze[var_4][var_5] == var_0:\n        return -1\n    var_6 = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    var_7, var_8 = (len(maze), len(maze[0]))\n    var_9, var_10 = (var_7 - 1, var_8 - 1)\n    var_11 = deque([(var_4, var_5, 0)])\n    var_12 = [[var_2 for var_13 in range(var_8)] for var_14 in range(var_7)]\n    var_12[var_4][var_5] = var_3\n    while var_11:\n        var_15, var_16, var_17 = var_11.popleft()\n        if var_15 == var_9 and var_16 == var_10:\n            return var_17\n        for var_18, var_19 in var_6:\n            var_20 = var_15 + var_18\n            var_21 = var_16 + var_19\n            if not (0 <= var_20 < var_7 and 0 <= var_21 < var_8):\n                continue\n            if maze[var_20][var_21] == var_1 and var_12[var_20][var_21] == var_2:\n                var_11.append((var_20, var_21, var_17 + 1))\n                var_12[var_20][var_21] = var_3\n    return -1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "311",
    "filename": "program_311.py",
    "code": "def find_substring(str1, sub_str):\n    if any((sub_str in s for var_0 in str1)):\n        return True\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "312",
    "filename": "program_312.py",
    "code": "import re\n\ndef remove_all_spaces(text):\n    return re.sub('\\\\s+', '', text)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "313",
    "filename": "program_313.py",
    "code": "def removals(arr, n, k):\n    var_0 = n - 1\n    arr.sort()\n    for var_1 in range(0, n):\n        var_2 = find_ind(arr[var_1], var_1, n, k, arr)\n        if var_2 != -1:\n            var_0 = min(var_0, n - (var_2 - var_1 + 1))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "314",
    "filename": "program_314.py",
    "code": "import re\n\ndef text_match_wordz_middle(text):\n    var_0 = '\\\\Bz\\\\B'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "315",
    "filename": "program_315.py",
    "code": "def prime_num(num):\n    if num >= 1:\n        for var_0 in range(2, num // 2):\n            if num % var_0 == 0:\n                return False\n            else:\n                return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "316",
    "filename": "program_316.py",
    "code": "def is_undulating(n):\n    if len(n) <= 2:\n        return False\n    for var_0 in range(2, len(n)):\n        if n[var_0 - 2] != n[var_0]:\n            return False\n    return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "317",
    "filename": "program_317.py",
    "code": "def check_Validity(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    else:\n        return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "318",
    "filename": "program_318.py",
    "code": "def return_sum(dict):\n    var_0 = 0\n    for var_1 in dict.values():\n        var_0 = var_0 + var_1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "319",
    "filename": "program_319.py",
    "code": "def random_pivot(lst):\n    \"\"\"\n    Choose a random pivot for the list.\n    We can use a more sophisticated algorithm here, such as the median-of-medians\n    algorithm.\n    \"\"\"\n    return choice(lst)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "320",
    "filename": "program_320.py",
    "code": "def sort_sublists(list1):\n    list1.sort()\n    list1.sort(key=len)\n    return list1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "321",
    "filename": "program_321.py",
    "code": "def fibonacci(n):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "322",
    "filename": "program_322.py",
    "code": "def sort_groups(groups):\n    return sorted(groups, key=lambda g: (g.depth, g.priority, g.name))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "323",
    "filename": "program_323.py",
    "code": "def encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not input:\n        return ''\n    var_0 = ''\n    var_1 = ''\n    var_2 = 1\n    for var_3 in input:\n        if var_3 != var_1:\n            if var_1:\n                var_0 += str(var_2) + var_1\n            var_2 = 1\n            var_1 = var_3\n        else:\n            var_2 += 1\n    else:\n        return var_0 + (str(var_2) + var_1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "324",
    "filename": "program_324.py",
    "code": "def count_Rectangles(radius):\n    var_0 = 0\n    var_1 = 2 * radius\n    var_2 = var_1 * var_1\n    for var_3 in range(1, 2 * radius):\n        for var_4 in range(1, 2 * radius):\n            var_5 = var_3 * var_3 + var_4 * var_4\n            if var_5 <= var_2:\n                var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "325",
    "filename": "program_325.py",
    "code": "def breakSum(n):\n    var_0 = [0] * (n + 1)\n    var_0[0] = 0\n    var_0[1] = 1\n    for var_1 in range(2, n + 1):\n        var_0[var_1] = max(var_0[int(var_1 / 2)] + var_0[int(var_1 / 3)] + var_0[int(var_1 / 4)], var_1)\n    return var_0[n]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "326",
    "filename": "program_326.py",
    "code": "def decimal_to_any(num: int, base: int) -> str:\n    \"\"\"\n    Convert a positive integer to another base as str.\n    >>> decimal_to_any(0, 2)\n    '0'\n    >>> decimal_to_any(5, 4)\n    '11'\n    >>> decimal_to_any(20, 3)\n    '202'\n    >>> decimal_to_any(58, 16)\n    '3A'\n    >>> decimal_to_any(243, 17)\n    'E5'\n    >>> decimal_to_any(34923, 36)\n    'QY3'\n    >>> decimal_to_any(10, 11)\n    'A'\n    >>> decimal_to_any(16, 16)\n    '10'\n    >>> decimal_to_any(36, 36)\n    '10'\n    >>> # negatives will error\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: parameter must be positive int\n    >>> # floats will error\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: int() can't convert non-string with explicit base\n    >>> # a float base will error\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # a str base will error\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    >>> # a base less than 2 will error\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be >= 2\n    >>> # a base greater than 36 will error\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be <= 36\n    \"\"\"\n    if isinstance(num, float):\n        raise TypeError(\"int() can't convert non-string with explicit base\")\n    if num < 0:\n        raise ValueError('parameter must be positive int')\n    if isinstance(base, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n    if isinstance(base, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if base in (0, 1):\n        raise ValueError('base must be >= 2')\n    if base > 36:\n        raise ValueError('base must be <= 36')\n    var_0 = ''\n    var_1 = 0\n    var_2 = 0\n    while var_2 != 1:\n        var_2, var_1 = divmod(num, base)\n        if base >= 11 and 9 < var_1 < 36:\n            var_3 = ALPHABET_VALUES[str(var_1)]\n        else:\n            var_3 = str(var_1)\n        var_0 += var_3\n        var_2 = num // base\n        var_4 = var_2\n        if var_2 == 0:\n            return str(var_0[::-1])\n        elif var_2 == 1:\n            var_0 += str(var_2)\n            return str(var_0[::-1])\n    return var_0[::-1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "327",
    "filename": "program_327.py",
    "code": "def find_Min_Sum(a, b, n):\n    a.sort()\n    b.sort()\n    var_0 = 0\n    for var_1 in range(n):\n        var_0 = var_0 + abs(a[var_1] - b[var_1])\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "328",
    "filename": "program_328.py",
    "code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    var_0 = len(input_string)\n    var_1 = input_string[::-1]\n    var_2 = len(var_1)\n    var_3 = [[-1] * (var_2 + 1) for var_4 in range(var_0 + 1)]\n    for var_4 in range(var_0 + 1):\n        var_3[var_4][0] = 0\n    for var_4 in range(var_2 + 1):\n        var_3[0][var_4] = 0\n    for var_4 in range(1, var_0 + 1):\n        for var_5 in range(1, var_2 + 1):\n            if input_string[var_4 - 1] == var_1[var_5 - 1]:\n                var_3[var_4][var_5] = 1 + var_3[var_4 - 1][var_5 - 1]\n            else:\n                var_3[var_4][var_5] = max(var_3[var_4 - 1][var_5], var_3[var_4][var_5 - 1])\n    return var_3[var_0][var_2]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "329",
    "filename": "program_329.py",
    "code": "def previous_palindrome(num):\n    for var_0 in range(num - 1, 0, -1):\n        if str(var_0) == str(var_0)[::-1]:\n            return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "330",
    "filename": "program_330.py",
    "code": "def harmonic_sum(n):\n    if n < 2:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "331",
    "filename": "program_331.py",
    "code": "def str_to_tuple(test_str):\n    var_0 = tuple(map(int, test_str.split(', ')))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "332",
    "filename": "program_332.py",
    "code": "import math\n\ndef volume_cone(r, h):\n    var_0 = 1.0 / 3 * math.pi * r * r * h\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "333",
    "filename": "program_333.py",
    "code": "def rotate(vector: np.ndarray, angle_in_degrees: float) -> np.ndarray:\n    \"\"\"\n    Standard rotation of a 2D vector with a rotation matrix\n    (see https://en.wikipedia.org/wiki/Rotation_matrix )\n    >>> rotate(np.array([1, 0]), 60)\n    array([0.5      , 0.8660254])\n    >>> rotate(np.array([1, 0]), 90)\n    array([6.123234e-17, 1.000000e+00])\n    \"\"\"\n    var_0 = np.radians(angle_in_degrees)\n    var_1, var_2 = (np.cos(var_0), np.sin(var_0))\n    var_3 = np.array(((var_1, -var_2), (var_2, var_1)))\n    return np.dot(var_3, vector)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "334",
    "filename": "program_334.py",
    "code": "def num_comm_div(x, y):\n    var_0 = ngcd(x, y)\n    var_1 = 0\n    var_2 = int(var_0 ** 0.5)\n    var_3 = 1\n    while var_3 <= var_2:\n        if var_0 % var_3 == 0:\n            var_1 += 2\n            if var_3 == var_0 / var_3:\n                var_1 -= 1\n        var_3 += 1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "335",
    "filename": "program_335.py",
    "code": "def gcd(p, q):\n    while q != 0:\n        var_0, var_1 = (var_1, var_0 % var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "336",
    "filename": "program_336.py",
    "code": "def palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not s:\n        yield []\n        return\n    for var_0 in range(len(s), 0, -1):\n        var_1 = s[:var_0]\n        if var_1 == var_1[::-1]:\n            for var_2 in palindromic_substrings_iter(s[var_0:]):\n                yield ([var_1] + var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "337",
    "filename": "program_337.py",
    "code": "def decimal_to_hexadecimal(decimal: float) -> str:\n    \"\"\"\n    take integer decimal value, return hexadecimal representation as str beginning\n    with 0x\n    >>> decimal_to_hexadecimal(5)\n    '0x5'\n    >>> decimal_to_hexadecimal(15)\n    '0xf'\n    >>> decimal_to_hexadecimal(37)\n    '0x25'\n    >>> decimal_to_hexadecimal(255)\n    '0xff'\n    >>> decimal_to_hexadecimal(4096)\n    '0x1000'\n    >>> decimal_to_hexadecimal(999098)\n    '0xf3eba'\n    >>> # negatives work too\n    >>> decimal_to_hexadecimal(-256)\n    '-0x100'\n    >>> # floats are acceptable if equivalent to an int\n    >>> decimal_to_hexadecimal(17.0)\n    '0x11'\n    >>> # other floats will error\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # strings will error as well\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # results are the same when compared to Python's default hex function\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\n    True\n    \"\"\"\n    assert isinstance(decimal, (int, float))\n    assert decimal == int(decimal)\n    var_0 = int(var_0)\n    var_1 = ''\n    var_2 = False\n    if var_0 < 0:\n        var_2 = True\n        var_0 *= -1\n    while var_0 > 0:\n        var_0, var_3 = divmod(var_0, 16)\n        var_1 = values[var_3] + var_1\n    var_1 = '0x' + var_1\n    if var_2:\n        var_1 = '-' + var_1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "338",
    "filename": "program_338.py",
    "code": "def replace_char(str1, ch, newch):\n    var_0 = str1.replace(ch, newch)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "339",
    "filename": "program_339.py",
    "code": "def find_path(maze):\n    var_0 = dfs(maze, 0, 0, 0, -1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "340",
    "filename": "program_340.py",
    "code": "import heapq as hq\n\ndef raw_heap(rawheap):\n    hq.heapify(rawheap)\n    return rawheap",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "341",
    "filename": "program_341.py",
    "code": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    var_0 = nums[0]\n    var_1 = 0\n    for var_2 in nums[1:]:\n        var_0, var_1 = (var_1 + var_2, max(var_0, var_1))\n    return max(var_1, var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "342",
    "filename": "program_342.py",
    "code": "import re\n\ndef text_match(text):\n    var_0 = 'a.*?b$'\n    if re.search(var_0, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "343",
    "filename": "program_343.py",
    "code": "def center_of_mass(particles: list[Particle]) -> Coord3D:\n    \"\"\"\n    Input Parameters\n    ----------------\n    particles: list(Particle):\n    A list of particles where each particle is a tuple with it's (x, y, z) position and\n    it's mass.\n\n    Returns\n    -------\n    Coord3D:\n    A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two\n    decimal places.\n\n    Examples\n    --------\n    >>> center_of_mass([\n    ...     Particle(1.5, 4, 3.4, 4),\n    ...     Particle(5, 6.8, 7, 8.1),\n    ...     Particle(9.4, 10.1, 11.6, 12)\n    ... ])\n    Coord3D(x=6.61, y=7.98, z=8.69)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Coord3D(x=6.33, y=7.33, z=8.33)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, -4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 0),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([])\n    Traceback (most recent call last):\n        ...\n    ValueError: No particles provided\n    \"\"\"\n    if not particles:\n        raise ValueError('No particles provided')\n    if any((particle.mass <= 0 for var_0 in particles)):\n        raise ValueError('Mass of all particles must be greater than 0')\n    var_1 = sum((var_0.mass for var_0 in particles))\n    var_2 = round(sum((var_0.x * var_0.mass for var_0 in particles)) / var_1, 2)\n    var_3 = round(sum((var_0.y * var_0.mass for var_0 in particles)) / var_1, 2)\n    var_4 = round(sum((var_0.z * var_0.mass for var_0 in particles)) / var_1, 2)\n    return Coord3D(var_2, var_3, var_4)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "344",
    "filename": "program_344.py",
    "code": "def min_length(list1):\n    var_0 = min((len(x) for var_1 in list1))\n    var_2 = min((var_1 for var_1 in list1))\n    return (var_0, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "345",
    "filename": "program_345.py",
    "code": "def flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for var_0 in iterable:\n        if not isinstance(var_0, str) and isinstance(var_0, Iterable):\n            yield from flatten_iter(var_0)\n        else:\n            yield var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "346",
    "filename": "program_346.py",
    "code": "def filter_oddnumbers(nums):\n    var_0 = list(filter(lambda x: x % 2 != 0, nums))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "347",
    "filename": "program_347.py",
    "code": "def flatten(test_tuple):\n    for var_0 in test_tuple:\n        if isinstance(var_0, tuple):\n            yield from flatten(var_0)\n        else:\n            yield var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "348",
    "filename": "program_348.py",
    "code": "def missing_ranges(arr, lo, hi):\n    var_0 = []\n    var_1 = lo\n    for var_2 in arr:\n        if var_2 == var_1:\n            var_1 += 1\n        elif var_2 > var_1:\n            var_0.append((var_1, var_2 - 1))\n            var_1 = var_2 + 1\n    if var_1 <= hi:\n        var_0.append((var_1, hi))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "349",
    "filename": "program_349.py",
    "code": "def is_Isomorphic(str1, str2):\n    var_0 = {}\n    var_1 = {}\n    for var_2, var_3 in enumerate(str1):\n        var_0[var_3] = var_0.get(var_3, []) + [var_2]\n    for var_4, var_3 in enumerate(str2):\n        var_1[var_3] = var_1.get(var_3, []) + [var_4]\n    if sorted(var_0.values()) == sorted(var_1.values()):\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "350",
    "filename": "program_350.py",
    "code": "def sum_negativenum(nums):\n    var_0 = list(filter(lambda nums: nums < 0, nums))\n    return sum(var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "351",
    "filename": "program_351.py",
    "code": "def lobb_num(n, m):\n    return (2 * m + 1) * binomial_coeff(2 * n, m + n) / (m + n + 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "352",
    "filename": "program_352.py",
    "code": "def remove_even(str1):\n    var_0 = ''\n    for var_1 in range(1, len(str1) + 1):\n        if var_1 % 2 != 0:\n            var_0 = var_0 + str1[var_1 - 1]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "353",
    "filename": "program_353.py",
    "code": "import re\n\ndef match(text):\n    var_0 = '[A-Z]+[a-z]+$'\n    if re.search(var_0, text):\n        return 'Yes'\n    else:\n        return 'No'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "354",
    "filename": "program_354.py",
    "code": "def are_Equal(arr1, arr2, n, m):\n    if n != m:\n        return False\n    arr1.sort()\n    arr2.sort()\n    for var_0 in range(0, n - 1):\n        if arr1[var_0] != arr2[var_0]:\n            return False\n    return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "355",
    "filename": "program_355.py",
    "code": "def count_odd(array_nums):\n    var_0 = len(list(filter(lambda x: x % 2 != 0, array_nums)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "356",
    "filename": "program_356.py",
    "code": "def zip_tuples(test_tup1, test_tup2):\n    var_0 = []\n    for var_1, var_2 in enumerate(test_tup1):\n        var_0.append((var_2, test_tup2[var_1 % len(test_tup2)]))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "357",
    "filename": "program_357.py",
    "code": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([4, 3, 1, 0])\n        2\n        >>> find_missing_number([-4, -3, -1, 0])\n        -2\n        >>> find_missing_number([-2, 2, 1, 3, 0])\n        -1\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    var_0 = min(nums)\n    var_1 = max(nums)\n    var_2 = var_1\n    for var_3 in range(var_0, var_1):\n        var_2 ^= var_3 ^ nums[var_3 - var_0]\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "358",
    "filename": "program_358.py",
    "code": "def check_permutation(str1, str2):\n    var_0 = len(str1)\n    var_1 = len(str2)\n    if var_0 != var_1:\n        return False\n    var_2 = sorted(str1)\n    var_3 = ' '.join(var_2)\n    var_4 = sorted(str2)\n    var_5 = ' '.join(var_4)\n    for var_6 in range(0, var_0, 1):\n        if var_3[var_6] != var_5[var_6]:\n            return False\n    return True",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "359",
    "filename": "program_359.py",
    "code": "def ngcd(x, y):\n    var_0 = 1\n    while var_0 <= x and var_0 <= y:\n        if x % var_0 == 0 and y % var_0 == 0:\n            var_1 = var_0\n        var_0 += 1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "360",
    "filename": "program_360.py",
    "code": "def binomial_probability(n, k, p):\n    return nCr(n, k) * pow(p, k) * pow(1 - p, n - k)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "361",
    "filename": "program_361.py",
    "code": "def remove_replica(test_tup):\n    var_0 = set()\n    var_1 = tuple((ele if ele not in var_0 and (not var_0.add(ele)) else 'MSP' for var_2 in test_tup))\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "362",
    "filename": "program_362.py",
    "code": "def loss_amount(actual_cost, sale_amount):\n    if sale_amount > actual_cost:\n        var_0 = sale_amount - actual_cost\n        return var_0\n    else:\n        return None",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "363",
    "filename": "program_363.py",
    "code": "def real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if not isinstance(power_factor, (int, float)) or power_factor < -1 or power_factor > 1:\n        raise ValueError('power_factor must be a valid float value between -1 and 1.')\n    return apparent_power * power_factor",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "364",
    "filename": "program_364.py",
    "code": "def max_length(list1):\n    var_0 = max((len(x) for var_1 in list1))\n    var_2 = max((var_1 for var_1 in list1))\n    return (var_0, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "365",
    "filename": "program_365.py",
    "code": "def add_nested_tuples(test_tup1, test_tup2):\n    var_0 = tuple((tuple((a + b for var_1, var_2 in zip(tup1, tup2))) for var_3, var_4 in zip(test_tup1, test_tup2)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "366",
    "filename": "program_366.py",
    "code": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) / 6",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "367",
    "filename": "program_367.py",
    "code": "def pos_count(list):\n    var_0 = 0\n    for var_1 in list:\n        if var_1 >= 0:\n            var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "368",
    "filename": "program_368.py",
    "code": "import math\n\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    var_0 = 1\n    for var_1 in range(2, int(math.sqrt(n)) + 1):\n        var_2 = 0\n        var_3 = 1\n        var_4 = 1\n        while n % var_1 == 0:\n            var_2 = var_2 + 1\n            var_5 = var_5 // var_1\n            if var_1 == 2 and var_2 == 1:\n                var_3 = 0\n            var_4 = var_4 * var_1\n            var_3 = var_3 + var_4\n        var_0 = var_0 * var_3\n    if var_5 >= 2:\n        var_0 = var_0 * (1 + var_5)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "369",
    "filename": "program_369.py",
    "code": "def is_abundant(n):\n    var_0 = sum([fctr for var_1 in range(1, n) if n % var_1 == 0])\n    return var_0 > n",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "370",
    "filename": "program_370.py",
    "code": "def minkowski_distance(point_a: list[float], point_b: list[float], order: int) -> float:\n    \"\"\"\n    This function calculates the Minkowski distance for a given order between\n    two n-dimensional points represented as lists. For the case of order = 1,\n    the Minkowski distance degenerates to the Manhattan distance. For\n    order = 2, the usual Euclidean distance is obtained.\n\n    https://en.wikipedia.org/wiki/Minkowski_distance\n\n    Note: due to floating point calculation errors the output of this\n    function may be inaccurate.\n\n    >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)\n    2.0\n    >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)\n    8.0\n    >>> import numpy as np\n    >>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3)))\n    True\n    >>> minkowski_distance([1.0], [2.0], -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The order must be greater than or equal to 1.\n    >>> minkowski_distance([1.0], [1.0, 2.0], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if order < 1:\n        raise ValueError('The order must be greater than or equal to 1.')\n    if len(point_a) != len(point_b):\n        raise ValueError('Both points must have the same dimension.')\n    return sum((abs(a - b) ** order for var_0, var_1 in zip(point_a, point_b))) ** (1 / order)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "371",
    "filename": "program_371.py",
    "code": "def object_distance(focal_length: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(object_distance(30, 20), -60.0)\n    True\n    >>> from math import isclose\n    >>> isclose(object_distance(10.5, 11.7), 102.375)\n    True\n    >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if distance_of_image == 0 or focal_length == 0:\n        raise ValueError('Invalid inputs. Enter non zero values with respect to the sign convention.')\n    var_0 = 1 / (1 / focal_length - 1 / distance_of_image)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "372",
    "filename": "program_372.py",
    "code": "def re_order(A):\n    var_0 = 0\n    for var_1 in A:\n        if var_1:\n            A[var_0] = var_1\n            var_0 = var_0 + 1\n    for var_1 in range(var_0, len(A)):\n        A[var_1] = 0\n    return A",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "373",
    "filename": "program_373.py",
    "code": "def count_alpha_dig_spl(string):\n    var_0 = var_1 = var_2 = 0\n    for var_3 in range(len(string)):\n        if string[var_3].isalpha():\n            var_0 = var_0 + 1\n        elif string[var_3].isdigit():\n            var_1 = var_1 + 1\n        else:\n            var_2 = var_2 + 1\n    return (var_0, var_1, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "374",
    "filename": "program_374.py",
    "code": "import re\n\ndef num_position(text):\n    for var_0 in re.finditer('\\\\d+', text):\n        return var_0.start()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "375",
    "filename": "program_375.py",
    "code": "def union_elements(test_tup1, test_tup2):\n    var_0 = tuple(set(test_tup1 + test_tup2))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "376",
    "filename": "program_376.py",
    "code": "def reverse_string_list(stringlist):\n    var_0 = [x[::-1] for var_1 in stringlist]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "377",
    "filename": "program_377.py",
    "code": "def even_bit_toggle_number(n):\n    var_0 = 0\n    var_1 = 0\n    var_2 = n\n    while var_2 > 0:\n        if var_1 % 2 == 0:\n            var_0 = var_0 | 1 << var_1\n        var_1 = var_1 + 1\n        var_2 >>= 1\n    return n ^ var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "378",
    "filename": "program_378.py",
    "code": "def permute_unique(nums):\n    var_0 = [[]]\n    for var_1 in nums:\n        var_2 = []\n        for var_3 in var_0:\n            for var_4 in range(len(var_3) + 1):\n                var_2.append(var_3[:var_4] + [var_1] + var_3[var_4:])\n                if var_4 < len(var_3) and var_3[var_4] == var_1:\n                    break\n        var_0 = var_2\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "379",
    "filename": "program_379.py",
    "code": "def permutation_coefficient(n, k):\n    var_0 = [[0 for var_1 in range(k + 1)] for var_2 in range(n + 1)]\n    for var_1 in range(n + 1):\n        for var_2 in range(min(var_1, k) + 1):\n            if var_2 == 0:\n                var_0[var_1][var_2] = 1\n            else:\n                var_0[var_1][var_2] = var_0[var_1 - 1][var_2] + var_2 * var_0[var_1 - 1][var_2 - 1]\n            if var_2 < k:\n                var_0[var_1][var_2 + 1] = 0\n    return var_0[n][k]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "380",
    "filename": "program_380.py",
    "code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    var_0 = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n    if var_0 == 0:\n        return 'No'\n    else:\n        return 'Yes'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "381",
    "filename": "program_381.py",
    "code": "def prod_Square(n):\n    for var_0 in range(2, n + 1):\n        if var_0 * var_0 < n + 1:\n            for var_1 in range(2, n + 1):\n                if var_0 * var_0 * var_1 * var_1 == n:\n                    return True\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "382",
    "filename": "program_382.py",
    "code": "def min_flip_to_make_string_alternate(str):\n    return min(get_flip_with_starting_charcter(str, '0'), get_flip_with_starting_charcter(str, '1'))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "383",
    "filename": "program_383.py",
    "code": "def find_Product(arr, n):\n    arr.sort()\n    var_0 = 1\n    for var_1 in range(0, n, 1):\n        if arr[var_1 - 1] != arr[var_1]:\n            var_0 = var_0 * arr[var_1]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "384",
    "filename": "program_384.py",
    "code": "def count_Intgral_Points(x1, y1, x2, y2):\n    return (y2 - y1 - 1) * (x2 - x1 - 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "385",
    "filename": "program_385.py",
    "code": "def remove_column(list1, n):\n    for var_0 in list1:\n        del var_0[n]\n    return list1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "386",
    "filename": "program_386.py",
    "code": "def lbs(arr):\n    var_0 = len(arr)\n    var_1 = [1 for var_2 in range(var_0 + 1)]\n    for var_2 in range(1, var_0):\n        for var_3 in range(0, var_2):\n            if arr[var_2] > arr[var_3] and var_1[var_2] < var_1[var_3] + 1:\n                var_1[var_2] = var_1[var_3] + 1\n    var_4 = [1 for var_2 in range(var_0 + 1)]\n    for var_2 in reversed(range(var_0 - 1)):\n        for var_3 in reversed(range(var_2 - 1, var_0)):\n            if arr[var_2] > arr[var_3] and var_4[var_2] < var_4[var_3] + 1:\n                var_4[var_2] = var_4[var_3] + 1\n    var_5 = var_1[0] + var_4[0] - 1\n    for var_2 in range(1, var_0):\n        var_5 = max(var_1[var_2] + var_4[var_2] - 1, var_5)\n    return var_5",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "387",
    "filename": "program_387.py",
    "code": "def merge_sort(x):\n    if len(x) == 0 or len(x) == 1:\n        return x\n    else:\n        var_0 = len(x) // 2\n        var_1 = merge_sort(x[:var_0])\n        var_2 = merge_sort(x[var_0:])\n        return merge(var_1, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "388",
    "filename": "program_388.py",
    "code": "def get_max_occuring_char(str1):\n    var_0 = 256\n    var_1 = [0] * var_0\n    var_2 = -1\n    var_3 = ''\n    for var_4 in str1:\n        var_1[ord(var_4)] += 1\n    for var_4 in str1:\n        if var_2 < var_1[ord(var_4)]:\n            var_2 = var_1[ord(var_4)]\n            var_3 = var_4\n    return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "389",
    "filename": "program_389.py",
    "code": "def constant_fold_unary_op(op: str, value: ConstantValue) -> int | float | None:\n    if op == '-' and isinstance(value, (int, float)):\n        return -value\n    elif op == '~' and isinstance(value, int):\n        return ~value\n    elif op == '+' and isinstance(value, (int, float)):\n        return value\n    return None",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "390",
    "filename": "program_390.py",
    "code": "def highest_Power_of_2(n):\n    var_0 = 0\n    for var_1 in range(n, 0, -1):\n        if var_1 & var_1 - 1 == 0:\n            var_0 = var_1\n            break\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "391",
    "filename": "program_391.py",
    "code": "def find_dissimilar(test_tup1, test_tup2):\n    var_0 = tuple(set(test_tup1) ^ set(test_tup2))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "392",
    "filename": "program_392.py",
    "code": "def archimedes_principle(fluid_density: float, volume: float, gravity: float=g) -> float:\n    \"\"\"\n    Args:\n        fluid_density: density of fluid (kg/m^3)\n        volume: volume of object/liquid being displaced by the object (m^3)\n        gravity: Acceleration from gravity. Gravitational force on the system,\n            The default is Earth Gravity\n    returns:\n        the buoyant force on an object in Newtons\n\n    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n    19600.0\n    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n    4885.3\n    >>> archimedes_principle(fluid_density=997, volume=0.7)\n    6844.061035\n    >>> archimedes_principle(fluid_density=997, volume=-0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible object volume\n    >>> archimedes_principle(fluid_density=0, volume=0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible fluid density\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n    0.0\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible gravity\n    \"\"\"\n    if fluid_density <= 0:\n        raise ValueError('Impossible fluid density')\n    if volume <= 0:\n        raise ValueError('Impossible object volume')\n    if gravity < 0:\n        raise ValueError('Impossible gravity')\n    return fluid_density * gravity * volume",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "393",
    "filename": "program_393.py",
    "code": "def first_repeated_word(str1):\n    var_0 = set()\n    for var_1 in str1.split():\n        if var_1 in var_0:\n            return var_1\n        else:\n            var_0.add(var_1)\n    return 'None'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "394",
    "filename": "program_394.py",
    "code": "def check(string):\n    if len(set(string).intersection('AEIOUaeiou')) >= 5:\n        return 'accepted'\n    else:\n        return 'not accepted'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "395",
    "filename": "program_395.py",
    "code": "def radix_sort(nums):\n    var_0 = 10\n    var_1 = 1\n    var_2 = max(nums)\n    while var_1 < var_2:\n        var_3 = [list() for var_4 in range(var_0)]\n        for var_5 in nums:\n            var_6 = int(var_5 / var_1 % var_0)\n            var_3[var_6].append(var_5)\n        var_7 = 0\n        for var_8 in range(var_0):\n            var_9 = var_3[var_8]\n            for var_5 in var_9:\n                nums[var_7] = var_5\n                var_7 += 1\n        var_1 *= var_0\n    return nums",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "396",
    "filename": "program_396.py",
    "code": "def str_to_list(string):\n    var_0 = []\n    for var_1 in string:\n        var_0.append(var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "397",
    "filename": "program_397.py",
    "code": "def get_3d_vectors_cross(ab: Vector3d, ac: Vector3d) -> Vector3d:\n    \"\"\"\n    Get the cross of the two vectors AB and AC.\n\n    I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.\n\n    Read More:\n        https://en.wikipedia.org/wiki/Cross_product\n        https://en.wikipedia.org/wiki/Determinant\n\n    >>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2))\n    (-55, 22, 11)\n    >>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1))\n    (0, 0, 0)\n    >>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))\n    (-36, -48, 27)\n    >>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))\n    (-123.2594, 277.15110000000004, 129.11260000000001)\n    \"\"\"\n    var_0 = ab[1] * ac[2] - ab[2] * ac[1]\n    var_1 = (ab[0] * ac[2] - ab[2] * ac[0]) * -1\n    var_2 = ab[0] * ac[1] - ab[1] * ac[0]\n    return (var_0, var_1, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "398",
    "filename": "program_398.py",
    "code": "def ascii_value_string(str1):\n    for var_0 in range(len(str1)):\n        return ord(str1[var_0])",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "399",
    "filename": "program_399.py",
    "code": "def find_Odd_Pair(A, N):\n    var_0 = 0\n    for var_1 in range(0, N):\n        for var_2 in range(var_1 + 1, N):\n            if (A[var_1] ^ A[var_2]) % 2 != 0:\n                var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "400",
    "filename": "program_400.py",
    "code": "def max_sum_increasing_subseq(a, n, index, k):\n    var_0 = [[0 for var_1 in range(n)] for var_1 in range(n)]\n    for var_1 in range(n):\n        if a[var_1] > a[0]:\n            var_0[0][var_1] = a[var_1] + a[0]\n        else:\n            var_0[0][var_1] = a[var_1]\n    for var_1 in range(1, n):\n        for var_2 in range(n):\n            if a[var_2] > a[var_1] and var_2 > var_1:\n                if var_0[var_1 - 1][var_1] + a[var_2] > var_0[var_1 - 1][var_2]:\n                    var_0[var_1][var_2] = var_0[var_1 - 1][var_1] + a[var_2]\n                else:\n                    var_0[var_1][var_2] = var_0[var_1 - 1][var_2]\n            else:\n                var_0[var_1][var_2] = var_0[var_1 - 1][var_2]\n    return var_0[index][k]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "401",
    "filename": "program_401.py",
    "code": "from collections import Counter\n\ndef second_frequent(input):\n    var_0 = Counter(input)\n    var_1 = sorted(var_0.values(), reverse=True)\n    var_2 = var_1[1]\n    for var_3, var_4 in var_0.items():\n        if var_4 == var_2:\n            return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "402",
    "filename": "program_402.py",
    "code": "def min_length_list(input_list):\n    var_0 = min((len(x) for var_1 in input_list))\n    var_2 = min(input_list, key=lambda i: len(i))\n    return (var_0, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "403",
    "filename": "program_403.py",
    "code": "def logical_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in positive 2 integers.\n    'number' is the integer to be logically right shifted 'shift_amount' times.\n    i.e. (number >>> shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_right_shift(0, 1)\n    '0b0'\n    >>> logical_right_shift(1, 1)\n    '0b0'\n    >>> logical_right_shift(1, 5)\n    '0b0'\n    >>> logical_right_shift(17, 2)\n    '0b100'\n    >>> logical_right_shift(1983, 4)\n    '0b1111011'\n    >>> logical_right_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if number < 0 or shift_amount < 0:\n        raise ValueError('both inputs must be positive integers')\n    var_0 = str(bin(number))[2:]\n    if shift_amount >= len(var_0):\n        return '0b0'\n    var_1 = var_0[:len(var_0) - shift_amount]\n    return '0b' + var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "404",
    "filename": "program_404.py",
    "code": "def front_and_rear(test_tup):\n    var_0 = (test_tup[0], test_tup[-1])\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "405",
    "filename": "program_405.py",
    "code": "def access_key(ditionary, key):\n    return list(ditionary)[key]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "406",
    "filename": "program_406.py",
    "code": "def get_gcd(l):\n    var_0 = l[0]\n    var_1 = l[1]\n    var_2 = find_gcd(var_0, var_1)\n    for var_3 in range(2, len(l)):\n        var_2 = find_gcd(var_2, l[var_3])\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "407",
    "filename": "program_407.py",
    "code": "def _valarray(shape, value=np.nan, typecode=None):\n    \"\"\"Return an array of all value.\"\"\"\n    var_0 = np.ones(shape, dtype=bool) * value\n    if typecode is not None:\n        var_0 = var_0.astype(typecode)\n    if not isinstance(var_0, np.ndarray):\n        var_0 = np.asarray(var_0)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "408",
    "filename": "program_408.py",
    "code": "def sum_Of_product(n):\n    return binomial_Coeff(2 * n, n - 1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "409",
    "filename": "program_409.py",
    "code": "def count_Rotation(arr, n):\n    for var_0 in range(1, n):\n        if arr[var_0] < arr[var_0 - 1]:\n            return var_0\n    return 0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "410",
    "filename": "program_410.py",
    "code": "def last(n):\n    return n[-1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "411",
    "filename": "program_411.py",
    "code": "def check_Type_Of_Triangle(a, b, c):\n    var_0 = pow(a, 2)\n    var_1 = pow(b, 2)\n    var_2 = pow(c, 2)\n    if var_0 == var_0 + var_1 or var_1 == var_0 + var_2 or var_2 == var_0 + var_1:\n        return 'Right-angled Triangle'\n    elif var_0 > var_2 + var_1 or var_1 > var_0 + var_2 or var_2 > var_0 + var_1:\n        return 'Obtuse-angled Triangle'\n    else:\n        return 'Acute-angled Triangle'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "412",
    "filename": "program_412.py",
    "code": "def __get_demo_graph(index):\n    return [{0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 5], 3: [2, 4], 4: [3], 5: [2, 6, 8], 6: [5, 7], 7: [6, 8], 8: [5, 7]}, {0: [6], 1: [9], 2: [4, 5], 3: [4], 4: [2, 3], 5: [2], 6: [0, 7], 7: [6], 8: [], 9: [1]}, {0: [4], 1: [6], 2: [], 3: [5, 6, 7], 4: [0, 6], 5: [3, 8, 9], 6: [1, 3, 4, 7], 7: [3, 6, 8, 9], 8: [5, 7], 9: [5, 7]}, {0: [1, 3], 1: [0, 2, 4], 2: [1, 3, 4], 3: [0, 2, 4], 4: [1, 2, 3]}][index]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "413",
    "filename": "program_413.py",
    "code": "def electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exactly one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    >>> electric_power(current=0, power=6, voltage=2)\n    Result(name='current', value=3.0)\n    \"\"\"\n    if (voltage, current, power).count(0) != 1:\n        raise ValueError('Exactly one argument must be 0')\n    elif power < 0:\n        raise ValueError('Power cannot be negative in any electrical/electronics system')\n    elif voltage == 0:\n        return Result('voltage', power / current)\n    elif current == 0:\n        return Result('current', power / voltage)\n    elif power == 0:\n        return Result('power', float(round(abs(voltage * current), 2)))\n    else:\n        raise AssertionError",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "414",
    "filename": "program_414.py",
    "code": "def sum_Of_Series(n):\n    var_0 = 0\n    for var_1 in range(1, n + 1):\n        var_0 += var_1 * var_1 * var_1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "415",
    "filename": "program_415.py",
    "code": "def float_to_tuple(test_str):\n    var_0 = tuple(map(float, test_str.split(', ')))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "416",
    "filename": "program_416.py",
    "code": "def concatenate_tuple(test_tup):\n    var_0 = '-'\n    var_1 = ''.join([str(ele) + var_0 for var_2 in test_tup])\n    var_1 = var_1[:len(var_1) - len(var_0)]\n    return str(var_1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "417",
    "filename": "program_417.py",
    "code": "def load_pandas():\n    \"\"\"\n    Load the strikes data and return a Dataset class instance.\n\n    Returns\n    -------\n    Dataset\n        See DATASET_PROPOSAL.txt for more information.\n    \"\"\"\n    var_0 = _get_data()\n    return du.process_pandas(var_0, endog_idx=0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "418",
    "filename": "program_418.py",
    "code": "def plus_one_v3(num_arr):\n    for var_0 in reversed(list(enumerate(num_arr))):\n        num_arr[var_0[0]] = (num_arr[var_0[0]] + 1) % 10\n        if num_arr[var_0[0]]:\n            return num_arr\n    return [1] + num_arr",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "419",
    "filename": "program_419.py",
    "code": "def base64_encode(data: bytes) -> bytes:\n    \"\"\"Encodes data according to RFC4648.\n\n    The data is first transformed to binary and appended with binary digits so that its\n    length becomes a multiple of 6, then each 6 binary digits will match a character in\n    the B64_CHARSET string. The number of appended binary digits would later determine\n    how many \"=\" signs should be added, the padding.\n    For every 2 binary digits added, a \"=\" sign is added in the output.\n    We can add any binary digits to make it a multiple of 6, for instance, consider the\n    following example:\n    \"AA\" -> 0010100100101001 -> 001010 010010 1001\n    As can be seen above, 2 more binary digits should be added, so there's 4\n    possibilities here: 00, 01, 10 or 11.\n    That being said, Base64 encoding can be used in Steganography to hide data in these\n    appended digits.\n\n    >>> from base64 import b64encode\n    >>> a = b\"This pull request is part of Hacktoberfest20!\"\n    >>> b = b\"https://tools.ietf.org/html/rfc4648\"\n    >>> c = b\"A\"\n    >>> base64_encode(a) == b64encode(a)\n    True\n    >>> base64_encode(b) == b64encode(b)\n    True\n    >>> base64_encode(c) == b64encode(c)\n    True\n    >>> base64_encode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    TypeError: a bytes-like object is required, not 'str'\n    \"\"\"\n    if not isinstance(data, bytes):\n        var_0 = f\"a bytes-like object is required, not '{data.__class__.__name__}'\"\n        raise TypeError(var_0)\n    var_1 = ''.join((bin(byte)[2:].zfill(8) for var_2 in data))\n    var_3 = len(var_1) % 6 != 0\n    if var_3:\n        var_4 = b'=' * ((6 - len(var_1) % 6) // 2)\n        var_1 += '0' * (6 - len(var_1) % 6)\n    else:\n        var_4 = b''\n    return ''.join((B64_CHARSET[int(var_1[index:index + 6], 2)] for var_5 in range(0, len(var_1), 6))).encode() + var_4",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "420",
    "filename": "program_420.py",
    "code": "def check_monthnumb_number(monthnum2):\n    if monthnum2 == 1 or monthnum2 == 3 or monthnum2 == 5 or (monthnum2 == 7) or (monthnum2 == 8) or (monthnum2 == 10) or (monthnum2 == 12):\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "421",
    "filename": "program_421.py",
    "code": "def length_Of_Last_Word(a):\n    var_0 = 0\n    var_1 = a.strip()\n    for var_2 in range(len(var_1)):\n        if var_1[var_2] == ' ':\n            var_0 = 0\n        else:\n            var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "422",
    "filename": "program_422.py",
    "code": "def is_tree_balanced(root):\n    if root is None:\n        return True\n    var_0 = get_height(root.left)\n    var_1 = get_height(root.right)\n    if abs(var_0 - var_1) <= 1 and is_tree_balanced(root.left) is True and (is_tree_balanced(root.right) is True):\n        return True\n    return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "423",
    "filename": "program_423.py",
    "code": "def casimir_force(force: float, area: float, distance: float) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force -> Casimir Force : magnitude in Newtons\n\n    area -> Surface area of each plate : magnitude in square meters\n\n    distance -> Distance between two plates : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> casimir_force(force = 0, area = 4, distance = 0.03)\n    {'force': 6.4248189174864216e-21}\n\n    >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)\n    {'distance': 1.0323056015031114e-05}\n\n    >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)\n    {'area': 0.06688838837354052}\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)\n    Traceback (most recent call last):\n        ...\n    ValueError: Distance can not be negative\n\n    >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Magnitude of force can not be negative\n    \"\"\"\n    if (force, area, distance).count(0) != 1:\n        raise ValueError('One and only one argument must be 0')\n    if force < 0:\n        raise ValueError('Magnitude of force can not be negative')\n    if distance < 0:\n        raise ValueError('Distance can not be negative')\n    if area < 0:\n        raise ValueError('Area can not be negative')\n    if force == 0:\n        var_0 = REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2 * area / (240 * distance ** 4)\n        return {'force': var_0}\n    elif area == 0:\n        var_1 = 240 * var_0 * distance ** 4 / (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2)\n        return {'area': var_1}\n    elif distance == 0:\n        var_2 = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi ** 2 * var_1 / (240 * var_0)) ** (1 / 4)\n        return {'distance': var_2}\n    raise ValueError('One and only one argument must be 0')",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "424",
    "filename": "program_424.py",
    "code": "import re\n\ndef remove_multiple_spaces(text1):\n    return re.sub(' +', ' ', text1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "425",
    "filename": "program_425.py",
    "code": "def first_odd(nums):\n    var_0 = next((el for var_1 in nums if var_1 % 2 != 0), -1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "426",
    "filename": "program_426.py",
    "code": "def similarity_search(dataset: np.ndarray, value_array: np.ndarray) -> list[list[list[float] | float]]:\n    \"\"\"\n    :param dataset: Set containing the vectors. Should be ndarray.\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\n    :return: Result will be a list containing\n            1. the nearest vector\n            2. distance from the vector\n\n    >>> dataset = np.array([[0], [1], [2]])\n    >>> value_array = np.array([[0]])\n    >>> similarity_search(dataset, value_array)\n    [[[0], 0.0]]\n\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\n    These are the errors that might occur:\n\n    1. If dimensions are different.\n    For example, dataset has 2d array and value_array has 1d array:\n    >>> dataset = np.array([[1]])\n    >>> value_array = np.array([1])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n    2. If data's shapes are different.\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\n    We are expecting same shapes of two arrays, so it is wrong.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n    3. If data types are different.\n    When trying to compare, we are expecting same types so they should be same.\n    If not, it'll come up with errors.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: Input data have different datatype...\n    dataset : float32, value_array : int32\n    \"\"\"\n    if dataset.ndim != value_array.ndim:\n        var_0 = f\"Wrong input data's dimensions... dataset : {dataset.ndim}, value_array : {value_array.ndim}\"\n        raise ValueError(var_0)\n    try:\n        if dataset.shape[1] != value_array.shape[1]:\n            var_0 = f\"Wrong input data's shape... dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}\"\n            raise ValueError(var_0)\n    except IndexError:\n        if dataset.ndim != value_array.ndim:\n            raise TypeError('Wrong shape')\n    if dataset.dtype != value_array.dtype:\n        var_0 = f'Input data have different datatype... dataset : {dataset.dtype}, value_array : {value_array.dtype}'\n        raise TypeError(var_0)\n    var_1 = []\n    for var_2 in value_array:\n        var_3 = euclidean(var_2, dataset[0])\n        var_4 = dataset[0].tolist()\n        for var_5 in dataset[1:]:\n            var_6 = euclidean(var_2, var_5)\n            if var_3 > var_6:\n                var_3 = var_6\n                var_4 = var_5.tolist()\n        var_1.append([var_4, var_3])\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "427",
    "filename": "program_427.py",
    "code": "def ap_sum(a, n, d):\n    var_0 = n * (2 * a + (n - 1) * d) / 2\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "428",
    "filename": "program_428.py",
    "code": "def lucky_num(n):\n    var_0 = range(-1, n * n + 9, 2)\n    var_1 = 2\n    while var_0[var_1:]:\n        var_0 = sorted(set(var_0) - set(var_0[var_0[var_1]::var_0[var_1]]))\n        var_1 += 1\n    return var_0[1:n + 1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "429",
    "filename": "program_429.py",
    "code": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    var_0 = var_0 or {}\n    var_0 = var_0.get(key)\n    if var_0:\n        if hasattr(var_0, '__call__'):\n            var_0 = [var_0]\n        for var_1 in var_0:\n            var_2 = var_1(hook_data, **kwargs)\n            if var_2 is not None:\n                var_3 = var_2\n    return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "430",
    "filename": "program_430.py",
    "code": "def rombus_area(p, q):\n    var_0 = p * q / 2\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "431",
    "filename": "program_431.py",
    "code": "def parse_strings(strs: _StrOrIter) -> Iterator[str]:\n    \"\"\"\n    Yield requirement strings for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    \"\"\"\n    return text.join_continuation(map(text.drop_comment, text.yield_lines(strs)))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "432",
    "filename": "program_432.py",
    "code": "def Check_Solution(a, b, c):\n    if a == c:\n        return 'Yes'\n    else:\n        return 'No'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "433",
    "filename": "program_433.py",
    "code": "def build_client_middlewares(handler: ClientHandlerType, middlewares: Sequence[ClientMiddlewareType]) -> ClientHandlerType:\n    \"\"\"\n    Apply middlewares to request handler.\n\n    The middlewares are applied in reverse order, so the first middleware\n    in the list wraps all subsequent middlewares and the handler.\n\n    This implementation avoids using partial/update_wrapper to minimize overhead\n    and doesn't cache to avoid holding references to stateful middleware.\n    \"\"\"\n    if len(middlewares) == 1:\n        var_0 = middlewares[0]\n\n        async def single_middleware_handler(req: ClientRequest) -> ClientResponse:\n            return await var_0(req, handler)\n        return single_middleware_handler\n    var_1 = handler\n    for var_0 in reversed(middlewares):\n\n        def make_wrapper(mw: ClientMiddlewareType, next_h: ClientHandlerType) -> ClientHandlerType:\n\n            async def wrapped(req: ClientRequest) -> ClientResponse:\n                return await mw(req, next_h)\n            return wrapped\n        var_1 = make_wrapper(var_0, var_1)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "434",
    "filename": "program_434.py",
    "code": "def knapsack(weights: list, values: list, number_of_items: int, max_weight: int, index: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    var_0 = 0\n    var_1 = 0\n    var_0 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        var_1 = values[index] + knapsack(weights, values, number_of_items, max_weight - weights[index], index + 1)\n    return max(var_0, var_1)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "435",
    "filename": "program_435.py",
    "code": "def zeller(date_input: str) -> str:\n    \"\"\"\n    | Zellers Congruence Algorithm\n    | Find the day of the week for nearly any Gregorian or Julian calendar date\n\n    >>> zeller('01-31-2010')\n    'Your date 01-31-2010, is a Sunday!'\n\n    Validate out of range month:\n\n    >>> zeller('13-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Month must be between 1 - 12\n    >>> zeller('.2-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.2'\n\n    Validate out of range date:\n\n    >>> zeller('01-33-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date must be between 1 - 31\n    >>> zeller('01-.4-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.4'\n\n    Validate second separator:\n\n    >>> zeller('01-31*2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate first separator:\n\n    >>> zeller('01^31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate out of range year:\n\n    >>> zeller('01-31-8999')\n    Traceback (most recent call last):\n        ...\n    ValueError: Year out of range. There has to be some sort of limit...right?\n\n    Test null input:\n\n    >>> zeller()\n    Traceback (most recent call last):\n        ...\n    TypeError: zeller() missing 1 required positional argument: 'date_input'\n\n    Test length of `date_input`:\n\n    >>> zeller('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\n    >>> zeller('01-31-19082939')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\"\"\"\n    var_0 = {'0': 'Sunday', '1': 'Monday', '2': 'Tuesday', '3': 'Wednesday', '4': 'Thursday', '5': 'Friday', '6': 'Saturday'}\n    var_1 = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}\n    if not 0 < len(date_input) < 11:\n        raise ValueError('Must be 10 characters long')\n    var_2: int = int(date_input[0] + date_input[1])\n    if not 0 < var_2 < 13:\n        raise ValueError('Month must be between 1 - 12')\n    var_3: str = date_input[2]\n    if var_3 not in ['-', '/']:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n    var_4: int = int(date_input[3] + date_input[4])\n    if not 0 < var_4 < 32:\n        raise ValueError('Date must be between 1 - 31')\n    var_5: str = date_input[5]\n    if var_5 not in ['-', '/']:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n    var_6: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])\n    if not 45 < var_6 < 8500:\n        raise ValueError('Year out of range. There has to be some sort of limit...right?')\n    var_7 = datetime.date(int(var_6), int(var_2), int(var_4))\n    if var_2 <= 2:\n        var_6 = var_6 - 1\n        var_2 = var_2 + 12\n    var_8: int = int(str(var_6)[:2])\n    var_9: int = int(str(var_6)[2:])\n    var_10: int = int(2.6 * var_2 - 5.39)\n    var_11: int = int(var_8 / 4)\n    var_12: int = int(var_9 / 4)\n    var_13: int = int(var_4 + var_9)\n    var_14: int = int(var_10 + var_11 + var_12 + var_13)\n    var_15: int = int(var_14 - 2 * var_8)\n    var_16: int = round(var_15 % 7)\n    if var_16 != var_1[var_7.weekday()]:\n        raise AssertionError('The date was evaluated incorrectly. Contact developer.')\n    var_17: str = f'Your date {date_input}, is a {var_0[str(var_16)]}!'\n    return var_17",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "436",
    "filename": "program_436.py",
    "code": "from math import radians, sin, cos, acos\n\ndef distance_lat_long(slat, slon, elat, elon):\n    var_0 = 6371.01 * acos(sin(slat) * sin(elat) + cos(slat) * cos(elat) * cos(slon - elon))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "437",
    "filename": "program_437.py",
    "code": "def count_list(input_list):\n    return len(input_list)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "438",
    "filename": "program_438.py",
    "code": "from collections import Counter\n\ndef max_char(str1):\n    var_0 = Counter(str1)\n    var_1 = max(var_0, key=var_0.get)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "439",
    "filename": "program_439.py",
    "code": "import re\n\ndef replace_max_specialchar(text, n):\n    return re.sub('[ ,.]', ':', text, n)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "440",
    "filename": "program_440.py",
    "code": "import re\n\ndef extract_date(url):\n    return re.findall('/(\\\\d{4})/(\\\\d{1,2})/(\\\\d{1,2})/', url)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "441",
    "filename": "program_441.py",
    "code": "def dict_filter(dict, n):\n    var_0 = {key: value for var_1, var_2 in dict.items() if var_2 >= n}\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "442",
    "filename": "program_442.py",
    "code": "def Split(list):\n    var_0 = []\n    for var_1 in list:\n        if var_1 % 2 != 0:\n            var_0.append(var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "443",
    "filename": "program_443.py",
    "code": "def chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem2(5,1,7,3)\n    31\n\n    >>> chinese_remainder_theorem2(6,1,4,3)\n    14\n\n    \"\"\"\n    var_0, var_1 = (invert_modulo(n1, n2), invert_modulo(n2, n1))\n    var_2 = n1 * n2\n    var_3 = r2 * var_0 * n1 + r1 * var_1 * n2\n    return (var_3 % var_2 + var_2) % var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "444",
    "filename": "program_444.py",
    "code": "def common_in_nested_lists(nestedlist):\n    var_0 = list(set.intersection(*map(set, nestedlist)))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "445",
    "filename": "program_445.py",
    "code": "def parabola_vertex(a, b, c):\n    var_0 = (-b / (2 * a), (4 * a * c - b * b) / (4 * a))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "446",
    "filename": "program_446.py",
    "code": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    var_0 = sorted(var_0)\n    var_1 = sorted(var_1)\n    var_2 = sorted(var_2)\n    var_3 = heapq.merge(var_0, var_1, var_2)\n    return list(var_3)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "447",
    "filename": "program_447.py",
    "code": "def filter_evennumbers(nums):\n    var_0 = list(filter(lambda x: x % 2 == 0, nums))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "448",
    "filename": "program_448.py",
    "code": "def check_Consecutive(l):\n    return sorted(l) == list(range(min(l), max(l) + 1))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "449",
    "filename": "program_449.py",
    "code": "def count_X(tup, x):\n    var_0 = 0\n    for var_1 in tup:\n        if var_1 == x:\n            var_0 = var_0 + 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "450",
    "filename": "program_450.py",
    "code": "def find_even_Pair(A, N):\n    var_0 = 0\n    for var_1 in range(0, N):\n        for var_2 in range(var_1 + 1, N):\n            if (A[var_1] ^ A[var_2]) % 2 == 0:\n                var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "451",
    "filename": "program_451.py",
    "code": "import math\n\ndef sum_of_odd_Factors(n):\n    var_0 = 1\n    while n % 2 == 0:\n        var_1 = var_1 // 2\n    for var_2 in range(3, int(math.sqrt(var_1) + 1)):\n        var_3 = 0\n        var_4 = 1\n        var_5 = 1\n        while var_1 % var_2 == 0:\n            var_3 += 1\n            var_1 = var_1 // var_2\n            var_5 *= var_2\n            var_4 += var_5\n        var_0 *= var_4\n    if var_1 >= 2:\n        var_0 *= 1 + var_1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "452",
    "filename": "program_452.py",
    "code": "def roman_to_int(s):\n    var_0 = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    var_1 = 0\n    for var_2 in range(len(s)):\n        if var_2 > 0 and var_0[s[var_2]] > var_0[s[var_2 - 1]]:\n            var_1 += var_0[s[var_2]] - 2 * var_0[s[var_2 - 1]]\n        else:\n            var_1 += var_0[s[var_2]]\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "453",
    "filename": "program_453.py",
    "code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    var_0 = [0] * len(array)\n    var_0[0] = array[0]\n    for var_1 in range(1, len(array)):\n        var_0[var_1] = var_0[var_1 - 1] + array[var_1]\n    var_2 = []\n    for var_3 in queries:\n        var_4, var_5 = var_3\n        var_6 = var_0[var_5]\n        if var_4 > 0:\n            var_6 -= var_0[var_4 - 1]\n        var_2.append(var_6)\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "454",
    "filename": "program_454.py",
    "code": "def len_log(list1):\n    var_0 = len(list1[0])\n    for var_1 in list1:\n        if len(var_1) < var_0:\n            var_0 = len(var_1)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "455",
    "filename": "program_455.py",
    "code": "def throw_dice(num_throws: int, num_dice: int=2) -> list[float]:\n    \"\"\"\n    Return probability list of all possible sums when throwing dice.\n\n    >>> random.seed(0)\n    >>> throw_dice(10, 1)\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n    >>> throw_dice(100, 1)\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n    >>> throw_dice(1000, 1)\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n    >>> throw_dice(10000, 1)\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n    >>> throw_dice(10000, 2)\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\n    \"\"\"\n    var_0 = [Dice() for var_1 in range(num_dice)]\n    var_2 = [0] * (len(var_0) * Dice.NUM_SIDES + 1)\n    for var_3 in range(num_throws):\n        var_2[sum((dice.roll() for var_4 in var_0))] += 1\n    var_5 = [round(count * 100 / num_throws, 2) for var_6 in var_2]\n    return var_5[num_dice:]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "456",
    "filename": "program_456.py",
    "code": "def get_noOfways(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return get_noOfways(n - 1) + get_noOfways(n - 2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "457",
    "filename": "program_457.py",
    "code": "def modular_sum(arr, n, m):\n    if n > m:\n        return True\n    var_0 = [False for var_1 in range(m)]\n    for var_1 in range(n):\n        if var_0[0]:\n            return True\n        var_2 = [False for var_1 in range(m)]\n        for var_3 in range(m):\n            if var_0[var_3] == True:\n                if var_0[(var_3 + arr[var_1]) % m] == False:\n                    var_2[(var_3 + arr[var_1]) % m] = True\n        for var_3 in range(m):\n            if var_2[var_3]:\n                var_0[var_3] = True\n        var_0[arr[var_1] % m] = True\n    return var_0[0]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "458",
    "filename": "program_458.py",
    "code": "from collections import Counter\n\ndef count_common(words):\n    var_0 = Counter(words)\n    var_1 = var_0.most_common(4)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "459",
    "filename": "program_459.py",
    "code": "def check_distinct(test_tup):\n    var_0 = True\n    var_1 = set()\n    for var_2 in test_tup:\n        if var_2 in var_1:\n            var_0 = False\n            break\n        var_1.add(var_2)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "460",
    "filename": "program_460.py",
    "code": "def sum_list(lst1, lst2):\n    var_0 = [lst1[i] + lst2[i] for var_1 in range(len(lst1))]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "461",
    "filename": "program_461.py",
    "code": "from heapq import heappop, heappush\n\ndef find_minimum_range(list):\n    var_0 = float('-inf')\n    var_1 = (0, float('inf'))\n    var_2 = []\n    for var_3 in range(len(list)):\n        heappush(var_2, Node(list[var_3][0], var_3, 0))\n        var_0 = max(var_0, list[var_3][0])\n    while True:\n        var_4 = heappop(var_2)\n        var_5 = var_4.value\n        var_3 = var_4.list_num\n        var_6 = var_4.index\n        if var_0 - var_5 < var_1[1] - var_1[0]:\n            var_1 = (var_5, var_0)\n        if var_6 == len(list[var_3]) - 1:\n            return var_1\n        heappush(var_2, Node(list[var_3][var_6 + 1], var_3, var_6 + 1))\n        var_0 = max(var_0, list[var_3][var_6 + 1])",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "462",
    "filename": "program_462.py",
    "code": "def parabola_directrix(a, b, c):\n    var_0 = int(c - (b * b + 1) * 4 * a)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "463",
    "filename": "program_463.py",
    "code": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    var_0 = 0\n    for var_1 in tup:\n        if var_1 in lst:\n            var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "464",
    "filename": "program_464.py",
    "code": "def lateralsuface_cylinder(r, h):\n    var_0 = 2 * 3.1415 * r * h\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "465",
    "filename": "program_465.py",
    "code": "def extract_rear(test_tuple):\n    var_0 = list((sub[len(sub) - 1] for var_1 in test_tuple))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "466",
    "filename": "program_466.py",
    "code": "def str_to_datetime_processor_factory(regexp: Pattern[str], type_: Callable[..., _DT]) -> Callable[[Optional[str]], Optional[_DT]]:\n    var_0 = regexp.match\n    var_1 = bool(regexp.groupindex)\n\n    def process(value: Optional[str]) -> Optional[_DT]:\n        if value is None:\n            return None\n        else:\n            try:\n                var_2 = var_0(value)\n            except TypeError as err:\n                raise ValueError(\"Couldn't parse %s string '%r' - value is not a string.\" % (type_.__name__, value)) from err\n            if var_2 is None:\n                raise ValueError(\"Couldn't parse %s string: '%s'\" % (type_.__name__, value))\n            if var_1:\n                var_3 = var_2.groupdict(0)\n                return type_(**dict(list(zip(iter(var_3.keys()), list(map(int, iter(var_3.values())))))))\n            else:\n                return type_(*list(map(int, var_2.groups(0))))\n    return process",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "467",
    "filename": "program_467.py",
    "code": "def get_Pairs_Count(arr, n, sum):\n    var_0 = 0\n    for var_1 in range(0, n):\n        for var_2 in range(var_1 + 1, n):\n            if arr[var_1] + arr[var_2] == sum:\n                var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "468",
    "filename": "program_468.py",
    "code": "from collections import defaultdict\n\ndef count_Substrings(s, n):\n    var_0, var_1 = (0, 0)\n    var_2 = defaultdict(lambda: 0)\n    var_2[0] += 1\n    for var_3 in range(n):\n        var_1 += ord(s[var_3]) - ord('0')\n        var_0 += var_2[var_1 - (var_3 + 1)]\n        var_2[var_1 - (var_3 + 1)] += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "469",
    "filename": "program_469.py",
    "code": "def _base85_to_10(digits: list) -> int:\n    return sum((char * 85 ** i for var_0, var_1 in enumerate(reversed(digits))))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "470",
    "filename": "program_470.py",
    "code": "def remove_even(l):\n    for var_0 in l:\n        if var_0 % 2 == 0:\n            l.remove(var_0)\n    return l",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "471",
    "filename": "program_471.py",
    "code": "def min_product_tuple(list1):\n    var_0 = min([abs(x * y) for var_1, var_2 in list1])\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "472",
    "filename": "program_472.py",
    "code": "import re\n\ndef camel_to_snake(text):\n    var_0 = re.sub('(.)([A-Z][a-z]+)', '\\\\1_\\\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', '\\\\1_\\\\2', var_0).lower()",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "473",
    "filename": "program_473.py",
    "code": "def find_length(string, n):\n    var_0 = 0\n    var_1 = 0\n    for var_2 in range(n):\n        var_0 += 1 if string[var_2] == '0' else -1\n        if var_0 < 0:\n            var_0 = 0\n        var_1 = max(var_0, var_1)\n    return var_1 if var_1 else 0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "474",
    "filename": "program_474.py",
    "code": "def count_Set_Bits(n):\n    var_0 += 1\n    var_1 = 2\n    var_2 = var_0 // 2\n    while var_1 <= var_0:\n        var_3 = var_0 // var_1\n        var_2 += var_3 // 2 * var_1\n        if var_3 & 1:\n            var_2 += var_0 % var_1\n        else:\n            var_2 += 0\n        var_1 <<= 1\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "475",
    "filename": "program_475.py",
    "code": "def distance(a: Point, b: Point) -> float:\n    \"\"\"\n    >>> point1 = Point(2, -1, 7)\n    >>> point2 = Point(1, -3, 5)\n    >>> print(f\"Distance from {point1} to {point2} is {distance(point1, point2)}\")\n    Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0\n    \"\"\"\n    return math.sqrt(abs((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2))",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "476",
    "filename": "program_476.py",
    "code": "def pass_and_relaxation(graph: dict, v: str, visited_forward: set, visited_backward: set, cst_fwd: dict, cst_bwd: dict, queue: PriorityQueue, parent: dict, shortest_distance: float) -> float:\n    for var_0, var_1 in graph[v]:\n        if var_0 in visited_forward:\n            continue\n        var_2 = cst_fwd.get(var_0, np.inf)\n        var_3 = cst_fwd[v] + var_1\n        if var_3 < var_2:\n            queue.put((var_3, var_0))\n            cst_fwd[var_0] = var_3\n            parent[var_0] = v\n        if var_0 in visited_backward and cst_fwd[v] + var_1 + cst_bwd[var_0] < shortest_distance:\n            var_4 = cst_fwd[v] + var_1 + cst_bwd[var_0]\n    return var_4",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "477",
    "filename": "program_477.py",
    "code": "def retroactive_resolution(coefficients: NDArray[float64], vector: NDArray[float64]) -> NDArray[float64]:\n    \"\"\"\n    This function performs a retroactive linear system resolution\n    for triangular matrix\n\n    Examples:\n        1.\n            * 2x1 + 2x2 - 1x3 = 5\n            * 0x1 - 2x2 - 1x3 = -7\n            * 0x1 + 0x2 + 5x3 = 15\n        2.\n            * 2x1 + 2x2 = -1\n            * 0x1 - 2x2 = -1\n\n    >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])\n    array([[2.],\n           [2.],\n           [3.]])\n    >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])\n    array([[-1. ],\n           [ 0.5]])\n    \"\"\"\n    var_0, var_1 = np.shape(coefficients)\n    var_2: NDArray[float64] = np.zeros((var_0, 1), dtype=float)\n    for var_3 in reversed(range(var_0)):\n        var_4 = np.dot(coefficients[var_3, var_3 + 1:], var_2[var_3 + 1:])\n        var_2[var_3, 0] = (vector[var_3][0] - var_4[0]) / coefficients[var_3, var_3]\n    return var_2",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "478",
    "filename": "program_478.py",
    "code": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return\n    if len(numbers) == 2 and numbers[0] == numbers[1]:\n        return\n    var_0 = set()\n    var_1 = []\n    for var_2 in numbers:\n        if var_2 not in var_0:\n            var_1.append(var_2)\n            var_0.add(var_2)\n    var_1.sort()\n    return var_1[1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "479",
    "filename": "program_479.py",
    "code": "def count_vowels(test_str):\n    var_0 = 0\n    var_1 = ['a', 'e', 'i', 'o', 'u']\n    for var_2 in range(1, len(test_str) - 1):\n        if test_str[var_2] not in var_1 and (test_str[var_2 - 1] in var_1 or test_str[var_2 + 1] in var_1):\n            var_0 += 1\n    if test_str[0] not in var_1 and test_str[1] in var_1:\n        var_0 += 1\n    if test_str[-1] not in var_1 and test_str[-2] in var_1:\n        var_0 += 1\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "480",
    "filename": "program_480.py",
    "code": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "481",
    "filename": "program_481.py",
    "code": "def plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    var_0 = []\n    var_1 = 0\n    var_2 = len(digits) - 1\n    while var_2 >= 0 or var_1 == 1:\n        var_3 = 0\n        if var_2 >= 0:\n            var_3 += digits[var_2]\n        if var_1:\n            var_3 += 1\n        var_0.append(var_3 % 10)\n        var_1 = var_3 // 10\n        var_2 -= 1\n    return var_0[::-1]",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "482",
    "filename": "program_482.py",
    "code": "import re\n\ndef remove_uppercase(str1):\n    var_0 = lambda text: re.sub('[A-Z]', '', text)\n    var_1 = var_0(str1)\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "483",
    "filename": "program_483.py",
    "code": "def sum_range_list(list1, m, n):\n    var_0 = 0\n    for var_1 in range(m, n + 1, 1):\n        var_0 += list1[var_1]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "484",
    "filename": "program_484.py",
    "code": "import math\n\ndef round_up(a, digits):\n    var_0 = 10 ** (-digits)\n    return round(math.ceil(a / var_0) * var_0, digits)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "485",
    "filename": "program_485.py",
    "code": "def max_product(arr):\n    var_0 = len(arr)\n    if var_0 < 2:\n        return None\n    var_1 = arr[0]\n    var_2 = arr[1]\n    for var_3 in range(0, var_0):\n        for var_4 in range(var_3 + 1, var_0):\n            if arr[var_3] * arr[var_4] > var_1 * var_2:\n                var_1 = arr[var_3]\n                var_2 = arr[var_4]\n    return (var_1, var_2)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "486",
    "filename": "program_486.py",
    "code": "import re\n\ndef check_IP(Ip):\n    if re.search(regex, Ip):\n        return 'Valid IP address'\n    else:\n        return 'Invalid IP address'",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "487",
    "filename": "program_487.py",
    "code": "def check(n):\n    return 2 * rev(n) == n + 1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "488",
    "filename": "program_488.py",
    "code": "def remove_nested(test_tup):\n    var_0 = tuple()\n    for var_1, var_2 in enumerate(test_tup):\n        if not isinstance(var_2, tuple):\n            var_0 = var_0 + (var_2,)\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "489",
    "filename": "program_489.py",
    "code": "def find_max(test_list):\n    var_0 = max((int(j) for var_1 in test_list for var_2 in var_1))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "490",
    "filename": "program_490.py",
    "code": "def maximum_value(test_list):\n    var_0 = [(key, max(lst)) for var_1, var_2 in test_list]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "491",
    "filename": "program_491.py",
    "code": "def square_Sum(n):\n    return int(n * (4 * n * n - 1) / 3)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "492",
    "filename": "program_492.py",
    "code": "def check_monthnumb(monthname2):\n    if monthname2 == 'January' or monthname2 == 'March' or monthname2 == 'May' or (monthname2 == 'July') or (monthname2 == 'Augest') or (monthname2 == 'October') or (monthname2 == 'December'):\n        return True\n    else:\n        return False",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "493",
    "filename": "program_493.py",
    "code": "def left_rotate(s, d):\n    var_0 = s[d:] + s[0:d]\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "494",
    "filename": "program_494.py",
    "code": "def lcm(x, y):\n    if x > y:\n        var_0 = x\n    else:\n        var_0 = y\n    while True:\n        if var_0 % x == 0 and var_0 % y == 0:\n            var_1 = var_0\n            break\n        var_0 += 1\n    return var_1",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "495",
    "filename": "program_495.py",
    "code": "def warp(image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Warps the pixels of an image into a new image using the horizontal and vertical\n    flows.\n    Pixels that are warped from an invalid location are set to 0.\n\n    Parameters:\n        image: Grayscale image\n        horizontal_flow: Horizontal flow\n        vertical_flow: Vertical flow\n\n    Returns: Warped image\n\n    >>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]),     np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]),     np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))\n    array([[0, 0, 0],\n           [3, 1, 0],\n           [0, 2, 3]])\n    \"\"\"\n    var_0 = np.stack((horizontal_flow, vertical_flow), 2)\n    var_1 = np.stack(np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2)\n    var_1 = np.round(var_1 - var_0).astype(np.int32)\n    var_2 = (var_1 < 0) | (var_1 >= np.array([image.shape[1], image.shape[0]]))\n    var_1[var_2] = 0\n    var_3 = image[var_1[:, :, 1], var_1[:, :, 0]]\n    var_3[var_2[:, :, 0] | var_2[:, :, 1]] = 0\n    return var_3",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "496",
    "filename": "program_496.py",
    "code": "def logprob_specify_shape(op, values, inner_rv, *shapes, **kwargs):\n    var_0, = values\n    var_0 = pt.specify_shape(var_0, shapes)\n    return _logprob_helper(inner_rv, var_0)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "497",
    "filename": "program_497.py",
    "code": "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    var_0 = sum(map(eq, nums1, nums2))\n    return var_0",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "498",
    "filename": "program_498.py",
    "code": "def shell_sort(my_list):\n    var_0 = len(my_list) // 2\n    while var_0 > 0:\n        for var_1 in range(var_0, len(my_list)):\n            var_2 = my_list[var_1]\n            var_3 = var_1\n            while var_3 >= var_0 and my_list[var_3 - var_0] > var_2:\n                my_list[var_3] = my_list[var_3 - var_0]\n                var_3 -= var_0\n            my_list[var_3] = var_2\n        var_0 //= 2\n    return my_list",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "499",
    "filename": "program_499.py",
    "code": "def _find_noqa(physical_line: str) -> Match[str] | None:\n    return defaults.NOQA_INLINE_REGEXP.search(physical_line)",
    "transformation_type": "variable_naming",
    "transformation_error": null
  },
  {
    "task_id": "500",
    "filename": "program_500.py",
    "code": "def remove_negs(num_list):\n    for var_0 in num_list:\n        if var_0 < 0:\n            num_list.remove(var_0)\n    return num_list",
    "transformation_type": "variable_naming",
    "transformation_error": null
  }
]