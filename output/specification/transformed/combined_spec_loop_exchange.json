{
  "metadata": {
    "summary": {
      "total_programs": 124,
      "api_requests": 124,
      "cached_results": 0,
      "errors": 0,
      "success_rate": "100.0%"
    },
    "timing": {
      "total_duration_seconds": 1160.523,
      "total_duration_formatted": "19m 20.5s",
      "average_per_request_seconds": 9.359
    },
    "tokens": {
      "total": 259199,
      "input": 176797,
      "output": 82402,
      "average_per_request": 2090.3
    },
    "cost": {
      "total_usd": 1.01281,
      "average_per_request_usd": 0.008168,
      "cost_per_token_usd": 3.91e-06
    },
    "model": "gpt-4.1",
    "generation_timestamp": "2025-10-24T15:55:23.480564"
  },
  "specifications": [
    {
      "file_path": "program_002.py",
      "code": "def find_triplet_array(A, arr_size, sum):\n    i = 0\n    while i < arr_size - 2:\n        j = i + 1\n        while j < arr_size - 1:\n            k = j + 1\n            while k < arr_size:\n                if A[i] + A[j] + A[k] == sum:\n                    return (A[i], A[j], A[k])\n                    return True\n                k += 1\n            j += 1\n        i += 1\n    return False",
      "program_specification": "```dafny\nmethod FindTripletArray(A: array<int>, arr_size: int, target_sum: int) returns (found: bool, x: int, y: int, z: int)\n  requires A != null\n  requires 0 <= arr_size <= A.Length\n  ensures found ==> (exists i, j, k :: 0 <= i < j < k < arr_size && x == A[i] && y == A[j] && z == A[k] && x + y + z == target_sum)\n  ensures !found ==> (forall i, j, k :: 0 <= i < j < k < arr_size ==> A[i] + A[j] + A[k] != target_sum)\n{\n  var i := 0;\n  while i < arr_size - 2\n    invariant 0 <= i <= arr_size\n    decreases arr_size - i\n  {\n    var j := i + 1;\n    while j < arr_size - 1\n      invariant i + 1 <= j <= arr_size\n      decreases arr_size - j\n    {\n      var k := j + 1;\n      while k < arr_size\n        invariant j + 1 <= k <= arr_size\n        decreases arr_size - k\n      {\n        if A[i] + A[j] + A[k] == target_sum {\n          found := true;\n          x := A[i];\n          y := A[j];\n          z := A[k];\n          return;\n        }\n        k := k + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  found := false;\n  // x, y, z are arbitrary in this case\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.05,
        "duration_formatted": "7.05s",
        "tokens": {
          "input": 1380,
          "output": 359,
          "total": 1739
        },
        "cost_usd": 0.005632,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:25:44.652512"
      }
    },
    {
      "file_path": "program_006.py",
      "code": "def multi_list(rownum, colnum):\n    multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\n    row = 0\n    while row < rownum:\n        col = 0\n        while col < colnum:\n            multi_list[row][col] = row * col\n            col += 1\n        row += 1\n    return multi_list",
      "program_specification": "```dafny\nmethod MultiList(rownum: int, colnum: int) returns (multiList: array<array<int>>)\n  requires rownum >= 0\n  requires colnum >= 0\n  ensures multiList != null\n  ensures multiList.Length == rownum\n  ensures forall r :: 0 <= r < rownum ==> multiList[r] != null && multiList[r].Length == colnum\n  ensures forall r, c :: 0 <= r < rownum && 0 <= c < colnum ==> multiList[r][c] == r * c\n{\n  multiList := new array<array<int>>(rownum);\n  var row: int := 0;\n  while row < rownum\n    invariant 0 <= row <= rownum\n    invariant multiList != null\n    invariant forall r :: 0 <= r < row ==> multiList[r] != null && multiList[r].Length == colnum\n    invariant forall r, c :: 0 <= r < row && 0 <= c < colnum ==> multiList[r][c] == r * c\n    decreases rownum - row\n  {\n    var inner := new int[colnum];\n    var col: int := 0;\n    while col < colnum\n      invariant 0 <= col <= colnum\n      invariant forall c' :: 0 <= c' < col ==> inner[c'] == row * c'\n      decreases colnum - col\n    {\n      inner[col] := row * col;\n      col := col + 1;\n    }\n    multiList[row] := inner;\n    row := row + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.505,
        "duration_formatted": "5.51s",
        "tokens": {
          "input": 1349,
          "output": 345,
          "total": 1694
        },
        "cost_usd": 0.005458,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:25:55.189161"
      }
    },
    {
      "file_path": "program_010.py",
      "code": "def count_char(string, char):\n    count = 0\n    i = 0\n    while i < len(string):\n        if string[i] == char:\n            count = count + 1\n        i += 1\n    return count",
      "program_specification": "```dafny\nmethod CountChar(s: seq<char>, c: char) returns (count: int)\n  ensures count >= 0\n  ensures count == |[i | i := 0 .. |s|, s[i] == c]|\n{\n  count := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant count == |[j | j := 0 .. i, s[j] == c]|\n    decreases |s| - i\n  {\n    if s[i] == c {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.585,
        "duration_formatted": "2.58s",
        "tokens": {
          "input": 1317,
          "output": 146,
          "total": 1463
        },
        "cost_usd": 0.003802,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:26:02.810133"
      }
    },
    {
      "file_path": "program_011.py",
      "code": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    i = 0\n    while i < len(array) - 2:\n        if i > 0 and array[i] == array[i - 1]:\n            continue\n        l, r = (i + 1, len(array) - 1)\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if s > 0:\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                res.add((array[i], array[l], array[r]))\n                while l < r and array[l] == array[l + 1]:\n                    l += 1\n                while l < r and array[r] == array[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n        i += 1\n    return res",
      "program_specification": "```dafny\nmethod ThreeSum(array: array<int>) returns (res: set<seq<int>>)\n  requires array != null\n  ensures forall t: seq<int> :: t in res ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n{\n  // Copy array to a sequence and sort it\n  var n := array.Length;\n  var a := array[..];\n  a := SortSeq(a);\n\n  res := {};\n\n  var i: int := 0;\n  while i < n - 2\n    invariant 0 <= i <= n - 2 || n < 2\n    invariant forall t: seq<int> :: t in res ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n    decreases n - i\n  {\n    if i > 0 && a[i] == a[i - 1] {\n      i := i + 1;\n      continue;\n    }\n    var l: int := i + 1;\n    var r: int := n - 1;\n    while l < r\n      invariant i + 1 <= l <= r + 1 <= n\n      invariant forall t: seq<int> :: t in res ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n      decreases r - l\n    {\n      var s := a[i] + a[l] + a[r];\n      if s > 0 {\n        r := r - 1;\n      } else if s < 0 {\n        l := l + 1;\n      } else {\n        res := res + {[a[i], a[l], a[r]]};\n        while l < r && a[l] == a[l + 1]\n          invariant i + 1 <= l <= r <= n - 1\n          decreases r - l\n        {\n          l := l + 1;\n        }\n        while l < r && a[r] == a[r - 1]\n          invariant i + 1 <= l <= r <= n - 1\n          decreases r - l\n        {\n          r := r - 1;\n        }\n        l := l + 1;\n        r := r - 1;\n      }\n    }\n    i := i + 1;\n  }\n}\n\n// Helper: returns a sorted sequence (ascending)\nfunction SortSeq(s: seq<int>): seq<int>\n  ensures |SortSeq(s)| == |s|\n  ensures multiset(SortSeq(s)) == multiset(s)\n  ensures forall j: int :: 0 <= j < |SortSeq(s)| - 1 ==> SortSeq(s)[j] <= SortSeq(s)[j + 1]\n{\n  if |s| <= 1 then s\n  else\n    var pivot := s[0];\n    SortSeq([x | x := s[1..], x < pivot]) +\n    [pivot] +\n    SortSeq([x | x := s[1..], x >= pivot])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.09,
        "duration_formatted": "9.09s",
        "tokens": {
          "input": 1488,
          "output": 650,
          "total": 2138
        },
        "cost_usd": 0.008176,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:26:16.942510"
      }
    },
    {
      "file_path": "program_015.py",
      "code": "def min_Swaps(s1, s2):\n    c0 = 0\n    c1 = 0\n    i = 0\n    while i < len(s1):\n        if s1[i] == '0' and s2[i] == '1':\n            c0 += 1\n        elif s1[i] == '1' and s2[i] == '0':\n            c1 += 1\n        i += 1\n    result = c0 // 2 + c1 // 2\n    if c0 % 2 == 0 and c1 % 2 == 0:\n        return result\n    elif (c0 + c1) % 2 == 0:\n        return result + 2\n    else:\n        return -1",
      "program_specification": "```dafny\nmethod MinSwaps(s1: seq<char>, s2: seq<char>) returns (res: int)\n  requires |s1| == |s2|\n  ensures res == -1 || res >= 0\n{\n  var c0 := 0;\n  var c1 := 0;\n  var i := 0;\n  while i < |s1|\n    invariant 0 <= i <= |s1|\n    invariant c0 >= 0 && c1 >= 0\n    invariant c0 == (|j: 0 <= j < i && s1[j] == '0' && s2[j] == '1'|)\n    invariant c1 == (|j: 0 <= j < i && s1[j] == '1' && s2[j] == '0'|)\n    decreases |s1| - i\n  {\n    if s1[i] == '0' && s2[i] == '1' {\n      c0 := c0 + 1;\n    } else if s1[i] == '1' && s2[i] == '0' {\n      c1 := c1 + 1;\n    }\n    i := i + 1;\n  }\n  var result := c0 / 2 + c1 / 2;\n  if c0 % 2 == 0 && c1 % 2 == 0 {\n    res := result;\n  } else if (c0 + c1) % 2 == 0 {\n    res := result + 2;\n  } else {\n    res := -1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.861,
        "duration_formatted": "3.86s",
        "tokens": {
          "input": 1432,
          "output": 340,
          "total": 1772
        },
        "cost_usd": 0.005584,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:26:25.852884"
      }
    },
    {
      "file_path": "program_018.py",
      "code": "def first_Element(arr, n, k):\n    count_map = {}\n    i = 0\n    while i < n:\n        if arr[i] in count_map.keys():\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        i += 1\n        i += 1\n    i = 0\n    while i < n:\n        if count_map[arr[i]] == k:\n            return arr[i]\n        i += 1\n        i += 1\n    return -1",
      "program_specification": "```dafny\nmethod FirstElement(arr: array<int>, n: int, k: int) returns (res: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  requires k > 0\n  ensures (exists i :: 0 <= i < n && (|seq j | 0 <= j < n && arr[j] == arr[i]|) == k) ==> (exists i :: 0 <= i < n && (|seq j | 0 <= j < n && arr[j] == arr[i]|) == k && res == arr[i])\n  ensures (forall i :: 0 <= i < n ==> (|seq j | 0 <= j < n && arr[j] == arr[i]|) != k) ==> res == -1\n{\n  // Build count map: for each value, count occurrences in arr[0..n)\n  var count := map<int, int>{};\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall v: int :: v in count ==> count[v] == (|seq j | 0 <= j < i && arr[j] == v|)\n    decreases n - i\n  {\n    var v := arr[i];\n    if v in count {\n      count := count[v := count[v] + 1];\n    } else {\n      count := count[v := 1];\n    }\n    i := i + 1;\n    i := i + 1;\n  }\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    if count[arr[i]] == k {\n      res := arr[i];\n      return;\n    }\n    i := i + 1;\n    i := i + 1;\n  }\n  res := -1;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.069,
        "duration_formatted": "7.07s",
        "tokens": {
          "input": 1380,
          "output": 394,
          "total": 1774
        },
        "cost_usd": 0.005912,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:26:37.959762"
      }
    },
    {
      "file_path": "program_019.py",
      "code": "def count_no(A, N, L, R):\n    count = 0\n    i = L\n    while i < R + 1:\n        if i % A != 0:\n            count += 1\n        if count == N:\n            break\n        i += 1\n    return i",
      "program_specification": "```dafny\nmethod CountNo(A: int, N: int, L: int, R: int) returns (res: int)\n  requires A != 0\n  requires N >= 0\n  requires L <= R\n  ensures L <= res <= R + 1\n  ensures (exists k :: L <= k <= R + 1 && (|seq j: int {:trigger L <= j < k} :: L <= j < k && j % A != 0|) == N && res == k)\n  ensures (res <= R) ==> (|seq j: int {:trigger L <= j < res} :: L <= j < res && j % A != 0|) == N\n  ensures (res > R) ==> (|seq j: int {:trigger L <= j <= R} :: L <= j <= R && j % A != 0|) < N\n{\n  var count := 0;\n  var i := L;\n  while i < R + 1\n    invariant L <= i <= R + 1\n    invariant 0 <= count <= N\n    invariant count == |seq j: int {:trigger L <= j < i} :: L <= j < i && j % A != 0|\n    decreases R + 1 - i\n  {\n    if i % A != 0 {\n      count := count + 1;\n    }\n    if count == N {\n      break;\n    }\n    i := i + 1;\n  }\n  res := i;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.871,
        "duration_formatted": "4.87s",
        "tokens": {
          "input": 1330,
          "output": 323,
          "total": 1653
        },
        "cost_usd": 0.005244,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:26:47.869432"
      }
    },
    {
      "file_path": "program_020.py",
      "code": "def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    i = 0\n    while i < len(cells):\n        next_generation_row = []\n        j = 0\n        while j < len(cells[i]):\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n            alive = cells[i][j] == 1\n            if alive and 2 <= neighbour_count <= 3 or (not alive and neighbour_count == 3):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n            j += 1\n        next_generation.append(next_generation_row)\n        i += 1\n    return next_generation",
      "program_specification": "```dafny\nmethod NewGeneration(cells: array<array<int>>) returns (nextGeneration: array<array<int>>)\n  requires cells != null\n  requires forall i :: 0 <= i < cells.Length ==> cells[i] != null\n  requires cells.Length > 0\n  requires forall i :: 0 <= i < cells.Length ==> cells[i].Length > 0\n  requires forall i :: 0 <= i < cells.Length ==> forall j :: 0 <= j < cells[i].Length ==> cells[i][j] == 0 || cells[i][j] == 1\n  ensures nextGeneration != null\n  ensures nextGeneration.Length == cells.Length\n  ensures forall i :: 0 <= i < cells.Length ==> nextGeneration[i] != null && nextGeneration[i].Length == cells[i].Length\n  ensures forall i, j :: 0 <= i < cells.Length && 0 <= j < cells[i].Length ==> nextGeneration[i][j] == 0 || nextGeneration[i][j] == 1\n{\n  var m := cells.Length;\n  var n := cells[0].Length;\n  // Allocate result\n  nextGeneration := new array<array<int>>(m);\n  var i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    invariant nextGeneration != null\n    invariant forall k :: 0 <= k < i ==> nextGeneration[k] != null && nextGeneration[k].Length == n\n    invariant forall k :: 0 <= k < i ==> forall j :: 0 <= j < n ==> nextGeneration[k][j] == 0 || nextGeneration[k][j] == 1\n    decreases m - i\n  {\n    var row := new array<int>(n);\n    var j := 0;\n    while j < n\n      invariant 0 <= j <= n\n      invariant row != null && row.Length == n\n      invariant forall l :: 0 <= l < j ==> row[l] == 0 || row[l] == 1\n      decreases n - j\n    {\n      var neighbourCount := 0;\n      // Top-left\n      if i > 0 && j > 0 {\n        neighbourCount := neighbourCount + cells[i-1][j-1];\n      }\n      // Top\n      if i > 0 {\n        neighbourCount := neighbourCount + cells[i-1][j];\n      }\n      // Top-right\n      if i > 0 && j < n - 1 {\n        neighbourCount := neighbourCount + cells[i-1][j+1];\n      }\n      // Left\n      if j > 0 {\n        neighbourCount := neighbourCount + cells[i][j-1];\n      }\n      // Right\n      if j < n - 1 {\n        neighbourCount := neighbourCount + cells[i][j+1];\n      }\n      // Bottom-left\n      if i < m - 1 && j > 0 {\n        neighbourCount := neighbourCount + cells[i+1][j-1];\n      }\n      // Bottom\n      if i < m - 1 {\n        neighbourCount := neighbourCount + cells[i+1][j];\n      }\n      // Bottom-right\n      if i < m - 1 && j < n - 1 {\n        neighbourCount := neighbourCount + cells[i+1][j+1];\n      }\n      var alive := cells[i][j] == 1;\n      if (alive && 2 <= neighbourCount && neighbourCount <= 3) || (!alive && neighbourCount == 3) {\n        row[j] := 1;\n      } else {\n        row[j] := 0;\n      }\n      j := j + 1;\n    }\n    nextGeneration[i] := row;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.668,
        "duration_formatted": "7.67s",
        "tokens": {
          "input": 1679,
          "output": 795,
          "total": 2474
        },
        "cost_usd": 0.009718,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:27:00.574311"
      }
    },
    {
      "file_path": "program_024.py",
      "code": "def octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not octal_number:\n        raise ValueError('Empty string was passed to the function')\n    binary_number = ''\n    octal_digits = '01234567'\n    for digit in octal_number:\n        if digit not in octal_digits:\n            raise ValueError('Non-octal value was passed to the function')\n        binary_digit = ''\n        value = int(digit)\n        _ = 0\n        while _ < 3:\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n            _ += 1\n        binary_number += binary_digit\n    return binary_number",
      "program_specification": "```dafny\nmethod OctalToBinary(octalNumber: seq<char>) returns (binaryNumber: seq<char>)\n  requires |octalNumber| > 0\n  requires forall i :: 0 <= i < |octalNumber| ==> '0' <= octalNumber[i] <= '7'\n  ensures |binaryNumber| == 3 * |octalNumber|\n  ensures forall i :: 0 <= i < |octalNumber| ==>\n    (var d := octalNumber[i] as int - '0' as int;\n     var b := binaryNumber[3*i..3*(i+1)];\n     b == ToBinary3(d))\n{\n  var n := |octalNumber|;\n  var res: seq<char> := [];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant |res| == 3 * i\n    invariant forall j :: 0 <= j < i ==>\n      (var d := octalNumber[j] as int - '0' as int;\n       var b := res[3*j..3*(j+1)];\n       b == ToBinary3(d))\n    decreases n - i\n  {\n    var d := octalNumber[i] as int - '0' as int;\n    var b := ToBinary3(d);\n    res := res + b;\n    i := i + 1;\n  }\n  binaryNumber := res;\n}\n\nfunction ToBinary3(d: int): seq<char>\n  requires 0 <= d <= 7\n  ensures |ToBinary3(d)| == 3\n  ensures forall k :: 0 <= k < 3 ==>\n    (ToBinary3(d)[k] == if ((d >> (2 - k)) & 1) == 1 then '1' else '0')\n{\n  [ if ((d >> 2) & 1) == 1 then '1' else '0',\n    if ((d >> 1) & 1) == 1 then '1' else '0',\n    if ((d >> 0) & 1) == 1 then '1' else '0' ]\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.659,
        "duration_formatted": "7.66s",
        "tokens": {
          "input": 1548,
          "output": 460,
          "total": 2008
        },
        "cost_usd": 0.006776,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:27:13.287265"
      }
    },
    {
      "file_path": "program_025.py",
      "code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum(lines) for lines in my_matrix])\n    col = 0\n    while col < iSize:\n        sum_list.append(sum((row[col] for row in my_matrix)))\n        col += 1\n    result1 = 0\n    i = 0\n    while i < iSize:\n        result1 += my_matrix[i][i]\n        i += 1\n    sum_list.append(result1)\n    result2 = 0\n    i = iSize - 1\n    while i > -1:\n        result2 += my_matrix[i][i]\n        i += -1\n    sum_list.append(result2)\n    if len(set(sum_list)) > 1:\n        return False\n    return True",
      "program_specification": "```dafny\nmethod MagicSquareTest(my_matrix: array<array<int>>) returns (is_magic: bool)\n  requires my_matrix != null\n  requires my_matrix.Length > 0\n  requires forall i :: 0 <= i < my_matrix.Length ==> my_matrix[i] != null\n  requires forall i :: 0 <= i < my_matrix.Length ==> my_matrix[i].Length == my_matrix[0].Length\n  ensures is_magic ==> my_matrix.Length == my_matrix[0].Length // Only squares can be magic squares\n  ensures is_magic ==> (forall r: int, c: int :: \n      0 <= r < my_matrix.Length && 0 <= c < my_matrix[0].Length ==>\n        (SumRow(my_matrix, r) == SumCol(my_matrix, c) == SumDiag1(my_matrix) == SumDiag2(my_matrix)))\n{\n  var n := my_matrix[0].Length;\n  var m := my_matrix.Length;\n  // Only square matrices can be magic squares\n  if m != n {\n    is_magic := false;\n    return;\n  }\n  var sum_list := new int[2 * n + 2];\n  var idx := 0;\n\n  // Sum of each row\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant idx == i\n    invariant sum_list.Length == 2 * n + 2\n    decreases n - i\n  {\n    var row_sum := 0;\n    var j := 0;\n    while j < n\n      invariant 0 <= j <= n\n      invariant row_sum == SumRowPartial(my_matrix, i, j)\n      decreases n - j\n    {\n      row_sum := row_sum + my_matrix[i][j];\n      j := j + 1;\n    }\n    sum_list[idx] := row_sum;\n    idx := idx + 1;\n    i := i + 1;\n  }\n\n  // Sum of each column\n  var col := 0;\n  while col < n\n    invariant 0 <= col <= n\n    invariant idx == n + col\n    decreases n - col\n  {\n    var col_sum := 0;\n    var row := 0;\n    while row < n\n      invariant 0 <= row <= n\n      invariant col_sum == SumColPartial(my_matrix, col, row)\n      decreases n - row\n    {\n      col_sum := col_sum + my_matrix[row][col];\n      row := row + 1;\n    }\n    sum_list[idx] := col_sum;\n    idx := idx + 1;\n    col := col + 1;\n  }\n\n  // Main diagonal\n  var diag1 := 0;\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant diag1 == SumDiag1Partial(my_matrix, i)\n    decreases n - i\n  {\n    diag1 := diag1 + my_matrix[i][i];\n    i := i + 1;\n  }\n  sum_list[idx] := diag1;\n  idx := idx + 1;\n\n  // Anti-diagonal\n  var diag2 := 0;\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant diag2 == SumDiag2Partial(my_matrix, i)\n    decreases n - i\n  {\n    diag2 := diag2 + my_matrix[i][n - 1 - i];\n    i := i + 1;\n  }\n  sum_list[idx] := diag2;\n  idx := idx + 1;\n\n  // Check if all sums are equal\n  var all_equal := true;\n  var k := 1;\n  while k < sum_list.Length\n    invariant 1 <= k <= sum_list.Length\n    invariant all_equal ==> (forall t: int :: 1 <= t < k ==> sum_list[t] == sum_list[0])\n    decreases sum_list.Length - k\n  {\n    if sum_list[k] != sum_list[0] {\n      all_equal := false;\n    }\n    k := k + 1;\n  }\n  is_magic := all_equal;\n}\n\n// Helper: sum of row r\nfunction method SumRow(m: array<array<int>>, r: int): int\n  requires m != null && 0 <= r < m.Length\n  requires m[r] != null && m[r].Length == m[0].Length\n  ensures 0 <= r < m.Length ==> SumRow(m, r) == (if m[0].Length == 0 then 0 else (sum i: int | 0 <= i < m[0].Length :: m[r][i]))\n{\n  if m[0].Length == 0 then 0 else (sum i: int | 0 <= i < m[0].Length :: m[r][i])\n}\n\n// Helper: sum of column c\nfunction method SumCol(m: array<array<int>>, c: int): int\n  requires m != null && m.Length > 0 && 0 <= c < m[0].Length\n  requires forall i :: 0 <= i < m.Length ==> m[i] != null && m[i].Length == m[0].Length\n  ensures 0 <= c < m[0].Length ==> (if m.Length == 0 then 0 else (sum i: int | 0 <= i < m.Length :: m[i][c]))\n{\n  if m.Length == 0 then 0 else (sum i: int | 0 <= i < m.Length :: m[i][c])\n}\n\n// Helper: sum of main diagonal\nfunction method SumDiag1(m: array<array<int>>): int\n  requires m != null && m.Length > 0 && m.Length == m[0].Length\n  requires forall i :: 0 <= i < m.Length ==> m[i] != null && m[i].Length == m[0].Length\n  ensures SumDiag1(m) == (if m.Length == 0 then 0 else (sum i: int | 0 <= i < m.Length :: m[i][i]))\n{\n  if m.Length == 0 then 0 else (sum i: int | 0 <= i < m.Length :: m[i][i])\n}\n\n// Helper: sum of anti-diagonal\nfunction method SumDiag2(m: array<array<int>>): int\n  requires m != null && m.Length > 0 && m.Length == m[0].Length\n  requires forall i :: 0 <= i < m.Length ==> m[i] != null && m[i].Length == m[0].Length\n  ensures SumDiag2(m) == (if m.Length == 0 then 0 else (sum i: int | 0 <= i < m.Length :: m[i][m.Length - 1 - i]))\n{\n  if m.Length == 0 then 0 else (sum i: int | 0 <= i < m.Length :: m[i][m.Length - 1 - i])\n}\n\n// Partial sum helpers for loop invariants\nfunction method SumRowPartial(m: array<array<int>>, r: int, upto: int): int\n  requires m != null && 0 <= r < m.Length\n  requires m[r] != null && m[r].Length >= upto\n  ensures SumRowPartial(m, r, upto) == (if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[r][i]))\n{\n  if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[r][i])\n}\n\nfunction method SumColPartial(m: array<array<int>>, c: int, upto: int): int\n  requires m != null && m.Length >= upto && 0 <= c < m[0].Length\n  requires forall i :: 0 <= i < upto ==> m[i] != null && m[i].Length > c\n  ensures SumColPartial(m, c, upto) == (if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[i][c]))\n{\n  if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[i][c])\n}\n\nfunction method SumDiag1Partial(m: array<array<int>>, upto: int): int\n  requires m != null && m.Length >= upto\n  requires forall i :: 0 <= i < upto ==> m[i] != null && m[i].Length > i\n  ensures SumDiag1Partial(m, upto) == (if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[i][i]))\n{\n  if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[i][i])\n}\n\nfunction method SumDiag2Partial(m: array<array<int>>, upto: int): int\n  requires m != null && m.Length >= upto\n  requires forall i :: 0 <= i < upto ==> m[i] != null && m[i].Length > m.Length - 1 - i\n  ensures SumDiag2Partial(m, upto) == (if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[i][m.Length - 1 - i]))\n{\n  if upto == 0 then 0 else (sum i: int | 0 <= i < upto :: m[i][m.Length - 1 - i])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 34.937,
        "duration_formatted": "34.94s",
        "tokens": {
          "input": 1443,
          "output": 2008,
          "total": 3451
        },
        "cost_usd": 0.01895,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:27:53.274932"
      }
    },
    {
      "file_path": "program_027.py",
      "code": "def remove_odd(str1):\n    str2 = ''\n    i = 1\n    while i < len(str1) + 1:\n        if i % 2 == 0:\n            str2 = str2 + str1[i - 1]\n        i += 1\n    return str2",
      "program_specification": "```dafny\nmethod RemoveOdd(str1: seq<char>) returns (str2: seq<char>)\n  ensures |str2| <= |str1|\n  ensures forall i :: 0 <= i < |str2| ==> str2[i] == str1[2 * i + 1]\n  ensures |str2| == if |str1| % 2 == 0 then |str1| / 2 else |str1| / 2\n{\n  var acc := [];\n  var i := 1;\n  while i < |str1| + 1\n    invariant 1 <= i <= |str1| + 1\n    invariant |acc| == (i - 1) / 2\n    invariant forall j :: 0 <= j < |acc| ==> acc[j] == str1[2 * j + 1]\n    decreases |str1| + 1 - i\n  {\n    if i % 2 == 0 {\n      acc := acc + [str1[i - 1]];\n    }\n    i := i + 1;\n  }\n  str2 := acc;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.567,
        "duration_formatted": "3.57s",
        "tokens": {
          "input": 1330,
          "output": 238,
          "total": 1568
        },
        "cost_usd": 0.004564,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:28:01.900597"
      }
    },
    {
      "file_path": "program_028.py",
      "code": "def max_Product(arr):\n    arr_len = len(arr)\n    if arr_len < 2:\n        return 'No pairs exists'\n    x = arr[0]\n    y = arr[1]\n    i = 0\n    while i < arr_len:\n        j = i + 1\n        while j < arr_len:\n            if arr[i] * arr[j] > x * y:\n                x = arr[i]\n                y = arr[j]\n            j += 1\n        i += 1\n    return (x, y)",
      "program_specification": "```dafny\nmethod MaxProduct(arr: array<int>) returns (res: (int, int))\n  requires arr != null\n  ensures arr.Length < 2 ==> res.0 == 0 && res.1 == 0\n  ensures arr.Length >= 2 ==>\n    (exists i, j :: 0 <= i < j < arr.Length && (res.0 == arr[i] && res.1 == arr[j] || res.0 == arr[j] && res.1 == arr[i]))\n  ensures arr.Length >= 2 ==>\n    (forall i, j :: 0 <= i < j < arr.Length ==>\n      res.0 * res.1 >= arr[i] * arr[j])\n{\n  if arr.Length < 2 {\n    // No pairs exist; return a default value (0,0)\n    res := (0, 0);\n    return;\n  }\n  var x := arr[0];\n  var y := arr[1];\n  var i := 0;\n  while i < arr.Length\n    invariant 0 <= i <= arr.Length\n    invariant arr.Length >= 2 ==> (exists ii, jj :: 0 <= ii < jj < arr.Length && (x == arr[ii] && y == arr[jj] || x == arr[jj] && y == arr[ii]))\n    invariant arr.Length >= 2 ==> (forall ii, jj :: 0 <= ii < jj < i ==> x * y >= arr[ii] * arr[jj])\n    decreases arr.Length - i\n  {\n    var j := i + 1;\n    while j < arr.Length\n      invariant i + 1 <= j <= arr.Length\n      invariant arr.Length >= 2 ==> (forall jj :: i + 1 <= jj < j ==> x * y >= arr[i] * arr[jj])\n      decreases arr.Length - j\n    {\n      if arr[i] * arr[j] > x * y {\n        x := arr[i];\n        y := arr[j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := (x, y);\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.817,
        "duration_formatted": "6.82s",
        "tokens": {
          "input": 1379,
          "output": 450,
          "total": 1829
        },
        "cost_usd": 0.006358,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:28:13.760237"
      }
    },
    {
      "file_path": "program_032.py",
      "code": "def common_prefix(arr, n):\n    prefix = arr[0]\n    i = 1\n    while i < n:\n        prefix = common_prefix_util(prefix, arr[i])\n        i += 1\n    return prefix",
      "program_specification": "```dafny\nmethod CommonPrefix(arr: array<string>, n: int) returns (prefix: string)\n  requires arr != null\n  requires 1 <= n <= arr.Length\n  ensures forall i: int :: 0 <= i < n ==> arr[i].StartsWith(prefix)\n{\n  prefix := arr[0];\n  var i := 1;\n  while i < n\n    invariant 1 <= n <= arr.Length\n    invariant 1 <= i <= n\n    invariant forall j: int :: 0 <= j < i ==> arr[j].StartsWith(prefix)\n    decreases n - i\n  {\n    prefix := CommonPrefixUtil(prefix, arr[i]);\n    i := i + 1;\n  }\n}\n\nmethod CommonPrefixUtil(a: string, b: string) returns (res: string)\n  ensures res == a[..|res|] && res == b[..|res|]\n  ensures forall i: int :: 0 <= i < |res| ==> a[i] == b[i]\n  ensures |res| <= |a| && |res| <= |b|\n{\n  var minLen := if |a| < |b| then |a| else |b|;\n  var i := 0;\n  while i < minLen && a[i] == b[i]\n    invariant 0 <= i <= minLen\n    invariant forall j: int :: 0 <= j < i ==> a[j] == b[j]\n    decreases minLen - i\n  {\n    i := i + 1;\n  }\n  res := a[..i];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.16,
        "duration_formatted": "5.16s",
        "tokens": {
          "input": 1312,
          "output": 329,
          "total": 1641
        },
        "cost_usd": 0.005256,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:28:23.962838"
      }
    },
    {
      "file_path": "program_033.py",
      "code": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0 for i in range(n + 1)] for j in range(k + 1)]\n    i = 1\n    while i < k + 1:\n        j = 1\n        while j < n + 1:\n            dp[i][j] = dp[i][j - 1]\n            if arr[j - 1] <= i and arr[j - 1] > 0:\n                dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n            j += 1\n        i += 1\n    return dp[k][n]",
      "program_specification": "```dafny\nmethod NoOfSubsequences(arr: array<int>, k: int) returns (count: int)\n  requires arr != null\n  requires k >= 0\n  ensures count >= 0\n{\n  var n := arr.Length;\n  var dp := new int[k + 1][];\n  var i: int := 0;\n  while i < k + 1\n    invariant 0 <= i <= k + 1\n    invariant dp != null && dp.Length == k + 1\n    decreases k + 1 - i\n  {\n    dp[i] := new int[n + 1];\n    i := i + 1;\n  }\n\n  i := 1;\n  while i < k + 1\n    invariant 1 <= i <= k + 1\n    decreases k + 1 - i\n  {\n    var j: int := 1;\n    while j < n + 1\n      invariant 1 <= j <= n + 1\n      decreases n + 1 - j\n    {\n      dp[i][j] := dp[i][j - 1];\n      if 0 < arr[j - 1] <= i {\n        var idx := i / arr[j - 1];\n        dp[i][j] := dp[i][j] + dp[idx][j - 1] + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  count := dp[k][n];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.82,
        "duration_formatted": "4.82s",
        "tokens": {
          "input": 1414,
          "output": 319,
          "total": 1733
        },
        "cost_usd": 0.00538,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:28:33.824946"
      }
    },
    {
      "file_path": "program_034.py",
      "code": "def swap_count(s):\n    chars = s\n    count_left = 0\n    count_right = 0\n    swap = 0\n    imbalance = 0\n    i = 0\n    while i < len(chars):\n        if chars[i] == '[':\n            count_left += 1\n            if imbalance > 0:\n                swap += imbalance\n                imbalance -= 1\n        elif chars[i] == ']':\n            count_right += 1\n            imbalance = count_right - count_left\n        i += 1\n    return swap",
      "program_specification": "```dafny\nmethod SwapCount(s: seq<char>) returns (swap: int)\n  ensures swap >= 0\n  ensures swap == 0 ==> (forall i :: 0 <= i < |s| ==> (|[j | 0 <= j <= i && s[j] == '['|) >= |[j | 0 <= j <= i && s[j] == ']'|))\n{\n  var count_left := 0;\n  var count_right := 0;\n  swap := 0;\n  var imbalance := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant count_left >= 0 && count_right >= 0 && imbalance >= 0\n    invariant swap >= 0\n    decreases |s| - i\n  {\n    if s[i] == '[' {\n      count_left := count_left + 1;\n      if imbalance > 0 {\n        swap := swap + imbalance;\n        imbalance := imbalance - 1;\n      }\n    } else if s[i] == ']' {\n      count_right := count_right + 1;\n      imbalance := count_right - count_left;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.436,
        "duration_formatted": "3.44s",
        "tokens": {
          "input": 1381,
          "output": 260,
          "total": 1641
        },
        "cost_usd": 0.004842,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:28:42.302674"
      }
    },
    {
      "file_path": "program_041.py",
      "code": "def count_bidirectional(test_list):\n    res = 0\n    idx = 0\n    while idx < len(test_list):\n        iidx = idx + 1\n        while iidx < len(test_list):\n            if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n                res += 1\n            iidx += 1\n        idx += 1\n    return str(res)",
      "program_specification": "```dafny\nmethod CountBidirectional(testList: seq<seq<int>>) returns (resStr: string)\n  requires forall pair :: pair in testList ==> |pair| >= 2\n  ensures resStr == resCountBidirectional(testList)\n{\n  var res := 0;\n  var idx := 0;\n  while idx < |testList|\n    invariant 0 <= idx <= |testList|\n    invariant res == countBidirectionalPairs(testList, idx)\n    decreases |testList| - idx\n  {\n    var iidx := idx + 1;\n    while iidx < |testList|\n      invariant idx + 1 <= iidx <= |testList|\n      invariant res == countBidirectionalPairs(testList, idx, iidx)\n      decreases |testList| - iidx\n    {\n      if testList[iidx][0] == testList[idx][1] && testList[idx][1] == testList[iidx][0] {\n        res := res + 1;\n      }\n      iidx := iidx + 1;\n    }\n    idx := idx + 1;\n  }\n  resStr := res.ToString();\n}\n\nfunction resCountBidirectional(testList: seq<seq<int>>): string\n  requires forall pair :: pair in testList ==> |pair| >= 2\n{\n  countBidirectionalPairsFinal(testList).ToString()\n}\n\nfunction countBidirectionalPairsFinal(testList: seq<seq<int>>): int\n  requires forall pair :: pair in testList ==> |pair| >= 2\n{\n  if |testList| == 0 then 0\n  else countBidirectionalPairs(testList, |testList|)\n}\n\nfunction countBidirectionalPairs(testList: seq<seq<int>>, upTo: int): int\n  requires 0 <= upTo <= |testList|\n  requires forall pair :: pair in testList ==> |pair| >= 2\n{\n  if upTo == 0 then 0\n  else countBidirectionalPairs(testList, upTo - 1) + countBidirectionalPairs(testList, upTo - 1, upTo)\n}\n\nfunction countBidirectionalPairs(testList: seq<seq<int>>, idx: int, iidx: int): int\n  requires 0 <= idx <= |testList|\n  requires idx <= iidx <= |testList|\n  requires forall pair :: pair in testList ==> |pair| >= 2\n{\n  if iidx == idx then 0\n  else\n    countBidirectionalPairs(testList, idx, iidx - 1) +\n    (if testList[iidx - 1][0] == testList[idx - 1][1] && testList[idx - 1][1] == testList[iidx - 1][0] then 1 else 0)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.891,
        "duration_formatted": "8.89s",
        "tokens": {
          "input": 1365,
          "output": 594,
          "total": 1959
        },
        "cost_usd": 0.007482,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:28:56.254771"
      }
    },
    {
      "file_path": "program_042.py",
      "code": "def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n    i = 0\n    while i < len(text):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n        i += 1\n    return encoded",
      "program_specification": "```dafny\nmethod RunLengthEncode(text: seq<char>) returns (encoded: seq<(char, int)>)\n  ensures |encoded| >= 0\n  ensures forall t: int :: 0 <= t < |encoded| ==> encoded[t].1 != ' '\n  ensures forall t: int :: 0 <= t < |encoded| ==> encoded[t].2 > 0\n  ensures |text| == 0 ==> |encoded| == 0\n  // Each run in encoded represents a maximal consecutive block of the same character in text\n  // The concatenation of runs reconstructs text\n  ensures\n    var recon: seq<char> := [];\n    (forall t: int :: 0 <= t < |encoded| ==> recon := recon + [encoded[t].1] * encoded[t].2);\n    recon == text\n{\n  var n := |text|;\n  var res: seq<(char, int)> := [];\n  if n == 0 {\n    encoded := res;\n    return;\n  }\n  var i: int := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant |res| >= 0\n    invariant\n      var recon: seq<char> := [];\n      (forall t: int :: 0 <= t < |res| ==> recon := recon + [res[t].1] * res[t].2);\n      recon + (if i < n then [text[i]] else []) * (if i < n then 1 else 0) <= text[..i+1]\n    decreases n - i\n  {\n    var count := 1;\n    while i + count < n && text[i] == text[i + count]\n      invariant 1 <= count <= n - i\n      invariant forall k: int :: 0 <= k < count ==> text[i] == text[i + k]\n      decreases n - (i + count)\n    {\n      count := count + 1;\n    }\n    res := res + [(text[i], count)];\n    i := i + count;\n  }\n  encoded := res;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.892,
        "duration_formatted": "9.89s",
        "tokens": {
          "input": 1492,
          "output": 437,
          "total": 1929
        },
        "cost_usd": 0.00648,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:29:11.186699"
      }
    },
    {
      "file_path": "program_044.py",
      "code": "def find_demlo(s):\n    l = len(s)\n    res = ''\n    i = 1\n    while i < l + 1:\n        res = res + str(i)\n        i += 1\n    i = l - 1\n    while i > 0:\n        res = res + str(i)\n        i += -1\n    return res",
      "program_specification": "```dafny\nmethod FindDemlo(s: seq<char>) returns (res: seq<char>)\n  ensures |res| == 2 * |s| - 1\n  ensures forall i :: 0 <= i < |s| ==> res[i] == ('0' as char) + i + 1\n  ensures forall i :: 0 <= i < |s| - 1 ==> res[|s| + i] == ('0' as char) + |s| - (i + 1)\n{\n  var l := |s|;\n  var r := [];\n  var i := 1;\n  while i < l + 1\n    invariant 1 <= i <= l + 1\n    invariant |r| == i - 1\n    invariant forall j :: 0 <= j < i - 1 ==> r[j] == ('0' as char) + j + 1\n    decreases l + 1 - i\n  {\n    r := r + [ ('0' as char) + i ];\n    i := i + 1;\n  }\n  i := l - 1;\n  while i > 0\n    invariant 0 <= i <= l - 1\n    invariant |r| == l + (l - 1 - i)\n    invariant forall j :: 0 <= j < l ==> r[j] == ('0' as char) + j + 1\n    invariant forall k :: 0 <= k < l - 1 - i ==> r[l + k] == ('0' as char) + l - (k + 1)\n    decreases i\n  {\n    r := r + [ ('0' as char) + i ];\n    i := i - 1;\n  }\n  res := r;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.735,
        "duration_formatted": "6.73s",
        "tokens": {
          "input": 1343,
          "output": 375,
          "total": 1718
        },
        "cost_usd": 0.005686,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:29:22.971379"
      }
    },
    {
      "file_path": "program_050.py",
      "code": "def bin_coff(n, r):\n    val = 1\n    if r > n - r:\n        r = n - r\n    i = 0\n    while i < r:\n        val *= n - i\n        val //= i + 1\n        i += 1\n    return val",
      "program_specification": "```dafny\nmethod BinCoff(n: int, r: int) returns (val: int)\n  requires n >= 0\n  requires 0 <= r <= n\n  ensures val >= 1\n  ensures val == BinomialCoeff(n, r)\n{\n  var rr := r;\n  if rr > n - rr {\n    rr := n - rr;\n  }\n  val := 1;\n  var i := 0;\n  while i < rr\n    invariant 0 <= i <= rr\n    invariant val >= 1\n    decreases rr - i\n  {\n    val := val * (n - i);\n    val := val / (i + 1);\n    i := i + 1;\n  }\n}\n\nfunction BinomialCoeff(n: int, r: int): int\n  requires n >= 0 && 0 <= r <= n\n{\n  if r == 0 || r == n then 1\n  else BinomialCoeff(n - 1, r - 1) + BinomialCoeff(n - 1, r)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.598,
        "duration_formatted": "4.60s",
        "tokens": {
          "input": 1332,
          "output": 226,
          "total": 1558
        },
        "cost_usd": 0.004472,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:29:32.599061"
      }
    },
    {
      "file_path": "program_051.py",
      "code": "def int_to_roman(num):\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syb = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    roman_num = ''\n    i = 0\n    while num > 0:\n        _ = 0\n        while _ < num // val[i]:\n            roman_num += syb[i]\n            num -= val[i]\n            _ += 1\n        i += 1\n    return roman_num",
      "program_specification": "```dafny\nmethod IntToRoman(num: int) returns (romanNum: string)\n  requires 1 <= num <= 3999\n  ensures romanNum != \"\"\n  // Ensures romanNum is a Roman numeral representing num, using standard symbols\n{\n  var val := [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n  var syb := [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n  romanNum := \"\";\n  var n := num;\n  var i := 0;\n  while n > 0\n    invariant 0 <= i <= 13\n    invariant 0 < n <= num\n    invariant romanNum != null\n    decreases n\n  {\n    var count := n / val[i];\n    var j := 0;\n    while j < count\n      invariant 0 <= j <= count\n      invariant romanNum != null\n      decreases count - j\n    {\n      romanNum := romanNum + syb[i];\n      n := n - val[i];\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.844,
        "duration_formatted": "7.84s",
        "tokens": {
          "input": 1422,
          "output": 286,
          "total": 1708
        },
        "cost_usd": 0.005132,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:29:45.485104"
      }
    },
    {
      "file_path": "program_053.py",
      "code": "def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    >>> # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    >>> # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    >>> # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    >>> # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    rows, columns = np.shape(table)\n    if rows != columns:\n        msg = f\"'table' has to be of square shaped array but got a {rows}x{columns} array:\\n{table}\"\n        raise ValueError(msg)\n    lower = np.zeros((rows, columns))\n    upper = np.zeros((rows, columns))\n    i = 0\n    while i < columns:\n        j = 0\n        while j < i:\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            if upper[j][j] == 0:\n                raise ArithmeticError('No LU decomposition exists')\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\n            j += 1\n        lower[i][i] = 1\n        j = i\n        while j < columns:\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            upper[i][j] = table[i][j] - total\n            j += 1\n        i += 1\n    return (lower, upper)",
      "program_specification": "```dafny\nmethod LowerUpperDecomposition(table: array2<Real>) returns (lower: array2<Real>, upper: array2<Real>)\n  requires table != null\n  requires table.Rows == table.Cols\n  requires table.Rows > 0\n  // Ensures: lower and upper are square matrices of same size as table\n  ensures lower != null && upper != null\n  ensures lower.Rows == table.Rows && lower.Cols == table.Cols\n  ensures upper.Rows == table.Rows && upper.Cols == table.Cols\n  // Ensures: lower is lower-triangular with 1s on the diagonal\n  ensures forall i, j :: 0 <= i < lower.Rows && 0 <= j < lower.Cols && i < j ==> lower[i, j] == 0.0\n  ensures forall i :: 0 <= i < lower.Rows ==> lower[i, i] == 1.0\n  // Ensures: upper is upper-triangular\n  ensures forall i, j :: 0 <= i < upper.Rows && 0 <= j < upper.Cols && i > j ==> upper[i, j] == 0.0\n  // Ensures: For all i, j, table[i, j] == sum_{k=0}^{min(i,j)} lower[i, k] * upper[k, j]\n  ensures forall i, j :: 0 <= i < table.Rows && 0 <= j < table.Cols ==>\n    table[i, j] == (if i == 0 || j == 0 then lower[i, 0] * upper[0, j]\n                    else\n                      (var m := if i < j then i else j;\n                       sum k | 0 <= k <= m :: lower[i, k] * upper[k, j]))\n{\n  var n := table.Rows;\n  lower := new Real[n, n];\n  upper := new Real[n, n];\n\n  var i: int := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant lower != null && upper != null\n    invariant lower.Rows == n && lower.Cols == n\n    invariant upper.Rows == n && upper.Cols == n\n    decreases n - i\n  {\n    var j: int := 0;\n    // Compute lower[i, j] for j < i\n    while j < i\n      invariant 0 <= j <= i <= n\n      decreases i - j\n    {\n      var total: Real := 0.0;\n      var k: int := 0;\n      while k < j\n        invariant 0 <= k <= j\n        invariant total == (if k == 0 then 0.0 else sum l | 0 <= l < k :: lower[i, l] * upper[l, j])\n        decreases j - k\n      {\n        total := total + lower[i, k] * upper[k, j];\n        k := k + 1;\n      }\n      if upper[j, j] == 0.0 {\n        // No LU decomposition exists\n        return;\n      }\n      lower[i, j] := (table[i, j] - total) / upper[j, j];\n      j := j + 1;\n    }\n    lower[i, i] := 1.0;\n\n    j := i;\n    // Compute upper[i, j] for j >= i\n    while j < n\n      invariant i <= j <= n\n      decreases n - j\n    {\n      var total: Real := 0.0;\n      var k: int := 0;\n      while k < i\n        invariant 0 <= k <= i\n        invariant total == (if k == 0 then 0.0 else sum l | 0 <= l < k :: lower[i, l] * upper[l, j])\n        decreases i - k\n      {\n        total := total + lower[i, k] * upper[k, j];\n        k := k + 1;\n      }\n      upper[i, j] := table[i, j] - total;\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 13.315,
        "duration_formatted": "13.31s",
        "tokens": {
          "input": 2118,
          "output": 877,
          "total": 2995
        },
        "cost_usd": 0.011252,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:30:03.867029"
      }
    },
    {
      "file_path": "program_054.py",
      "code": "def coin_change(S, m, n):\n    table = [[0 for x in range(m)] for x in range(n + 1)]\n    i = 0\n    while i < m:\n        table[0][i] = 1\n        i += 1\n    i = 1\n    while i < n + 1:\n        j = 0\n        while j < m:\n            x = table[i - S[j]][j] if i - S[j] >= 0 else 0\n            y = table[i][j - 1] if j >= 1 else 0\n            table[i][j] = x + y\n            j += 1\n        i += 1\n    return table[n][m - 1]",
      "program_specification": "```dafny\nmethod CoinChange(S: array<int>, m: int, n: int) returns (count: int)\n  requires S != null\n  requires 0 <= m <= S.Length\n  requires n >= 0\n  ensures count >= 0\n{\n  var table := new int[n + 1][];\n  var i := 0;\n  while i < n + 1\n    invariant 0 <= i <= n + 1\n    invariant table != null && table.Length == n + 1\n    decreases n + 1 - i\n  {\n    table[i] := new int[m];\n    var j := 0;\n    while j < m\n      invariant 0 <= j <= m\n      invariant table[i] != null && table[i].Length == m\n      decreases m - j\n    {\n      table[i][j] := 0;\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n\n  i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    decreases m - i\n  {\n    table[0][i] := 1;\n    i := i + 1;\n  }\n\n  i := 1;\n  while i < n + 1\n    invariant 1 <= i <= n + 1\n    decreases n + 1 - i\n  {\n    var j := 0;\n    while j < m\n      invariant 0 <= j <= m\n      decreases m - j\n    {\n      var x := if i - S[j] >= 0 then table[i - S[j]][j] else 0;\n      var y := if j >= 1 then table[i][j - 1] else 0;\n      table[i][j] := x + y;\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  count := table[n][m - 1];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.337,
        "duration_formatted": "5.34s",
        "tokens": {
          "input": 1427,
          "output": 416,
          "total": 1843
        },
        "cost_usd": 0.006182,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:30:14.247008"
      }
    },
    {
      "file_path": "program_064.py",
      "code": "def longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError('longest_common_substring() takes two strings for inputs')\n    if not text1 or not text2:\n        return ''\n    text1_length = len(text1)\n    text2_length = len(text2)\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    end_pos = 0\n    max_length = 0\n    i = 1\n    while i < text1_length + 1:\n        j = 1\n        while j < text2_length + 1:\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if dp[i][j] > max_length:\n                    end_pos = i\n                    max_length = dp[i][j]\n            j += 1\n        i += 1\n    return text1[end_pos - max_length:end_pos]",
      "program_specification": "```dafny\nmethod LongestCommonSubstring(text1: seq<char>, text2: seq<char>) returns (res: seq<char>)\n  requires text1 != null && text2 != null\n  ensures res != null\n  ensures res in text1 && res in text2\n  ensures forall s: seq<char> :: s in text1 && s in text2 ==> |s| <= |res|\n  ensures (|text1| == 0 || |text2| == 0) ==> |res| == 0\n{\n  if |text1| == 0 || |text2| == 0 {\n    res := [];\n    return;\n  }\n\n  var n := |text1|;\n  var m := |text2|;\n  var dp := new int[n + 1][];\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant dp != null && dp.Length == n + 1\n    decreases n + 1 - i\n  {\n    dp[i] := new int[m + 1];\n    i := i + 1;\n  }\n\n  var maxLen := 0;\n  var endPos := 0;\n  i := 1;\n  while i <= n\n    invariant 1 <= i <= n + 1\n    invariant 0 <= maxLen <= i\n    invariant 0 <= endPos <= i\n    decreases n + 1 - i\n  {\n    var j := 1;\n    while j <= m\n      invariant 1 <= j <= m + 1\n      decreases m + 1 - j\n    {\n      if text1[i - 1] == text2[j - 1] {\n        dp[i][j] := 1 + dp[i - 1][j - 1];\n        if dp[i][j] > maxLen {\n          maxLen := dp[i][j];\n          endPos := i;\n        }\n      } else {\n        dp[i][j] := 0;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n\n  if maxLen == 0 {\n    res := [];\n  } else {\n    res := text1[(endPos - maxLen) .. endPos];\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 12.409,
        "duration_formatted": "12.41s",
        "tokens": {
          "input": 1745,
          "output": 485,
          "total": 2230
        },
        "cost_usd": 0.00737,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:30:31.708555"
      }
    },
    {
      "file_path": "program_065.py",
      "code": "def count_Unset_Bits(n):\n    cnt = 0\n    i = 1\n    while i < n + 1:\n        temp = i\n        while temp:\n            if temp % 2 == 0:\n                cnt += 1\n            temp = temp // 2\n        i += 1\n    return cnt",
      "program_specification": "```dafny\nmethod CountUnsetBits(n: int) returns (cnt: int)\n  requires n >= 0\n  ensures cnt >= 0\n  // cnt is the total number of unset (0) bits among all numbers i in 1..n, in their binary representation\n{\n  cnt := 0;\n  var i := 1;\n  while i < n + 1\n    invariant 1 <= i <= n + 1\n    invariant cnt >= 0\n    decreases n + 1 - i\n  {\n    var temp := i;\n    while temp > 0\n      invariant temp >= 0\n      decreases temp\n    {\n      if temp % 2 == 0 {\n        cnt := cnt + 1;\n      }\n      temp := temp / 2;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.614,
        "duration_formatted": "3.61s",
        "tokens": {
          "input": 1337,
          "output": 181,
          "total": 1518
        },
        "cost_usd": 0.004122,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:30:40.354078"
      }
    },
    {
      "file_path": "program_066.py",
      "code": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    longest_increasing_subsequence = [1] * n\n    i = 1\n    while i < n:\n        j = 0\n        while j < i:\n            if arr[i] > arr[j] and longest_increasing_subsequence[i] < longest_increasing_subsequence[j] + 1:\n                longest_increasing_subsequence[i] = longest_increasing_subsequence[j] + 1\n            j += 1\n        i += 1\n    maximum = 0\n    i = 0\n    while i < n:\n        maximum = max(maximum, longest_increasing_subsequence[i])\n        i += 1\n    return maximum",
      "program_specification": "```dafny\nmethod LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 1 <= length <= arr.Length || arr.Length == 0 ==> length == 0\n  ensures length == 0 <==> arr.Length == 0\n  ensures length <= arr.Length\n  // For any strictly increasing subsequence, its length <= result\n{\n  var n := arr.Length;\n  if n == 0 {\n    length := 0;\n    return;\n  }\n\n  var lis := new int[n];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] >= 1 && lis[k] <= k + 1\n    decreases n - i\n  {\n    lis[i] := 1;\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      decreases i - j\n    {\n      if arr[i] > arr[j] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n\n  var maximum := 0;\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= maximum <= n\n    invariant forall k :: 0 <= k < i ==> maximum >= lis[k]\n    decreases n - i\n  {\n    if lis[i] > maximum {\n      maximum := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maximum;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.141,
        "duration_formatted": "6.14s",
        "tokens": {
          "input": 1419,
          "output": 364,
          "total": 1783
        },
        "cost_usd": 0.00575,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:30:51.545069"
      }
    },
    {
      "file_path": "program_068.py",
      "code": "def find_longest_conseq_subseq(arr, n):\n    ans = 0\n    count = 0\n    arr.sort()\n    v = []\n    v.append(arr[0])\n    i = 1\n    while i < n:\n        if arr[i] != arr[i - 1]:\n            v.append(arr[i])\n        i += 1\n    i = 0\n    while i < len(v):\n        if i > 0 and v[i] == v[i - 1] + 1:\n            count += 1\n        else:\n            count = 1\n        ans = max(ans, count)\n        i += 1\n    return ans",
      "program_specification": "```dafny\nmethod FindLongestConseqSubseq(arr: array<int>, n: int) returns (ans: int)\n  requires arr != null\n  requires 0 < n <= arr.Length\n  ensures 1 <= ans <= n\n{\n  var a := arr[..n];\n  var b := a[..];\n  b := b[..];\n  // Sort b\n  b := b[..];\n  b := b[..];\n  // Simple insertion sort for simplicity and verifiability\n  var i: int := 1;\n  while i < |b|\n    invariant 1 <= n <= arr.Length\n    invariant 1 <= |b| == n\n    invariant 0 <= i <= |b|\n    invariant b[..i] is sorted\n    decreases |b| - i\n  {\n    var j := i;\n    while j > 0 && b[j] < b[j-1]\n      invariant 0 <= j <= i <= |b|\n      invariant b[..j] is sorted\n      decreases j\n    {\n      var tmp := b[j];\n      b[j] := b[j-1];\n      b[j-1] := tmp;\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n\n  var v: seq<int> := [];\n  v := v + [b[0]];\n  i := 1;\n  while i < |b|\n    invariant 1 <= |b| == n\n    invariant 1 <= |v| <= i+1\n    invariant v == [b[0]] + [b[j] | j : int :: 1 <= j < i && b[j] != b[j-1]]\n    invariant 1 <= i <= |b|\n    decreases |b| - i\n  {\n    if b[i] != b[i-1] {\n      v := v + [b[i]];\n    }\n    i := i + 1;\n  }\n\n  var count: int := 0;\n  ans := 0;\n  i := 0;\n  while i < |v|\n    invariant 0 <= i <= |v|\n    invariant 0 <= ans <= i\n    invariant 0 <= count <= i+1\n    decreases |v| - i\n  {\n    if i > 0 && v[i] == v[i-1] + 1 {\n      count := count + 1;\n    } else {\n      count := 1;\n    }\n    if ans < count {\n      ans := count;\n    }\n    i := i + 1;\n  }\n  // Postcondition: 1 <= ans <= n\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 11.711,
        "duration_formatted": "11.71s",
        "tokens": {
          "input": 1407,
          "output": 552,
          "total": 1959
        },
        "cost_usd": 0.00723,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:31:08.292171"
      }
    },
    {
      "file_path": "program_074.py",
      "code": "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        i = index\n        while i < len(nums):\n            dfs(nums, target - nums[i], i, path + [nums[i]], res)\n            i += 1\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res",
      "program_specification": "```dafny\nmethod CombinationSum(candidates: seq<int>, target: int) returns (res: seq<seq<int>>)\n  requires target >= 0\n  ensures forall s: seq<int> :: s in res ==> (|s| >= 0 && Sum(s) == target && AllIn(s, candidates) && IsNonDecreasing(s))\n{\n  var sortedCandidates := SortSeq(candidates);\n  var result: seq<seq<int>> := [];\n  dfs(sortedCandidates, target, 0, [], result);\n  res := result;\n}\n\nmethod dfs(nums: seq<int>, target: int, index: int, path: seq<int>, modifies res: seq<seq<int>>)\n  requires 0 <= index <= |nums|\n  requires target >= 0 || target < 0\n  modifies res\n  ensures forall s: seq<int> :: s in res ==> (|s| >= 0 && Sum(s) == target + Sum(path) && AllIn(s, nums) && IsNonDecreasing(s))\n  decreases target, |nums| - index\n{\n  if target < 0 {\n    return;\n  }\n  if target == 0 {\n    res := res + [path];\n    return;\n  }\n  var i := index;\n  while i < |nums|\n    invariant 0 <= i <= |nums|\n    invariant forall s: seq<int> :: s in res ==> (|s| >= 0 && Sum(s) == target + Sum(path) && AllIn(s, nums) && IsNonDecreasing(s))\n    decreases |nums| - i\n  {\n    dfs(nums, target - nums[i], i, path + [nums[i]], res);\n    i := i + 1;\n  }\n}\n\nfunction Sum(s: seq<int>): int\n  decreases s\n{\n  if |s| == 0 then 0 else s[0] + Sum(s[1..])\n}\n\nfunction AllIn(s: seq<int>, pool: seq<int>): bool\n  decreases |s|\n{\n  forall i :: 0 <= i < |s| ==> s[i] in pool\n}\n\nfunction IsNonDecreasing(s: seq<int>): bool\n  decreases |s|\n{\n  forall i :: 1 <= i < |s| ==> s[i-1] <= s[i]\n}\n\nfunction SortSeq(s: seq<int>): seq<int>\n  decreases |s|\n{\n  if |s| <= 1 then s\n  else\n    var pivot := s[0];\n    SortSeq([x | x := s[1..], x < pivot]) +\n    [pivot] +\n    SortSeq([x | x := s[1..], x >= pivot])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 10.735,
        "duration_formatted": "10.73s",
        "tokens": {
          "input": 1373,
          "output": 565,
          "total": 1938
        },
        "cost_usd": 0.007266,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:31:24.060229"
      }
    },
    {
      "file_path": "program_082.py",
      "code": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    dp = [[0 for k in range(n + 1)] for l in range(n + 1)]\n    i = 1\n    while i < n + 1:\n        j = 1\n        while j < n + 1:\n            if str[i - 1] == str[j - 1] and i != j:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n            j += 1\n        i += 1\n    return dp[n][n]",
      "program_specification": "```dafny\nmethod FindLongestRepeatingSubseq(s: seq<char>) returns (len: int)\n  ensures 0 <= len <= |s|\n{\n  var n := |s|;\n  var dp := new int[n + 1][n + 1];\n  var i := 1;\n  while i <= n\n    invariant 1 <= i <= n + 1\n    invariant forall x :: 0 <= x < i ==> forall y :: 0 <= y <= n ==> 0 <= dp[x][y] <= x\n    decreases n + 1 - i\n  {\n    var j := 1;\n    while j <= n\n      invariant 1 <= j <= n + 1\n      invariant forall y :: 0 <= y < j ==> 0 <= dp[i][y] <= i\n      decreases n + 1 - j\n    {\n      if s[i - 1] == s[j - 1] && i != j {\n        dp[i][j] := 1 + dp[i - 1][j - 1];\n      } else {\n        dp[i][j] := if dp[i][j - 1] >= dp[i - 1][j] then dp[i][j - 1] else dp[i - 1][j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  len := dp[n][n];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.364,
        "duration_formatted": "4.36s",
        "tokens": {
          "input": 1421,
          "output": 304,
          "total": 1725
        },
        "cost_usd": 0.005274,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:31:33.462752"
      }
    },
    {
      "file_path": "program_089.py",
      "code": "def find_Element(arr, ranges, rotations, index):\n    i = rotations - 1\n    while i > -1:\n        left = ranges[i][0]\n        right = ranges[i][1]\n        if left <= index and right >= index:\n            if index == left:\n                index = right\n            else:\n                index = index - 1\n        i += -1\n    return arr[index]",
      "program_specification": "```dafny\nmethod FindElement(arr: array<int>, ranges: array<array<int>>, rotations: int, index: int) returns (res: int)\n  requires arr != null\n  requires ranges != null\n  requires 0 <= rotations <= ranges.Length\n  requires 0 <= index < arr.Length\n  // Each ranges[i] must be an array of length 2\n  requires forall i :: 0 <= i < ranges.Length ==> ranges[i] != null && ranges[i].Length == 2\n  // Each range must be a valid subarray of arr\n  requires forall i :: 0 <= i < rotations ==> 0 <= ranges[i][0] <= ranges[i][1] < arr.Length\n  ensures 0 <= index < arr.Length ==> res == arr[index] || exists j :: 0 <= j < arr.Length && res == arr[j]\n{\n  var i := rotations - 1;\n  var idx := index;\n  while i > -1\n    invariant -1 <= i < rotations\n    invariant 0 <= idx < arr.Length\n    decreases i\n  {\n    var left := ranges[i][0];\n    var right := ranges[i][1];\n    if left <= idx && right >= idx {\n      if idx == left {\n        idx := right;\n      } else {\n        idx := idx - 1;\n      }\n    }\n    i := i - 1;\n  }\n  res := arr[idx];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.331,
        "duration_formatted": "8.33s",
        "tokens": {
          "input": 1350,
          "output": 303,
          "total": 1653
        },
        "cost_usd": 0.005124,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:31:46.832788"
      }
    },
    {
      "file_path": "program_096.py",
      "code": "def ncr_modp(n, r, p):\n    C = [0 for i in range(r + 1)]\n    C[0] = 1\n    i = 1\n    while i < n + 1:\n        j = min(i, r)\n        while j > 0:\n            C[j] = (C[j] + C[j - 1]) % p\n            j += -1\n        i += 1\n    return C[r]",
      "program_specification": "```dafny\nmethod NCrModP(n: int, r: int, p: int) returns (res: int)\n  requires n >= 0\n  requires 0 <= r <= n\n  requires p > 0\n  ensures 0 <= res < p\n{\n  var C := new int[r + 1];\n  var i := 0;\n  while i < r + 1\n    invariant 0 <= i <= r + 1\n    invariant forall k :: 0 <= k < i ==> C[k] >= 0 && C[k] < p\n    decreases r + 1 - i\n  {\n    C[i] := 0;\n    i := i + 1;\n  }\n  C[0] := 1;\n  i := 1;\n  while i < n + 1\n    invariant 1 <= i <= n + 1\n    invariant C[0] == 1\n    invariant forall k :: 0 <= k <= r ==> C[k] >= 0 && C[k] < p\n    decreases n + 1 - i\n  {\n    var j := if i < r then i else r;\n    while j > 0\n      invariant 0 <= j <= if i < r then i else r\n      invariant forall k :: 0 <= k <= r ==> C[k] >= 0 && C[k] < p\n      decreases j\n    {\n      C[j] := (C[j] + C[j - 1]) % p;\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n  res := C[r];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.251,
        "duration_formatted": "4.25s",
        "tokens": {
          "input": 1365,
          "output": 349,
          "total": 1714
        },
        "cost_usd": 0.005522,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:31:56.118102"
      }
    },
    {
      "file_path": "program_101.py",
      "code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    i = len(nums) - 2\n    while i > -1:\n        if nums[i] < nums[i + 1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(''.join(nums))\n        i += -1\n    return False",
      "program_specification": "```dafny\nmethod RearrangeBigger(n: int) returns (res: int)\n  requires n >= 0\n  ensures (res > n) ==> (|res.ToString()| == |n.ToString()| && Multiset(res.ToString()) == Multiset(n.ToString()))\n  ensures (res > n) ==> res > n\n  ensures (res <= n) ==> (forall m :: m > n && |m.ToString()| == |n.ToString()| && Multiset(m.ToString()) == Multiset(n.ToString()) ==> false)\n{\n  var s := n.ToString();\n  var nums := new int[s.Length];\n  var i := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall j :: 0 <= j < i ==> 0 <= nums[j] <= 9\n    decreases s.Length - i\n  {\n    nums[i] := s[i] - '0';\n    i := i + 1;\n  }\n\n  var idx := nums.Length - 2;\n  var found := false;\n  while idx >= 0\n    invariant -1 <= idx <= nums.Length - 2\n    invariant forall j :: 0 <= j < nums.Length ==> 0 <= nums[j] <= 9\n    decreases idx + 1\n  {\n    if nums[idx] < nums[idx + 1] {\n      found := true;\n      // Copy tail\n      var tailLen := nums.Length - idx;\n      var z := new int[tailLen];\n      var k := 0;\n      while k < tailLen\n        invariant 0 <= k <= tailLen\n        invariant forall j :: 0 <= j < k ==> 0 <= z[j] <= 9\n        decreases tailLen - k\n      {\n        z[k] := nums[idx + k];\n        k := k + 1;\n      }\n      // Find minimal y > z[0]\n      var minY := 10;\n      var minYIdx := -1;\n      k := 1;\n      while k < tailLen\n        invariant 1 <= k <= tailLen\n        invariant (minY == 10) || (exists j :: 1 <= j < k && z[j] > z[0] && z[j] == minY)\n        decreases tailLen - k\n      {\n        if z[k] > z[0] && z[k] < minY {\n          minY := z[k];\n          minYIdx := k;\n        }\n        k := k + 1;\n      }\n      if minYIdx == -1 {\n        // Shouldn't happen, but for safety\n        break;\n      }\n      // Remove y from z\n      var newZ := new int[tailLen - 1];\n      var pos := 0;\n      k := 0;\n      while k < tailLen\n        invariant 0 <= k <= tailLen\n        invariant 0 <= pos <= tailLen - 1\n        invariant pos == k - (if minYIdx < k then 1 else 0)\n        decreases tailLen - k\n      {\n        if k != minYIdx {\n          newZ[pos] := z[k];\n          pos := pos + 1;\n        }\n        k := k + 1;\n      }\n      // Sort newZ\n      // Simple selection sort for verifiability\n      k := 0;\n      while k < newZ.Length\n        invariant 0 <= k <= newZ.Length\n        decreases newZ.Length - k\n      {\n        var minIdx := k;\n        var l := k + 1;\n        while l < newZ.Length\n          invariant k + 1 <= l <= newZ.Length\n          decreases newZ.Length - l\n        {\n          if newZ[l] < newZ[minIdx] {\n            minIdx := l;\n          }\n          l := l + 1;\n        }\n        if minIdx != k {\n          var tmp := newZ[k];\n          newZ[k] := newZ[minIdx];\n          newZ[minIdx] := tmp;\n        }\n        k := k + 1;\n      }\n      // Assign back\n      nums[idx] := minY;\n      k := 0;\n      while k < newZ.Length\n        invariant 0 <= k <= newZ.Length\n        decreases newZ.Length - k\n      {\n        nums[idx + 1 + k] := newZ[k];\n        k := k + 1;\n      }\n      // Convert nums to int\n      var result := 0;\n      k := 0;\n      while k < nums.Length\n        invariant 0 <= k <= nums.Length\n        invariant result >= 0\n        decreases nums.Length - k\n      {\n        result := result * 10 + nums[k];\n        k := k + 1;\n      }\n      res := result;\n      return;\n    }\n    idx := idx - 1;\n  }\n  res := n; // No bigger permutation exists, return n (False not possible in int)\n}\n\nfunction Multiset(s: seq<char>): multiset<char>\n{\n  multiset s\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 16.209,
        "duration_formatted": "16.21s",
        "tokens": {
          "input": 1368,
          "output": 1078,
          "total": 2446
        },
        "cost_usd": 0.01136,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:32:17.401639"
      }
    },
    {
      "file_path": "program_102.py",
      "code": "def frequency_Of_Smallest(n, arr):\n    mn = arr[0]\n    freq = 1\n    i = 1\n    while i < n:\n        if arr[i] < mn:\n            mn = arr[i]\n            freq = 1\n        elif arr[i] == mn:\n            freq += 1\n        i += 1\n    return freq",
      "program_specification": "```dafny\nmethod FrequencyOfSmallest(n: int, arr: array<int>) returns (freq: int)\n  requires arr != null\n  requires 1 <= n <= arr.Length\n  ensures 1 <= freq <= n\n  ensures exists mn: int :: (forall i :: 0 <= i < n ==> arr[i] >= mn) && freq == |{ i: int | 0 <= i < n && arr[i] == mn }|\n{\n  var mn := arr[0];\n  freq := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= n <= arr.Length\n    invariant 1 <= i <= n\n    invariant 1 <= freq <= i\n    invariant exists m: int :: (forall j :: 0 <= j < i ==> arr[j] >= m) && mn == m\n    invariant freq == |{ j: int | 0 <= j < i && arr[j] == mn }|\n    decreases n - i\n  {\n    if arr[i] < mn {\n      mn := arr[i];\n      freq := 1;\n    } else if arr[i] == mn {\n      freq := freq + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.696,
        "duration_formatted": "3.70s",
        "tokens": {
          "input": 1345,
          "output": 265,
          "total": 1610
        },
        "cost_usd": 0.00481,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:32:26.137342"
      }
    },
    {
      "file_path": "program_105.py",
      "code": "def find_Min_Diff(arr, n):\n    arr = sorted(arr)\n    diff = 10 ** 20\n    i = 0\n    while i < n - 1:\n        if arr[i + 1] - arr[i] < diff:\n            diff = arr[i + 1] - arr[i]\n        i += 1\n    return diff",
      "program_specification": "```dafny\nmethod FindMinDiff(arr: array<int>, n: int) returns (diff: int)\n  requires arr != null\n  requires 1 <= n <= arr.Length\n  ensures forall i :: 0 <= i < n-1 ==> diff <= arr[i+1] - arr[i]\n  ensures exists i :: 0 <= i < n-1 ==> diff == arr[i+1] - arr[i]\n{\n  var tmp := new int[n];\n  // Copy first n elements to tmp for sorting\n  var j := 0;\n  while j < n\n    invariant 0 <= j <= n\n    invariant forall k :: 0 <= k < j ==> tmp[k] == arr[k]\n    decreases n - j\n  {\n    tmp[j] := arr[j];\n    j := j + 1;\n  }\n  // Sort tmp[0..n)\n  // Simple selection sort for verifiability\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall a, b :: 0 <= a < i <= b < n ==> tmp[a] <= tmp[b]\n    decreases n - i\n  {\n    var minIdx := i;\n    var k := i + 1;\n    while k < n\n      invariant i+1 <= k <= n\n      invariant i <= minIdx < n\n      invariant forall m :: i <= m < k ==> tmp[minIdx] <= tmp[m]\n      decreases n - k\n    {\n      if tmp[k] < tmp[minIdx] {\n        minIdx := k;\n      }\n      k := k + 1;\n    }\n    // Swap tmp[i] and tmp[minIdx]\n    var t := tmp[i];\n    tmp[i] := tmp[minIdx];\n    tmp[minIdx] := t;\n    i := i + 1;\n  }\n\n  diff := 100000000000000000000; // 10^20\n  i := 0;\n  while i < n - 1\n    invariant 0 <= i <= n-1\n    invariant forall k :: 0 <= k < i ==> diff <= tmp[k+1] - tmp[k]\n    invariant diff >= 0\n    decreases n - 1 - i\n  {\n    var d := tmp[i+1] - tmp[i];\n    if d < diff {\n      diff := d;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.683,
        "duration_formatted": "7.68s",
        "tokens": {
          "input": 1342,
          "output": 515,
          "total": 1857
        },
        "cost_usd": 0.006804,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:32:38.858267"
      }
    },
    {
      "file_path": "program_112.py",
      "code": "def get_maxgold(gold, m, n):\n    goldTable = [[0 for i in range(n)] for j in range(m)]\n    col = n - 1\n    while col > -1:\n        row = 0\n        while row < m:\n            if col == n - 1:\n                right = 0\n            else:\n                right = goldTable[row][col + 1]\n            if row == 0 or col == n - 1:\n                right_up = 0\n            else:\n                right_up = goldTable[row - 1][col + 1]\n            if row == m - 1 or col == n - 1:\n                right_down = 0\n            else:\n                right_down = goldTable[row + 1][col + 1]\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down)\n            row += 1\n        col += -1\n    res = goldTable[0][0]\n    i = 1\n    while i < m:\n        res = max(res, goldTable[i][0])\n        i += 1\n    return res",
      "program_specification": "```dafny\nmethod GetMaxGold(gold: array2<int>, m: int, n: int) returns (res: int)\n  requires gold != null\n  requires m >= 0 && n >= 0\n  requires gold.Dims == 2\n  requires gold.Length0 == m\n  requires gold.Length1 == n\n  ensures 0 <= res\n  ensures forall i :: 0 <= i < m ==> res >= gold[i,0]\n{\n  var goldTable := new int[m,n];\n  var col := n - 1;\n  while col > -1\n    invariant -1 <= col <= n - 1\n    invariant goldTable != null\n    decreases col + 1\n  {\n    var row := 0;\n    while row < m\n      invariant 0 <= row <= m\n      invariant goldTable != null\n      decreases m - row\n    {\n      var right: int;\n      if col == n - 1 {\n        right := 0;\n      } else {\n        right := goldTable[row, col + 1];\n      }\n      var right_up: int;\n      if row == 0 || col == n - 1 {\n        right_up := 0;\n      } else {\n        right_up := goldTable[row - 1, col + 1];\n      }\n      var right_down: int;\n      if row == m - 1 || col == n - 1 {\n        right_down := 0;\n      } else {\n        right_down := goldTable[row + 1, col + 1];\n      }\n      goldTable[row, col] := gold[row, col] + MaxOfThree(right, right_up, right_down);\n      row := row + 1;\n    }\n    col := col - 1;\n  }\n  res := goldTable[0,0];\n  var i := 1;\n  while i < m\n    invariant 1 <= i <= m\n    invariant forall j :: 0 <= j < i ==> res >= goldTable[j,0]\n    decreases m - i\n  {\n    res := MaxOfTwo(res, goldTable[i,0]);\n    i := i + 1;\n  }\n}\n\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures (m == a || m == b)\n  ensures m >= a && m >= b\n  ensures (a >= b) ==> m == a\n  ensures (b >  a) ==> m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n\nmethod MaxOfThree(a: int, b: int, c: int) returns (m: int)\n  ensures m == a || m == b || m == c\n  ensures m >= a && m >= b && m >= c\n{\n  var ab := MaxOfTwo(a, b);\n  m := MaxOfTwo(ab, c);\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.495,
        "duration_formatted": "7.49s",
        "tokens": {
          "input": 1512,
          "output": 623,
          "total": 2135
        },
        "cost_usd": 0.008008,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:32:51.451721"
      }
    },
    {
      "file_path": "program_117.py",
      "code": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    i = 0\n    while i < len(string):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n        i += 1\n    return max_length",
      "program_specification": "```dafny\nmethod LongestNonRepeatV1(s: seq<char>) returns (maxLen: int)\n  ensures 0 <= maxLen <= |s|\n  // maxLen is the length of some substring of s with all unique characters\n  ensures forall i, j :: 0 <= i <= j <= |s| && (j - i) > maxLen ==>\n            exists k, l :: 0 <= k <= l <= |s| && l - k == maxLen &&\n              (forall m, n :: k <= m < n < l ==> s[m] != s[n])\n  // maxLen is achievable: there is a substring of length maxLen with all unique characters\n  ensures exists i, j :: 0 <= i <= j <= |s| && j - i == maxLen &&\n            (forall k, l :: i <= k < l < j ==> s[k] != s[l])\n{\n  var dict := map[]; // map from char to int (1-based index of last occurrence)\n  maxLen := 0;\n  var j := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant 0 <= j <= i\n    invariant 0 <= maxLen <= i - j + 1\n    invariant forall c: char :: c in dict ==> 1 <= dict[c] <= i + 1\n    decreases |s| - i\n  {\n    if s[i] in dict {\n      j := if dict[s[i]] > j then dict[s[i]] else j;\n    }\n    dict := dict[s[i] := i + 1];\n    var currLen := i - j + 1;\n    if currLen > maxLen {\n      maxLen := currLen;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.347,
        "duration_formatted": "7.35s",
        "tokens": {
          "input": 1387,
          "output": 391,
          "total": 1778
        },
        "cost_usd": 0.005902,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:33:03.829985"
      }
    },
    {
      "file_path": "program_118.py",
      "code": "def factorial(start, end):\n    res = 1\n    i = start\n    while i < end + 1:\n        res *= i\n        i += 1\n    return res",
      "program_specification": "```dafny\nmethod Factorial(start: int, end: int) returns (res: int)\n  ensures end < start ==> res == 1\n  ensures end >= start ==> res == if start > 0 then ProductSeq(start, end) else 0\n{\n  res := 1;\n  var i := start;\n  while i <= end\n    invariant i >= start\n    invariant i <= end + 1\n    invariant res == (if i > start then ProductSeq(start, i - 1) else 1)\n    decreases end + 1 - i\n  {\n    res := res * i;\n    i := i + 1;\n  }\n}\n\nfunction ProductSeq(a: int, b: int): int\n  decreases b - a + 1\n{\n  if b < a then 1\n  else if a > 0 then a * ProductSeq(a + 1, b)\n  else 0\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.959,
        "duration_formatted": "3.96s",
        "tokens": {
          "input": 1306,
          "output": 200,
          "total": 1506
        },
        "cost_usd": 0.004212,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:33:12.829660"
      }
    },
    {
      "file_path": "program_119.py",
      "code": "def reverse_floyd(n):\n    \"\"\"\n\n    Print the lower half of a diamond pattern with '*' characters.\n\n    Args:\n\n        n (int): Size of the pattern.\n\n    Examples:\n\n        >>> reverse_floyd(3)\n\n        '* * * \\\\n * * \\\\n  * \\\\n   '\n\n        >>> reverse_floyd(5)\n\n        '* * * * * \\\\n * * * * \\\\n  * * * \\\\n   * * \\\\n    * \\\\n     '\n\n    \"\"\"\n    result = ''\n    i = n\n    while i > 0:\n        _ = i\n        while _ > 0:\n            result += '* '\n            _ += -1\n        result += '\\n'\n        _ = n - i + 1\n        while _ > 0:\n            result += ' '\n            _ += -1\n        i += -1\n    return result",
      "program_specification": "```dafny\nmethod ReverseFloyd(n: int) returns (result: string)\n  requires n >= 0\n  ensures result.Length >= 0\n  // ensures result contains n lines, each ending with '\\n'\n{\n  var res := \"\";\n  var i := n;\n  while i > 0\n    invariant 0 <= i <= n\n    invariant res.Length >= 0\n    decreases i\n  {\n    var j := i;\n    while j > 0\n      invariant 0 <= j <= i\n      invariant res.Length >= 0\n      decreases j\n    {\n      res := res + \"* \";\n      j := j - 1;\n    }\n    res := res + \"\\n\";\n    var k := n - i + 1;\n    while k > 0\n      invariant 0 <= k <= n - i + 1\n      invariant res.Length >= 0\n      decreases k\n    {\n      res := res + \" \";\n      k := k - 1;\n    }\n    i := i - 1;\n  }\n  result := res;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.637,
        "duration_formatted": "2.64s",
        "tokens": {
          "input": 1450,
          "output": 230,
          "total": 1680
        },
        "cost_usd": 0.00474,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:33:20.502816"
      }
    },
    {
      "file_path": "program_127.py",
      "code": "def find_Min_Swaps(arr, n):\n    noOfZeroes = [0] * n\n    count = 0\n    noOfZeroes[n - 1] = 1 - arr[n - 1]\n    i = n - 2\n    while i > -1:\n        noOfZeroes[i] = noOfZeroes[i + 1]\n        if arr[i] == 0:\n            noOfZeroes[i] = noOfZeroes[i] + 1\n        i += -1\n    i = 0\n    while i < n:\n        if arr[i] == 1:\n            count = count + noOfZeroes[i]\n        i += 1\n    return count",
      "program_specification": "```dafny\nmethod FindMinSwaps(arr: array<int>, n: int) returns (count: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  requires forall i :: 0 <= i < n ==> (arr[i] == 0 || arr[i] == 1)\n  ensures count >= 0\n{\n  var noOfZeroes := new int[n];\n  count := 0;\n  if n > 0 {\n    noOfZeroes[n - 1] := 1 - arr[n - 1];\n    var i := n - 2;\n    while i >= 0\n      invariant -1 <= i < n\n      invariant forall j :: i+1 <= j < n ==> 0 <= noOfZeroes[j] <= n\n      decreases i + 1\n    {\n      noOfZeroes[i] := noOfZeroes[i + 1];\n      if arr[i] == 0 {\n        noOfZeroes[i] := noOfZeroes[i] + 1;\n      }\n      i := i - 1;\n    }\n    var j := 0;\n    while j < n\n      invariant 0 <= j <= n\n      invariant count >= 0\n      decreases n - j\n    {\n      if arr[j] == 1 {\n        count := count + noOfZeroes[j];\n      }\n      j := j + 1;\n    }\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.258,
        "duration_formatted": "4.26s",
        "tokens": {
          "input": 1420,
          "output": 307,
          "total": 1727
        },
        "cost_usd": 0.005296,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:33:29.798953"
      }
    },
    {
      "file_path": "program_129.py",
      "code": "def max_volume(s):\n    maxvalue = 0\n    i = 1\n    i = 0\n    while i < s - 1:\n        j = 1\n        j = 0\n        while j < s:\n            k = s - i - j\n            maxvalue = max(maxvalue, i * j * k)\n            j += 1\n        i += 1\n    return maxvalue",
      "program_specification": "```dafny\nmethod MaxVolume(s: int) returns (maxvalue: int)\n  requires s >= 0\n  ensures maxvalue >= 0\n  ensures forall i, j, k :: 0 <= i < s - 1 && 0 <= j < s && k == s - i - j ==> maxvalue >= i * j * k\n{\n  maxvalue := 0;\n  var i := 0;\n  while i < s - 1\n    invariant 0 <= i <= s - 1\n    invariant maxvalue >= 0\n    invariant forall i0, j0, k0 :: 0 <= i0 < i && 0 <= j0 < s && k0 == s - i0 - j0 ==> maxvalue >= i0 * j0 * k0\n    decreases s - 1 - i\n  {\n    var j := 0;\n    while j < s\n      invariant 0 <= j <= s\n      invariant maxvalue >= 0\n      invariant forall j0 :: 0 <= j0 < j ==> maxvalue >= i * j0 * (s - i - j0)\n      decreases s - j\n    {\n      var k := s - i - j;\n      if maxvalue < i * j * k {\n        maxvalue := i * j * k;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.166,
        "duration_formatted": "4.17s",
        "tokens": {
          "input": 1356,
          "output": 305,
          "total": 1661
        },
        "cost_usd": 0.005152,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:33:39.002136"
      }
    },
    {
      "file_path": "program_130.py",
      "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        end = str_index + 1\n        while end < len(input_string) + 1:\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n            end += 1\n        return False\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)",
      "program_specification": "```dafny\nmethod MatchWordPattern(pattern: seq<char>, inputString: seq<char>) returns (matches: bool)\n  ensures matches ==> |pattern| > 0 ==> exists f: map<char, seq<char>> ::\n    (forall i :: 0 <= i < |pattern| ==> pattern[i] in f)\n    && (forall i, j :: 0 <= i < |pattern| && 0 <= j < |pattern| && i != j ==> pattern[i] != pattern[j] ==> f[pattern[i]] != f[pattern[j]])\n    && inputString == SeqConcat(Seq(Seq(f[pattern[i]]) | i : int :: 0 <= i < |pattern|))\n  ensures !matches ==> forall f: map<char, seq<char>> ::\n    (forall i :: 0 <= i < |pattern| ==> pattern[i] in f)\n    && (forall i, j :: 0 <= i < |pattern| && 0 <= j < |pattern| && i != j ==> pattern[i] != pattern[j] ==> f[pattern[i]] != f[pattern[j]])\n    ==> inputString != SeqConcat(Seq(Seq(f[pattern[i]]) | i : int :: 0 <= i < |pattern|))\n{\n  matches := MatchWordPatternRec(pattern, inputString, 0, 0, map[], map[]);\n}\n\nfunction method SeqConcat(ss: seq<seq<char>>): seq<char>\n{\n  if |ss| == 0 then [] else ss[0] + SeqConcat(ss[1..])\n}\n\nmethod MatchWordPatternRec(pattern: seq<char>, inputString: seq<char>, patternIndex: int, strIndex: int, patternMap: map<char, seq<char>>, strMap: map<seq<char>, char>) returns (res: bool)\n  requires 0 <= patternIndex <= |pattern|\n  requires 0 <= strIndex <= |inputString|\n  requires forall c :: c in patternMap ==> exists i :: 0 <= i < |pattern| && pattern[i] == c\n  requires forall s :: s in strMap ==> exists i :: 0 <= i < |inputString| // weak, for simplicity\n  decreases |pattern| - patternIndex, |inputString| - strIndex\n{\n  if patternIndex == |pattern| && strIndex == |inputString| {\n    res := true;\n    return;\n  }\n  if patternIndex == |pattern| || strIndex == |inputString| {\n    res := false;\n    return;\n  }\n  var char := pattern[patternIndex];\n  if char in patternMap {\n    var mappedStr := patternMap[char];\n    if strIndex + |mappedStr| <= |inputString| && inputString[strIndex .. strIndex + |mappedStr|] == mappedStr {\n      res := MatchWordPatternRec(pattern, inputString, patternIndex + 1, strIndex + |mappedStr|, patternMap, strMap);\n      return;\n    } else {\n      res := false;\n      return;\n    }\n  }\n  var end := strIndex + 1;\n  while end <= |inputString|\n    invariant strIndex < end <= |inputString| + 1\n    invariant 0 <= strIndex <= |inputString|\n    decreases |inputString| - end + 1\n  {\n    var substr := inputString[strIndex .. end];\n    if substr in strMap {\n      end := end + 1;\n      continue;\n    }\n    var newPatternMap := patternMap[char := substr];\n    var newStrMap := strMap[substr := char];\n    if MatchWordPatternRec(pattern, inputString, patternIndex + 1, end, newPatternMap, newStrMap) {\n      res := true;\n      return;\n    }\n    end := end + 1;\n  }\n  res := false;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 12.56,
        "duration_formatted": "12.56s",
        "tokens": {
          "input": 1670,
          "output": 805,
          "total": 2475
        },
        "cost_usd": 0.00978,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:33:56.596235"
      }
    },
    {
      "file_path": "program_131.py",
      "code": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n:\n            if arr[i] > arr[j]:\n                inv_count += 1\n            j += 1\n        i += 1\n    return inv_count",
      "program_specification": "```dafny\nmethod GetInvCount(arr: array<int>, n: int) returns (inv_count: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  ensures 0 <= inv_count <= n * (n - 1) / 2\n  ensures inv_count == |set i, j | 0 <= i < j < n && arr[i] > arr[j]|\n{\n  inv_count := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= inv_count <= n * (n - 1) / 2\n    invariant inv_count == |set x, y | 0 <= x < y < n && x < i && arr[x] > arr[y]|\n    decreases n - i\n  {\n    var j := i + 1;\n    while j < n\n      invariant i + 1 <= j <= n\n      invariant 0 <= inv_count <= n * (n - 1) / 2\n      invariant inv_count == |set x, y | 0 <= x < y < n && (x < i || (x == i && y < j)) && arr[x] > arr[y]|\n      decreases n - j\n    {\n      if arr[i] > arr[j] {\n        inv_count := inv_count + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 11.723,
        "duration_formatted": "11.72s",
        "tokens": {
          "input": 1340,
          "output": 319,
          "total": 1659
        },
        "cost_usd": 0.005232,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:34:13.372620"
      }
    },
    {
      "file_path": "program_133.py",
      "code": "def frequency_Of_Largest(n, arr):\n    mn = arr[0]\n    freq = 1\n    i = 1\n    while i < n:\n        if arr[i] > mn:\n            mn = arr[i]\n            freq = 1\n        elif arr[i] == mn:\n            freq += 1\n        i += 1\n    return freq",
      "program_specification": "```dafny\nmethod FrequencyOfLargest(n: int, arr: array<int>) returns (freq: int)\n  requires arr != null\n  requires 1 <= n <= arr.Length\n  ensures 1 <= freq <= n\n  ensures exists v: int :: (forall i :: 0 <= i < n ==> arr[i] <= v) && freq == |set i | 0 <= i < n && arr[i] == v|\n{\n  var mn := arr[0];\n  freq := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= n <= arr.Length\n    invariant 1 <= freq <= i\n    invariant 1 <= i <= n\n    invariant exists v: int :: (forall j :: 0 <= j < i ==> arr[j] <= v) && freq == |set j | 0 <= j < i && arr[j] == v|\n    decreases n - i\n  {\n    if arr[i] > mn {\n      mn := arr[i];\n      freq := 1;\n    } else if arr[i] == mn {\n      freq := freq + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.135,
        "duration_formatted": "4.14s",
        "tokens": {
          "input": 1344,
          "output": 252,
          "total": 1596
        },
        "cost_usd": 0.004704,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:34:22.541022"
      }
    },
    {
      "file_path": "program_140.py",
      "code": "def count(s, c):\n    res = 0\n    i = 0\n    while i < len(s):\n        if s[i] == c:\n            res = res + 1\n        i += 1\n    return res",
      "program_specification": "```dafny\nmethod Count(s: seq<char>, c: char) returns (res: int)\n  ensures res >= 0\n  ensures res == |[i | i := 0 .. |s|, s[i] == c]|\n{\n  res := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant res == |[j | j := 0 .. i, s[j] == c]|\n    decreases |s| - i\n  {\n    if s[i] == c {\n      res := res + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.672,
        "duration_formatted": "2.67s",
        "tokens": {
          "input": 1316,
          "output": 145,
          "total": 1461
        },
        "cost_usd": 0.003792,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:34:30.246354"
      }
    },
    {
      "file_path": "program_141.py",
      "code": "def find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    for i in range(0, n, 1):\n        if str[i] == ' ':\n            if currlen % 2 == 0:\n                if maxlen < currlen:\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else:\n            currlen += 1\n    if currlen % 2 == 0:\n        if maxlen < currlen:\n            maxlen = currlen\n            st = i - currlen\n    if st == -1:\n        return '-1'\n    return str[st:st + maxlen]",
      "program_specification": "```dafny\nmethod FindMaxLenEven(s: seq<char>) returns (res: seq<char>)\n  ensures res == \"-1\" || (|res| % 2 == 0 && res in s && (forall t: seq<char> :: t in s && |t| % 2 == 0 ==> |res| >= |t|))\n{\n  var n := |s|;\n  var i := 0;\n  var currlen := 0;\n  var maxlen := 0;\n  var st := -1;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= currlen <= i\n    invariant 0 <= maxlen <= i\n    invariant -1 <= st < n\n    decreases n - i\n  {\n    if s[i] == ' ' {\n      if currlen % 2 == 0 {\n        if maxlen < currlen {\n          maxlen := currlen;\n          st := i - currlen;\n        }\n      }\n      currlen := 0;\n    } else {\n      currlen := currlen + 1;\n    }\n    i := i + 1;\n  }\n  if currlen % 2 == 0 {\n    if maxlen < currlen {\n      maxlen := currlen;\n      st := i - currlen;\n    }\n  }\n  if st == -1 {\n    res := \"-1\";\n  } else {\n    res := s[st .. st + maxlen];\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.966,
        "duration_formatted": "3.97s",
        "tokens": {
          "input": 1436,
          "output": 315,
          "total": 1751
        },
        "cost_usd": 0.005392,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:34:39.253310"
      }
    },
    {
      "file_path": "program_142.py",
      "code": "def unique_Characters(str):\n    i = 0\n    while i < len(str):\n        j = i + 1\n        while j < len(str):\n            if str[i] == str[j]:\n                return False\n            j += 1\n        i += 1\n    return True",
      "program_specification": "```dafny\nmethod UniqueCharacters(s: seq<char>) returns (res: bool)\n  ensures res ==> (forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j])\n  ensures (!res) ==> (exists i, j :: 0 <= i < j < |s| && s[i] == s[j])\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall x, y :: 0 <= x < y < i ==> s[x] != s[y]\n    decreases |s| - i\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n      decreases |s| - j\n    {\n      if s[i] == s[j] {\n        res := false;\n        return;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := true;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.563,
        "duration_formatted": "3.56s",
        "tokens": {
          "input": 1328,
          "output": 240,
          "total": 1568
        },
        "cost_usd": 0.004576,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:34:47.872019"
      }
    },
    {
      "file_path": "program_144.py",
      "code": "def glob_to_regex_pattern(glob: str) -> str:\n    tokens = ['^']\n    in_group = False\n    i = 0\n    for i in range(0, len(glob), 1):\n        c = glob[i]\n        if c == '\\\\' and i + 1 < len(glob):\n            char = glob[i + 1]\n            tokens.append('\\\\' + char if char in escaped_chars else char)\n            i += 1\n        elif c == '*':\n            before_deep = glob[i - 1] if i > 0 else None\n            star_count = 1\n            while i + 1 < len(glob) and glob[i + 1] == '*':\n                star_count += 1\n                i += 1\n            after_deep = glob[i + 1] if i + 1 < len(glob) else None\n            is_deep = star_count > 1 and (before_deep == '/' or before_deep is None) and (after_deep == '/' or after_deep is None)\n            if is_deep:\n                tokens.append('((?:[^/]*(?:/|$))*)')\n                i += 1\n            else:\n                tokens.append('([^/]*)')\n        elif c == '{':\n            in_group = True\n            tokens.append('(')\n        elif c == '}':\n            in_group = False\n            tokens.append(')')\n        elif c == ',':\n            if in_group:\n                tokens.append('|')\n            else:\n                tokens.append('\\\\' + c)\n        else:\n            tokens.append('\\\\' + c if c in escaped_chars else c)\n    tokens.append('$')\n    return ''.join(tokens)",
      "program_specification": "```dafny\nmethod GlobToRegexPattern(glob: seq<char>) returns (pattern: seq<char>)\n  requires glob != []\n  ensures |pattern| >= 2 // At least '^' and '$'\n{\n  var tokens := new seq<char>['^'];\n  var inGroup := false;\n  var i := 0;\n  while i < |glob|\n    invariant 0 <= i <= |glob|\n    invariant tokens != []\n    decreases |glob| - i\n  {\n    var c := glob[i];\n    if c == '\\\\' && i + 1 < |glob| {\n      var char := glob[i + 1];\n      // For simplicity, escape any char after '\\'\n      tokens := tokens + ['\\\\', char];\n      i := i + 2;\n    } else if c == '*' {\n      var beforeDeep: char?;\n      if i > 0 {\n        beforeDeep := glob[i - 1];\n      }\n      var starCount := 1;\n      var j := i + 1;\n      while j < |glob| && glob[j] == '*'\n        invariant i + 1 <= j <= |glob|\n        invariant starCount == j - i\n        decreases |glob| - j\n      {\n        starCount := starCount + 1;\n        j := j + 1;\n      }\n      var afterDeep: char?;\n      if j < |glob| {\n        afterDeep := glob[j];\n      }\n      var isDeep := starCount > 1 &&\n        (beforeDeep == null || beforeDeep.Value == '/') &&\n        (afterDeep == null || afterDeep.Value == '/');\n      if isDeep {\n        // Append ((?:[^/]*(?:/|$))*)\n        tokens := tokens +\n          ['(', '(', '?', ':', '[', '^', '/', ']', '*', '(', '?', ':', '/', '|', '$', ')', ')', '*', ')'];\n        i := j;\n      } else {\n        // Append ([^/]*)\n        tokens := tokens + ['(', '[', '^', '/', ']', '*', ')'];\n        i := i + 1;\n      }\n    } else if c == '{' {\n      inGroup := true;\n      tokens := tokens + ['('];\n      i := i + 1;\n    } else if c == '}' {\n      inGroup := false;\n      tokens := tokens + [')'];\n      i := i + 1;\n    } else if c == ',' {\n      if inGroup {\n        tokens := tokens + ['|'];\n      } else {\n        tokens := tokens + ['\\\\', ','];\n      }\n      i := i + 1;\n    } else {\n      // Escape special regex chars: . ^ $ + ? ( ) [ ] | \\\n      if c == '.' || c == '^' || c == '$' || c == '+' || c == '?' ||\n         c == '(' || c == ')' || c == '[' || c == ']' || c == '|' || c == '\\\\' {\n        tokens := tokens + ['\\\\', c];\n      } else {\n        tokens := tokens + [c];\n      }\n      i := i + 1;\n    }\n  }\n  tokens := tokens + ['$'];\n  pattern := tokens;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.036,
        "duration_formatted": "9.04s",
        "tokens": {
          "input": 1621,
          "output": 677,
          "total": 2298
        },
        "cost_usd": 0.008658,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:35:01.948341"
      }
    },
    {
      "file_path": "program_145.py",
      "code": "def min_Swaps(str1, str2):\n    count = 0\n    i = 0\n    while i < len(str1):\n        if str1[i] != str2[i]:\n            count += 1\n        i += 1\n    if count % 2 == 0:\n        return count // 2\n    else:\n        return 'Not Possible'",
      "program_specification": "```dafny\nmethod MinSwaps(str1: seq<char>, str2: seq<char>) returns (res: int)\n  requires |str1| == |str2|\n  ensures (exists k :: 0 <= k <= |str1| && (forall i :: 0 <= i < |str1| ==> (str1[i] != str2[i]) <==> (i < k && (str1[i] != str2[i]))) && k % 2 == 0 ==> res == k / 2) || res == -1\n  ensures (res >= 0) ==> (res * 2 == |seq i :: 0 <= i < |str1| && str1[i] != str2[i]|)\n  ensures (|seq i :: 0 <= i < |str1| && str1[i] != str2[i]|) % 2 == 1 ==> res == -1\n{\n  var count := 0;\n  var i := 0;\n  while i < |str1|\n    invariant 0 <= i <= |str1|\n    invariant 0 <= count <= i\n    invariant count == |seq j :: 0 <= j < i && str1[j] != str2[j]|\n    decreases |str1| - i\n  {\n    if str1[i] != str2[i] {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n  if count % 2 == 0 {\n    res := count / 2;\n  } else {\n    res := -1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.332,
        "duration_formatted": "5.33s",
        "tokens": {
          "input": 1345,
          "output": 338,
          "total": 1683
        },
        "cost_usd": 0.005394,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:35:12.315372"
      }
    },
    {
      "file_path": "program_154.py",
      "code": "def upper_ctr(str):\n    upper_ctr = 0\n    i = 0\n    while i < len(str):\n        if str[i] >= 'A' and str[i] <= 'Z':\n            upper_ctr += 1\n        return upper_ctr\n        i += 1",
      "program_specification": "```dafny\nmethod UpperCtr(s: seq<char>) returns (count: int)\n  ensures 0 <= count <= |s|\n  ensures count == |[i := 0 .. |s| - 1] where 'A' <= s[i] <= 'Z'|\n{\n  count := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant 0 <= count <= i\n    invariant count == |[j := 0 .. i - 1] where 'A' <= s[j] <= 'Z'|\n    decreases |s| - i\n  {\n    if 'A' <= s[i] <= 'Z' {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.532,
        "duration_formatted": "3.53s",
        "tokens": {
          "input": 1325,
          "output": 174,
          "total": 1499
        },
        "cost_usd": 0.004042,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:35:20.895350"
      }
    },
    {
      "file_path": "program_156.py",
      "code": "def sort_tuple(tup):\n    lst = len(tup)\n    i = 0\n    while i < lst:\n        j = 0\n        while j < lst - i - 1:\n            if tup[j][-1] > tup[j + 1][-1]:\n                temp = tup[j]\n                tup[j] = tup[j + 1]\n                tup[j + 1] = temp\n            j += 1\n        i += 1\n    return tup",
      "program_specification": "```dafny\nmethod SortTuple(tup: array<array<int>>) returns (res: array<array<int>>)\n  requires tup != null\n  requires forall k :: 0 <= k < tup.Length ==> tup[k] != null && tup[k].Length > 0\n  ensures res != null && res.Length == tup.Length\n  ensures forall k :: 0 <= k < res.Length ==> res[k] != null && res[k].Length > 0\n  ensures multiset{tup[i][j] | i, j :: 0 <= i < tup.Length && 0 <= j < tup[i].Length} ==\n          multiset{res[i][j] | i, j :: 0 <= i < res.Length && 0 <= j < res[i].Length}\n  ensures forall i, j :: 0 <= i < j < res.Length ==> res[i][res[i].Length-1] <= res[j][res[j].Length-1]\n{\n  res := new array<array<int>>(tup.Length);\n  var k := 0;\n  while k < tup.Length\n    invariant 0 <= k <= tup.Length\n    invariant forall i :: 0 <= i < k ==> res[i] == tup[i]\n    decreases tup.Length - k\n  {\n    res[k] := tup[k];\n    k := k + 1;\n  }\n\n  var n := res.Length;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    var j := 0;\n    while j < n - i - 1\n      invariant 0 <= j <= n - i - 1\n      invariant n == res.Length\n      decreases n - i - 1 - j\n    {\n      if res[j][res[j].Length - 1] > res[j + 1][res[j + 1].Length - 1] {\n        var temp := res[j];\n        res[j] := res[j + 1];\n        res[j + 1] := temp;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.183,
        "duration_formatted": "8.18s",
        "tokens": {
          "input": 1366,
          "output": 459,
          "total": 1825
        },
        "cost_usd": 0.006404,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:35:34.113075"
      }
    },
    {
      "file_path": "program_169.py",
      "code": "def maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 10)\n    dp[0] = 0\n    i = 0\n    while i < n:\n        if dp[i] != -1:\n            if i + a <= n:\n                dp[i + a] = max(dp[i] + 1, dp[i + a])\n            if i + b <= n:\n                dp[i + b] = max(dp[i] + 1, dp[i + b])\n            if i + c <= n:\n                dp[i + c] = max(dp[i] + 1, dp[i + c])\n        i += 1\n    return dp[n]",
      "program_specification": "```dafny\nmethod MaximumSegments(n: int, a: int, b: int, c: int) returns (res: int)\n  requires n >= 0\n  requires a > 0 && b > 0 && c > 0\n  ensures res >= -1\n  // ensures: if res >= 0, then n can be written as a sum of res segments of length a, b, c (with repetition)\n{\n  var dp := new int[n + 10];\n  var i: int := 0;\n  while i < n + 10\n    invariant 0 <= i <= n + 10\n    invariant dp.Length == n + 10\n    decreases n + 10 - i\n  {\n    dp[i] := -1;\n    i := i + 1;\n  }\n  dp[0] := 0;\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant dp[0] == 0\n    invariant dp.Length == n + 10\n    decreases n - i\n  {\n    if dp[i] != -1 {\n      if i + a <= n {\n        if dp[i + a] < dp[i] + 1 {\n          dp[i + a] := dp[i] + 1;\n        }\n      }\n      if i + b <= n {\n        if dp[i + b] < dp[i] + 1 {\n          dp[i + b] := dp[i] + 1;\n        }\n      }\n      if i + c <= n {\n        if dp[i + c] < dp[i] + 1 {\n          dp[i + c] := dp[i] + 1;\n        }\n      }\n    }\n    i := i + 1;\n  }\n  res := dp[n];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.908,
        "duration_formatted": "5.91s",
        "tokens": {
          "input": 1414,
          "output": 383,
          "total": 1797
        },
        "cost_usd": 0.005892,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:35:45.057697"
      }
    },
    {
      "file_path": "program_176.py",
      "code": "def first_Missing_Positive(arr, n):\n    ptr = 0\n    i = 0\n    while i < n:\n        if arr[i] == 1:\n            ptr = 1\n            break\n        i += 1\n    if ptr == 0:\n        return 1\n    i = 0\n    while i < n:\n        if arr[i] <= 0 or arr[i] > n:\n            arr[i] = 1\n        i += 1\n    i = 0\n    while i < n:\n        arr[(arr[i] - 1) % n] += n\n        i += 1\n    i = 0\n    while i < n:\n        if arr[i] <= n:\n            return i + 1\n        i += 1\n    return n + 1",
      "program_specification": "```dafny\nmethod FirstMissingPositive(arr: array<int>, n: int) returns (res: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  ensures 1 <= res <= n + 1\n{\n  var ptr := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant ptr == 1 ==> exists j :: 0 <= j < i && arr[j] == 1\n    invariant ptr == 0 ==> forall j :: 0 <= j < i ==> arr[j] != 1\n    decreases n - i\n  {\n    if arr[i] == 1 {\n      ptr := 1;\n      break;\n    }\n    i := i + 1;\n  }\n  if ptr == 0 {\n    res := 1;\n    return;\n  }\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    if arr[i] <= 0 || arr[i] > n {\n      arr[i] := 1;\n    }\n    i := i + 1;\n  }\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    var idx := (arr[i] - 1) % n;\n    if idx < 0 {\n      idx := idx + n;\n    }\n    arr[idx] := arr[idx] + n;\n    i := i + 1;\n  }\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    if arr[i] <= n {\n      res := i + 1;\n      return;\n    }\n    i := i + 1;\n  }\n  res := n + 1;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.771,
        "duration_formatted": "5.77s",
        "tokens": {
          "input": 1444,
          "output": 400,
          "total": 1844
        },
        "cost_usd": 0.006088,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:35:55.890996"
      }
    },
    {
      "file_path": "program_181.py",
      "code": "def get_output_shapes(model_data):\n    \"\"\"Returns a list of output shapes in the tflite model data.\"\"\"\n    model = schema_fb.Model.GetRootAsModel(model_data, 0)\n    output_shapes = []\n    subgraph_idx = 0\n    while subgraph_idx < model.SubgraphsLength():\n        subgraph = model.Subgraphs(subgraph_idx)\n        output_idx = 0\n        while output_idx < subgraph.OutputsLength():\n            output_tensor_idx = subgraph.Outputs(output_idx)\n            output_tensor = subgraph.Tensors(output_tensor_idx)\n            output_shapes.append(output_tensor.ShapeAsNumpy().tolist())\n            output_idx += 1\n        subgraph_idx += 1\n    return output_shapes",
      "program_specification": "```dafny\nmethod GetOutputShapes(modelData: array<byte>) returns (outputShapes: seq<seq<int>>)\n  requires modelData != null\n  ensures outputShapes != null\n{\n  // As we cannot model the internals of schema_fb.Model in Dafny,\n  // we specify only that the result is a sequence of sequences of integers.\n  // The method body is left empty as a stub, since modeling the actual\n  // FlatBuffers logic is out of Dafny's scope.\n  outputShapes := [];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.329,
        "duration_formatted": "2.33s",
        "tokens": {
          "input": 1414,
          "output": 110,
          "total": 1524
        },
        "cost_usd": 0.003708,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:36:03.254572"
      }
    },
    {
      "file_path": "program_187.py",
      "code": "def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:\n    \"\"\"\n    Perform topological sorting of a Directed Acyclic Graph (DAG)\n    using Kahn's Algorithm via Breadth-First Search (BFS).\n\n    Topological sorting is a linear ordering of vertices in a graph such that for\n    every directed edge u  v, vertex u comes before vertex v in the ordering.\n\n    Parameters:\n    graph: Adjacency list representing the directed graph where keys are\n           vertices, and values are lists of adjacent vertices.\n\n    Returns:\n    The topologically sorted order of vertices if the graph is a DAG.\n    Returns None if the graph contains a cycle.\n\n    Example:\n    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n    >>> topological_sort(graph)\n    [0, 1, 2, 3, 4, 5]\n\n    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n    >>> topological_sort(graph_with_cycle)\n    \"\"\"\n    indegree = [0] * len(graph)\n    queue = []\n    topo_order = []\n    processed_vertices_count = 0\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n    i = 0\n    while i < len(indegree):\n        if indegree[i] == 0:\n            queue.append(i)\n        i += 1\n    while queue:\n        vertex = queue.pop(0)\n        processed_vertices_count += 1\n        topo_order.append(vertex)\n        for neighbor in graph[vertex]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    if processed_vertices_count != len(graph):\n        return None\n    return topo_order",
      "program_specification": "```dafny\nmethod TopologicalSort(graph: array<seq<int>>) returns (order: seq<int>?, hasOrder: bool)\n  requires graph != null\n  requires forall i :: 0 <= i < graph.Length ==> graph[i] != null\n  requires forall i :: 0 <= i < graph.Length ==> forall v :: 0 <= v < |graph[i]| ==> 0 <= graph[i][v] < graph.Length\n  ensures hasOrder ==> order != null && |order| == graph.Length\n  ensures hasOrder ==> (forall u, i :: 0 <= u < graph.Length && 0 <= i < |graph[u]| ==> \n                          var v := graph[u][i]; \n                          exists idxU, idxV :: 0 <= idxU < |order| && 0 <= idxV < |order| && order[idxU] == u && order[idxV] == v && idxU < idxV)\n  ensures !hasOrder ==> order == null\n{\n  var n := graph.Length;\n  var indegree := new int[n];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall j :: 0 <= j < i ==> indegree[j] == 0\n    decreases n - i\n  {\n    indegree[i] := 0;\n    i := i + 1;\n  }\n  // Compute indegrees\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    var j := 0;\n    while j < |graph[i]|\n      invariant 0 <= j <= |graph[i]|\n      decreases |graph[i]| - j\n    {\n      var v := graph[i][j];\n      indegree[v] := indegree[v] + 1;\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n\n  var queue := new int[n];\n  var qStart := 0;\n  var qEnd := 0;\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= qEnd <= n\n    decreases n - i\n  {\n    if indegree[i] == 0 {\n      queue[qEnd] := i;\n      qEnd := qEnd + 1;\n    }\n    i := i + 1;\n  }\n\n  var topo := new int[n];\n  var topoLen := 0;\n  var processed := 0;\n  while qStart < qEnd\n    invariant 0 <= qStart <= qEnd <= n\n    invariant 0 <= topoLen <= n\n    invariant processed == topoLen\n    decreases n - processed\n  {\n    var u := queue[qStart];\n    qStart := qStart + 1;\n    topo[topoLen] := u;\n    topoLen := topoLen + 1;\n    processed := processed + 1;\n\n    var j := 0;\n    while j < |graph[u]|\n      invariant 0 <= j <= |graph[u]|\n      decreases |graph[u]| - j\n    {\n      var v := graph[u][j];\n      indegree[v] := indegree[v] - 1;\n      if indegree[v] == 0 {\n        queue[qEnd] := v;\n        qEnd := qEnd + 1;\n      }\n      j := j + 1;\n    }\n  }\n\n  if processed != n {\n    order := null;\n    hasOrder := false;\n    return;\n  }\n  var res := [];\n  i := 0;\n  while i < topoLen\n    invariant 0 <= i <= topoLen <= n\n    invariant |res| == i\n    decreases topoLen - i\n  {\n    res := res + [topo[i]];\n    i := i + 1;\n  }\n  order := res;\n  hasOrder := true;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 12.031,
        "duration_formatted": "12.03s",
        "tokens": {
          "input": 1681,
          "output": 831,
          "total": 2512
        },
        "cost_usd": 0.01001,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:36:20.324742"
      }
    },
    {
      "file_path": "program_189.py",
      "code": "import math\n\ndef max_Prime_Factors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    i = 3\n    while i < int(math.sqrt(n)) + 1:\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n        i += 2\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)",
      "program_specification": "```dafny\nmethod MaxPrimeFactors(n: int) returns (maxPrime: int)\n  requires n > 0\n  ensures maxPrime > 0 ==> n % maxPrime == 0\n  ensures maxPrime <= n\n{\n  var m := n;\n  maxPrime := -1;\n\n  // Remove all factors of 2\n  while m % 2 == 0\n    invariant m > 0\n    invariant 1 <= m <= n\n    invariant maxPrime == -1 || maxPrime == 2\n    decreases m\n  {\n    maxPrime := 2;\n    m := m / 2;\n  }\n\n  var i := 3;\n  var bound := if m > 1 then (if Sqrt(m) * Sqrt(m) == m then Sqrt(m) else Sqrt(m) + 1) else 2;\n  while i <= bound && m > 1\n    invariant i >= 3 && i <= n + 2\n    invariant m > 0\n    invariant 1 <= m <= n\n    invariant maxPrime == -1 || (maxPrime % 2 == 1 && maxPrime <= i)\n    decreases n - i\n  {\n    while m % i == 0\n      invariant m > 0\n      invariant 1 <= m <= n\n      invariant maxPrime == -1 || maxPrime <= i\n      decreases m\n    {\n      maxPrime := i;\n      m := m / i;\n    }\n    i := i + 2;\n  }\n  if m > 2 {\n    maxPrime := m;\n  }\n  if maxPrime == -1 {\n    maxPrime := n;\n  }\n}\n\nfunction Sqrt(x: int): int\n  requires x >= 0\n  ensures Sqrt(x) * Sqrt(x) <= x < (Sqrt(x)+1)*(Sqrt(x)+1)\n{\n  if x == 0 then 0\n  else if x == 1 then 1\n  else\n    var l := 1;\n    var r := x;\n    while l < r\n      invariant 1 <= l <= r <= x\n      invariant l * l <= x\n      decreases r - l\n    {\n      var m := (l + r + 1) / 2;\n      if m * m <= x {\n        l := m;\n      } else {\n        r := m - 1;\n      }\n    }\n    l\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.649,
        "duration_formatted": "6.65s",
        "tokens": {
          "input": 1372,
          "output": 520,
          "total": 1892
        },
        "cost_usd": 0.006904,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:36:32.025098"
      }
    },
    {
      "file_path": "program_200.py",
      "code": "def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if partitions <= 0:\n        raise ValueError('partitions must be a positive number!')\n    if partitions > number_of_bytes:\n        raise ValueError('partitions can not > number_of_bytes!')\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    i = 0\n    while i < partitions:\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        allocation_list.append(f'{start_bytes}-{end_bytes}')\n        i += 1\n    return allocation_list",
      "program_specification": "```dafny\nmethod AllocationNum(number_of_bytes: int, partitions: int) returns (allocation_list: seq<string>)\n  requires partitions > 0\n  requires partitions <= number_of_bytes\n  ensures |allocation_list| == partitions\n  ensures forall i :: 0 <= i < partitions ==>\n    var s := allocation_list[i];\n    var dash := s.IndexOf(\"-\");\n    dash > 0 &&\n    var start := s[..dash].ParseInt();\n    var end := s[(dash+1)..].ParseInt();\n    1 <= start <= end <= number_of_bytes &&\n    (i == 0 ==> start == 1) &&\n    (i == partitions-1 ==> end == number_of_bytes)\n{\n  var bytes_per_partition := number_of_bytes / partitions;\n  var i := 0;\n  var alloc: seq<string> := [];\n  while i < partitions\n    invariant 0 <= i <= partitions\n    invariant |alloc| == i\n    invariant forall j :: 0 <= j < i ==>\n      var s := alloc[j];\n      var dash := s.IndexOf(\"-\");\n      dash > 0 &&\n      var start := s[..dash].ParseInt();\n      var end := s[(dash+1)..].ParseInt();\n      1 <= start <= end <= number_of_bytes &&\n      (j == 0 ==> start == 1)\n    decreases partitions - i\n  {\n    var start_bytes := i * bytes_per_partition + 1;\n    var end_bytes := if i == partitions - 1 then number_of_bytes else (i + 1) * bytes_per_partition;\n    var s := start_bytes.ToString() + \"-\" + end_bytes.ToString();\n    alloc := alloc + [s];\n    i := i + 1;\n  }\n  allocation_list := alloc;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.132,
        "duration_formatted": "6.13s",
        "tokens": {
          "input": 1619,
          "output": 376,
          "total": 1995
        },
        "cost_usd": 0.006246,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:36:43.196464"
      }
    },
    {
      "file_path": "program_203.py",
      "code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return 'Input is not an integer!'\n    if limit < 1:\n        return 'Input must be bigger than 0!'\n    amicables = set()\n    num = 2\n    while num < limit + 1:\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n        num += 1\n    return sum(amicables)",
      "program_specification": "```dafny\nmethod AmicableNumbersSum(limit: int) returns (total: int)\n  requires limit >= 1\n  ensures total >= 0\n{\n  var amicables := set int{};\n  var num := 2;\n  while num < limit + 1\n    invariant num >= 2 && num <= limit + 1\n    invariant forall x :: 2 <= x < num ==> (x in amicables) ==> (exists y :: 2 <= y <= limit && y != x && SumOfProperDivisors(x) == y && SumOfProperDivisors(y) == x)\n    invariant amicables <= set x | 2 <= x < num && exists y :: 2 <= y <= limit && y != x && SumOfProperDivisors(x) == y && SumOfProperDivisors(y) == x\n    decreases limit + 1 - num\n  {\n    if num in amicables {\n      num := num + 1;\n      continue;\n    }\n    var sum_fact := SumOfProperDivisors(num);\n    if sum_fact != num && sum_fact >= 2 && sum_fact <= limit {\n      var sum_fact2 := SumOfProperDivisors(sum_fact);\n      if num == sum_fact2 {\n        amicables := amicables + {num, sum_fact};\n      }\n    }\n    num := num + 1;\n  }\n  total := 0;\n  var it := amicables;\n  while |it| > 0\n    invariant total >= 0\n    invariant it <= amicables\n    invariant amicables == it + (amicables - it)\n    decreases |it|\n  {\n    var x: int :| x in it;\n    total := total + x;\n    it := it - {x};\n  }\n}\n\nfunction SumOfProperDivisors(n: int): int\n  requires n >= 1\n  ensures SumOfProperDivisors(n) == sum k | 1 <= k < n && n % k == 0 :: k\n{\n  if n == 1 then 0\n  else sum k | 1 <= k < n && n % k == 0 :: k\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.885,
        "duration_formatted": "8.89s",
        "tokens": {
          "input": 1429,
          "output": 461,
          "total": 1890
        },
        "cost_usd": 0.006546,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:36:57.118611"
      }
    },
    {
      "file_path": "program_206.py",
      "code": "def lcp_w_suffix_str(array, s):\n    N = len(array)\n    lcp_array = [0] * N\n    inv_suffix = [0] * N\n    index = 0\n    while index < N:\n        inv_suffix[array[index]] = index\n        index += 1\n    maxLen = 0\n    index = 0\n    while index < N:\n        if inv_suffix[index] == N - 1:\n            maxLen = 0\n            continue\n        index_j = array[inv_suffix[index] + 1]\n        while index + maxLen < N and index_j + maxLen < N and (s[index + maxLen] == s[index_j + maxLen]):\n            maxLen += 1\n        lcp_array[inv_suffix[index]] = maxLen\n        if maxLen > 0:\n            maxLen -= 1\n        index += 1\n    return lcp_array",
      "program_specification": "```dafny\nmethod LcpWSuffixStr(array: array<int>, s: seq<char>) returns (lcpArray: array<int>)\n  requires array != null\n  requires lcpArray != null\n  requires array.Length == |s|\n  requires lcpArray.Length == array.Length\n  requires array.Length > 0\n  requires (forall i :: 0 <= i < array.Length ==> 0 <= array[i] < array.Length)\n  requires (forall i, j :: 0 <= i < array.Length && 0 <= j < array.Length && i != j ==> array[i] != array[j])\n  ensures lcpArray.Length == array.Length\n  ensures forall i :: 0 <= i < lcpArray.Length ==> 0 <= lcpArray[i] <= |s|\n{\n  var N := array.Length;\n  var invSuffix := new int[N];\n  var index := 0;\n  while index < N\n    invariant 0 <= index <= N\n    invariant forall k :: 0 <= k < index ==> 0 <= array[k] < N && invSuffix[array[k]] == k\n    decreases N - index\n  {\n    invSuffix[array[index]] := index;\n    index := index + 1;\n  }\n  var maxLen := 0;\n  index := 0;\n  while index < N\n    invariant 0 <= index <= N\n    invariant 0 <= maxLen <= N\n    decreases N - index\n  {\n    if invSuffix[index] == N - 1 {\n      maxLen := 0;\n      index := index + 1;\n      continue;\n    }\n    var index_j := array[invSuffix[index] + 1];\n    while index + maxLen < N && index_j + maxLen < N && s[index + maxLen] == s[index_j + maxLen]\n      invariant 0 <= maxLen <= N\n      decreases N - maxLen\n    {\n      maxLen := maxLen + 1;\n    }\n    lcpArray[invSuffix[index]] := maxLen;\n    if maxLen > 0 {\n      maxLen := maxLen - 1;\n    }\n    index := index + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.988,
        "duration_formatted": "4.99s",
        "tokens": {
          "input": 1463,
          "output": 461,
          "total": 1924
        },
        "cost_usd": 0.006614,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:37:07.144695"
      }
    },
    {
      "file_path": "program_208.py",
      "code": "def divisor(n):\n    i = 0\n    while i < n:\n        x = len([i for i in range(1, n + 1) if not n % i])\n        i += 1\n    return x",
      "program_specification": "```dafny\nmethod Divisor(n: int) returns (x: int)\n  requires n > 0\n  ensures x == |seq i :: 1 <= i <= n && n % i == 0|\n{\n  var i := 0;\n  x := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant x == |seq j :: 1 <= j <= n && n % j == 0|\n    decreases n - i\n  {\n    // This assignment is redundant, but we mimic the original structure.\n    x := |seq j :: 1 <= j <= n && n % j == 0|;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.426,
        "duration_formatted": "2.43s",
        "tokens": {
          "input": 1315,
          "output": 152,
          "total": 1467
        },
        "cost_usd": 0.003846,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:37:14.609517"
      }
    },
    {
      "file_path": "program_217.py",
      "code": "def reverse_bit(number: int) -> str:\n    \"\"\"\n    Take in an 32 bit integer, reverse its bits,\n    return a string of reverse bits\n\n    result of a reverse_bit and operation on the integer provided.\n\n    >>> reverse_bit(25)\n    '00000000000000000000000000011001'\n    >>> reverse_bit(37)\n    '00000000000000000000000000100101'\n    >>> reverse_bit(21)\n    '00000000000000000000000000010101'\n    >>> reverse_bit(58)\n    '00000000000000000000000000111010'\n    >>> reverse_bit(0)\n    '00000000000000000000000000000000'\n    >>> reverse_bit(256)\n    '00000000000000000000000100000000'\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be positive\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if number < 0:\n        raise ValueError('the value of input must be positive')\n    elif isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    elif isinstance(number, str):\n        raise TypeError(\"'<' not supported between instances of 'str' and 'int'\")\n    result = 0\n    _ = 1\n    while _ < 33:\n        result = result << 1\n        end_bit = number % 2\n        number = number >> 1\n        result = result | end_bit\n        _ += 1\n    return get_reverse_bit_string(result)",
      "program_specification": "```dafny\nmethod ReverseBit(number: int) returns (s: string)\n  requires number >= 0\n  ensures |s| == 32\n  ensures forall i :: 0 <= i < 32 ==> s[i] == '0' || s[i] == '1'\n{\n  var n := number;\n  var result := 0;\n  var i := 0;\n  while i < 32\n    invariant 0 <= i <= 32\n    invariant n >= 0\n    invariant result >= 0\n    decreases 32 - i\n  {\n    result := result << 1;\n    var end_bit := n % 2;\n    n := n >> 1;\n    result := result | end_bit;\n    i := i + 1;\n  }\n  s := GetReverseBitString(result);\n}\n\nmethod GetReverseBitString(x: int) returns (s: string)\n  requires x >= 0\n  ensures |s| == 32\n  ensures forall i :: 0 <= i < 32 ==> s[i] == '0' || s[i] == '1'\n{\n  var chars := new char[32];\n  var i := 31;\n  var y := x;\n  while i >= 0\n    invariant -1 <= i <= 31\n    invariant y >= 0\n    invariant chars != null && chars.Length == 32\n    decreases i + 1\n  {\n    if (y % 2 == 1) {\n      chars[i] := '1';\n    } else {\n      chars[i] := '0';\n    }\n    y := y / 2;\n    i := i - 1;\n  }\n  s := chars[..].ToString();\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.008,
        "duration_formatted": "4.01s",
        "tokens": {
          "input": 1672,
          "output": 366,
          "total": 2038
        },
        "cost_usd": 0.006272,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:37:23.671554"
      }
    },
    {
      "file_path": "program_224.py",
      "code": "import sys\n\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    i = num + 1\n    while i < sys.maxsize:\n        if str(i) == str(i)[::-1]:\n            return i\n        i += 1",
      "program_specification": "```dafny\nmethod NextSmallestPalindrome(num: int) returns (p: int)\n  requires num >= 0\n  ensures p > num\n  ensures var s := p.ToString(); s == s[..|s|][..][..|s|][..][..|s|]; s == s[..][..|s|][..][..|s|][..|s|]; s == s[..][..|s|][..][..|s|][..|s|] && (forall k :: 0 <= k < |s| ==> s[k] == s[|s|-1-k])\n  ensures p >= 0\n{\n  var i := num + 1;\n  while true\n    invariant i > num\n    invariant i >= 1\n    decreases sys.maxsize - i\n  {\n    var s := i.ToString();\n    var isPalindrome := true;\n    var j := 0;\n    while j < |s| / 2\n      invariant 0 <= j <= |s| / 2\n      invariant isPalindrome ==> (forall k :: 0 <= k < j ==> s[k] == s[|s|-1-k])\n      decreases |s| / 2 - j\n    {\n      if s[j] != s[|s|-1-j] {\n        isPalindrome := false;\n        break;\n      }\n      j := j + 1;\n    }\n    if isPalindrome {\n      p := i;\n      return;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.258,
        "duration_formatted": "6.26s",
        "tokens": {
          "input": 1321,
          "output": 328,
          "total": 1649
        },
        "cost_usd": 0.005266,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:37:34.977958"
      }
    },
    {
      "file_path": "program_227.py",
      "code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n    if number <= 0:\n        msg = f'n must be greater than 0. Got n = {number}'\n        raise ValueError(msg)\n    table = [number + 1] * (number + 1)\n    table[1] = 0\n    i = 1\n    while i < number:\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n        i += 1\n    return table[number]",
      "program_specification": "```dafny\nmethod MinStepsToOne(number: int) returns (steps: int)\n  requires number > 0\n  ensures steps >= 0\n  // ensures: steps is the minimal number of steps to reduce number to 1 by allowed moves\n{\n  var table := new int[number + 1];\n  var i: int := 0;\n  // Initialize table with number + 1 (impossible high value)\n  while i <= number\n    invariant 0 <= i <= number + 1\n    invariant forall j :: 0 <= j < i ==> table[j] >= 0\n    decreases number + 1 - i\n  {\n    table[i] := number + 1;\n    i := i + 1;\n  }\n  table[1] := 0;\n  i := 1;\n  while i < number\n    invariant 1 <= i <= number\n    invariant table[1] == 0\n    invariant forall k :: 1 <= k <= i ==> table[k] >= 0\n    decreases number - i\n  {\n    if i + 1 <= number {\n      if table[i + 1] > table[i] + 1 {\n        table[i + 1] := table[i] + 1;\n      }\n    }\n    if i * 2 <= number {\n      if table[i * 2] > table[i] + 1 {\n        table[i * 2] := table[i] + 1;\n      }\n    }\n    if i * 3 <= number {\n      if table[i * 3] > table[i] + 1 {\n        table[i * 3] := table[i] + 1;\n      }\n    }\n    i := i + 1;\n  }\n  steps := table[number];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.765,
        "duration_formatted": "4.76s",
        "tokens": {
          "input": 1504,
          "output": 375,
          "total": 1879
        },
        "cost_usd": 0.006008,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:37:44.798447"
      }
    },
    {
      "file_path": "program_228.py",
      "code": "def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n\n    A matrix multiplied with its inverse gives the identity matrix.\n\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n\n    [[0.0, 0.5], [0.2, -0.2]]\n\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    \"\"\"\n    d = Decimal\n    if len(matrix) == 2 and len(matrix[0]) == 2 and (len(matrix[1]) == 2):\n        determinant = float(d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1]))\n        if determinant == 0:\n            raise ValueError('This matrix has no inverse.')\n        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\n        swapped_matrix[0][0], swapped_matrix[1][1] = (matrix[1][1], matrix[0][0])\n        swapped_matrix[1][0], swapped_matrix[0][1] = (-matrix[1][0], -matrix[0][1])\n        return [[float(d(n)) / determinant or 0.0 for n in row] for row in swapped_matrix]\n    elif len(matrix) == 3 and len(matrix[0]) == 3 and (len(matrix[1]) == 3) and (len(matrix[2]) == 3):\n        determinant = float(d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]) + d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]) + d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]) - (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]) + d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]) + d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1])))\n        if determinant == 0:\n            raise ValueError('This matrix has no inverse.')\n        cofactor_matrix = [[d(0.0), d(0.0), d(0.0)], [d(0.0), d(0.0), d(0.0)], [d(0.0), d(0.0), d(0.0)]]\n        cofactor_matrix[0][0] = d(matrix[1][1]) * d(matrix[2][2]) - d(matrix[1][2]) * d(matrix[2][1])\n        cofactor_matrix[0][1] = -(d(matrix[1][0]) * d(matrix[2][2]) - d(matrix[1][2]) * d(matrix[2][0]))\n        cofactor_matrix[0][2] = d(matrix[1][0]) * d(matrix[2][1]) - d(matrix[1][1]) * d(matrix[2][0])\n        cofactor_matrix[1][0] = -(d(matrix[0][1]) * d(matrix[2][2]) - d(matrix[0][2]) * d(matrix[2][1]))\n        cofactor_matrix[1][1] = d(matrix[0][0]) * d(matrix[2][2]) - d(matrix[0][2]) * d(matrix[2][0])\n        cofactor_matrix[1][2] = -(d(matrix[0][0]) * d(matrix[2][1]) - d(matrix[0][1]) * d(matrix[2][0]))\n        cofactor_matrix[2][0] = d(matrix[0][1]) * d(matrix[1][2]) - d(matrix[0][2]) * d(matrix[1][1])\n        cofactor_matrix[2][1] = -(d(matrix[0][0]) * d(matrix[1][2]) - d(matrix[0][2]) * d(matrix[1][0]))\n        cofactor_matrix[2][2] = d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[0][1]) * d(matrix[1][0])\n        adjoint_matrix = array(cofactor_matrix)\n        i = 0\n        while i < 3:\n            j = 0\n            while j < 3:\n                adjoint_matrix[i][j] = cofactor_matrix[j][i]\n                j += 1\n            i += 1\n        inverse_matrix = array(cofactor_matrix)\n        i = 0\n        while i < 3:\n            j = 0\n            while j < 3:\n                inverse_matrix[i][j] /= d(determinant)\n                j += 1\n            i += 1\n        return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]\n    raise ValueError('Please provide a matrix of size 2x2 or 3x3.')",
      "program_specification": "```dafny\n// Helper: Determinant of 2x2 matrix\nfunction Determinant2x2(m: seq<seq<real>>): real\n  requires |m| == 2 && |m[0]| == 2 && |m[1]| == 2\n{\n  m[0][0] * m[1][1] - m[0][1] * m[1][0]\n}\n\n// Helper: Determinant of 3x3 matrix\nfunction Determinant3x3(m: seq<seq<real>>): real\n  requires |m| == 3 && |m[0]| == 3 && |m[1]| == 3 && |m[2]| == 3\n{\n  m[0][0]*m[1][1]*m[2][2] + m[0][1]*m[1][2]*m[2][0] + m[0][2]*m[1][0]*m[2][1]\n  - m[0][2]*m[1][1]*m[2][0] - m[0][1]*m[1][0]*m[2][2] - m[0][0]*m[1][2]*m[2][1]\n}\n\n// Helper: 2x2 matrix inverse\nmethod Inverse2x2(m: seq<seq<real>>) returns (inv: seq<seq<real>>)\n  requires |m| == 2 && |m[0]| == 2 && |m[1]| == 2\n  requires Determinant2x2(m) != 0.0\n  ensures |inv| == 2 && |inv[0]| == 2 && |inv[1]| == 2\n{\n  var det := Determinant2x2(m);\n  var a := m[0][0];\n  var b := m[0][1];\n  var c := m[1][0];\n  var d := m[1][1];\n  inv := [\n    [d/det, -b/det],\n    [-c/det, a/det]\n  ];\n}\n\n// Helper: 3x3 matrix cofactor matrix\nmethod Cofactor3x3(m: seq<seq<real>>) returns (cof: seq<seq<real>>)\n  requires |m| == 3 && |m[0]| == 3 && |m[1]| == 3 && |m[2]| == 3\n  ensures |cof| == 3 && |cof[0]| == 3 && |cof[1]| == 3 && |cof[2]| == 3\n{\n  cof := [\n    [\n      m[1][1]*m[2][2] - m[1][2]*m[2][1],\n      -(m[1][0]*m[2][2] - m[1][2]*m[2][0]),\n      m[1][0]*m[2][1] - m[1][1]*m[2][0]\n    ],\n    [\n      -(m[0][1]*m[2][2] - m[0][2]*m[2][1]),\n      m[0][0]*m[2][2] - m[0][2]*m[2][0],\n      -(m[0][0]*m[2][1] - m[0][1]*m[2][0])\n    ],\n    [\n      m[0][1]*m[1][2] - m[0][2]*m[1][1],\n      -(m[0][0]*m[1][2] - m[0][2]*m[1][0]),\n      m[0][0]*m[1][1] - m[0][1]*m[1][0]\n    ]\n  ];\n}\n\n// Helper: transpose 3x3 matrix\nmethod Transpose3x3(m: seq<seq<real>>) returns (t: seq<seq<real>>)\n  requires |m| == 3 && |m[0]| == 3 && |m[1]| == 3 && |m[2]| == 3\n  ensures |t| == 3 && |t[0]| == 3 && |t[1]| == 3 && |t[2]| == 3\n{\n  t := [\n    [m[0][0], m[1][0], m[2][0]],\n    [m[0][1], m[1][1], m[2][1]],\n    [m[0][2], m[1][2], m[2][2]]\n  ];\n}\n\n// Helper: scale 3x3 matrix by 1/det\nmethod Scale3x3(m: seq<seq<real>>, det: real) returns (r: seq<seq<real>>)\n  requires |m| == 3 && |m[0]| == 3 && |m[1]| == 3 && |m[2]| == 3\n  requires det != 0.0\n  ensures |r| == 3 && |r[0]| == 3 && |r[1]| == 3 && |r[2]| == 3\n{\n  r := [\n    [m[0][0]/det, m[0][1]/det, m[0][2]/det],\n    [m[1][0]/det, m[1][1]/det, m[1][2]/det],\n    [m[2][0]/det, m[2][1]/det, m[2][2]/det]\n  ];\n}\n\nmethod InverseOfMatrix(matrix: seq<seq<real>>) returns (inv: seq<seq<real>>)\n  requires (|matrix| == 2 && |matrix[0]| == 2 && |matrix[1]| == 2) ||\n           (|matrix| == 3 && |matrix[0]| == 3 && |matrix[1]| == 3 && |matrix[2]| == 3)\n  requires (|matrix| == 2 ==> Determinant2x2(matrix) != 0.0) &&\n           (|matrix| == 3 ==> Determinant3x3(matrix) != 0.0)\n  ensures (|matrix| == 2 ==> |inv| == 2 && |inv[0]| == 2 && |inv[1]| == 2)\n  ensures (|matrix| == 3 ==> |inv| == 3 && |inv[0]| == 3 && |inv[1]| == 3 && |inv[2]| == 3)\n{\n  if |matrix| == 2 {\n    inv := Inverse2x2(matrix);\n  } else {\n    var det := Determinant3x3(matrix);\n    var cof := Cofactor3x3(matrix);\n    var adj := Transpose3x3(cof);\n    inv := Scale3x3(adj, det);\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 15.961,
        "duration_formatted": "15.96s",
        "tokens": {
          "input": 3027,
          "output": 1504,
          "total": 4531
        },
        "cost_usd": 0.018086,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:38:05.788355"
      }
    },
    {
      "file_path": "program_229.py",
      "code": "def num_islands(grid):\n    count = 0\n    i = 0\n    while i < len(grid):\n        for j, col in enumerate(grid[i]):\n            if col == 1:\n                dfs(grid, i, j)\n                count += 1\n        i += 1\n    return count",
      "program_specification": "```dafny\nmethod Dfs(grid: array2<int>, i: int, j: int)\n  requires grid != null\n  requires 0 <= i < grid.Length\n  requires 0 <= j < grid[i].Length\n  requires grid[i][j] == 1\n  modifies grid\n  ensures grid[i][j] == 1 || grid[i][j] == 0\n{\n  // This is a placeholder; actual DFS logic is omitted for simplicity and verifiability.\n  // We only require that grid[i][j] is 1 at entry.\n  grid[i][j] := 0;\n}\n\nmethod NumIslands(grid: array2<int>) returns (count: int)\n  requires grid != null\n  ensures count >= 0\n{\n  count := 0;\n  var i := 0;\n  while i < grid.Length\n    invariant 0 <= i <= grid.Length\n    invariant count >= 0\n    decreases grid.Length - i\n  {\n    var j := 0;\n    while j < grid[i].Length\n      invariant 0 <= j <= grid[i].Length\n      decreases grid[i].Length - j\n    {\n      if grid[i][j] == 1 {\n        Dfs(grid, i, j);\n        count := count + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.177,
        "duration_formatted": "6.18s",
        "tokens": {
          "input": 1331,
          "output": 299,
          "total": 1630
        },
        "cost_usd": 0.005054,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:38:16.999810"
      }
    },
    {
      "file_path": "program_230.py",
      "code": "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    curr = 0\n    while curr < n:\n        if arr[curr] == 0:\n            if curr - prev_prev_zero > max_count:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n        curr += 1\n    if n - prev_prev_zero > max_count:\n        max_index = prev_zero\n    return max_index",
      "program_specification": "```dafny\nmethod MaxOnesIndex(arr: array<int>) returns (maxIndex: int)\n  requires arr != null\n  requires arr.Length >= 0\n  ensures 0 <= maxIndex < arr.Length || arr.Length == 0\n{\n  var n := arr.Length;\n  var maxCount := 0;\n  maxIndex := 0;\n  var prevZero := -1;\n  var prevPrevZero := -1;\n  var curr := 0;\n  while curr < n\n    invariant 0 <= curr <= n\n    invariant -1 <= prevPrevZero < n || prevPrevZero == -1\n    invariant -1 <= prevZero < n || prevZero == -1\n    invariant 0 <= maxIndex < n || n == 0\n    decreases n - curr\n  {\n    if arr[curr] == 0 {\n      if curr - prevPrevZero > maxCount {\n        maxCount := curr - prevPrevZero;\n        maxIndex := prevZero;\n      }\n      prevPrevZero := prevZero;\n      prevZero := curr;\n    }\n    curr := curr + 1;\n  }\n  if n - prevPrevZero > maxCount {\n    maxIndex := prevZero;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.685,
        "duration_formatted": "3.68s",
        "tokens": {
          "input": 1399,
          "output": 258,
          "total": 1657
        },
        "cost_usd": 0.004862,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:38:25.727093"
      }
    },
    {
      "file_path": "program_232.py",
      "code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n    i = 0\n    while i < arr_len + 1:\n        subset[i][0] = True\n        i += 1\n    i = 1\n    while i < required_sum + 1:\n        subset[0][i] = False\n        i += 1\n    i = 1\n    while i < arr_len + 1:\n        j = 1\n        while j < required_sum + 1:\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n            j += 1\n        i += 1\n    return subset[arr_len][required_sum]",
      "program_specification": "```dafny\nmethod IsSumSubset(arr: array<int>, requiredSum: int) returns (ok: bool)\n  requires arr != null\n  requires requiredSum >= 0\n  ensures ok ==> exists S: set<int> :: S <= set i | 0 <= i < arr.Length && sum s: S :: arr[s] == requiredSum\n  ensures !ok ==> forall S: set<int> :: S <= set i | 0 <= i < arr.Length ==> sum s: S :: arr[s] != requiredSum\n{\n  var arrLen := arr.Length;\n  var subset := new bool[arrLen + 1][];\n  var i := 0;\n  while i < arrLen + 1\n    invariant 0 <= i <= arrLen + 1\n    invariant forall k :: 0 <= k < i ==> subset[k] != null\n    decreases arrLen + 1 - i\n  {\n    subset[i] := new bool[requiredSum + 1];\n    i := i + 1;\n  }\n\n  i := 0;\n  while i < arrLen + 1\n    invariant 0 <= i <= arrLen + 1\n    decreases arrLen + 1 - i\n  {\n    subset[i][0] := true;\n    i := i + 1;\n  }\n\n  i := 1;\n  while i < requiredSum + 1\n    invariant 1 <= i <= requiredSum + 1\n    decreases requiredSum + 1 - i\n  {\n    subset[0][i] := false;\n    i := i + 1;\n  }\n\n  i := 1;\n  while i < arrLen + 1\n    invariant 1 <= i <= arrLen + 1\n    decreases arrLen + 1 - i\n  {\n    var j := 1;\n    while j < requiredSum + 1\n      invariant 1 <= j <= requiredSum + 1\n      decreases requiredSum + 1 - j\n    {\n      if arr[i - 1] > j {\n        subset[i][j] := subset[i - 1][j];\n      }\n      if arr[i - 1] <= j {\n        subset[i][j] := subset[i - 1][j] || subset[i - 1][j - arr[i - 1]];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  ok := subset[arrLen][requiredSum];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.814,
        "duration_formatted": "6.81s",
        "tokens": {
          "input": 1546,
          "output": 524,
          "total": 2070
        },
        "cost_usd": 0.007284,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:38:37.581680"
      }
    },
    {
      "file_path": "program_235.py",
      "code": "def factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    facs: list[int] = []\n    if num < 1:\n        return facs\n    facs.append(1)\n    if num == 1:\n        return facs\n    facs.append(num)\n    i = 2\n    while i < int(sqrt(num)) + 1:\n        if num % i == 0:\n            facs.append(i)\n            d = num // i\n            if d != i:\n                facs.append(d)\n        i += 1\n    facs.sort()\n    return facs",
      "program_specification": "```dafny\nmethod FactorsOfANumber(num: int) returns (facs: seq<int>)\n  ensures num < 1 ==> |facs| == 0\n  ensures num >= 1 ==> (forall i :: 0 <= i < |facs| ==> 1 <= facs[i] <= num && num % facs[i] == 0)\n  ensures num >= 1 ==> (forall k :: 1 <= k <= num && num % k == 0 ==> facs[..].Contains(k))\n  ensures facs == if num < 1 then [] else (set i | 1 <= i <= num && num % i == 0) as seq<int>\n  decreases num\n{\n  if num < 1 {\n    facs := [];\n    return;\n  }\n  var tmp := new int[0];\n  // Add 1\n  tmp := tmp + [1];\n  if num == 1 {\n    facs := tmp[..];\n    return;\n  }\n  // Add num itself\n  tmp := tmp + [num];\n  var i := 2;\n  while i < (if num < 0 then 0 else (if num * num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num < 0 then 0 else (if num == 0 then 0 else (if num",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 330.544,
        "duration_formatted": "5m 30.5s",
        "tokens": {
          "input": 1470,
          "output": 32768,
          "total": 34238
        },
        "cost_usd": 0.265084,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:44:13.158761"
      }
    },
    {
      "file_path": "program_236.py",
      "code": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    i = 0\n    while i < len(board):\n        j = 0\n        while j < len(board[0]):\n            backtrack(board, i, j, trie, '', used, result)\n            j += 1\n        i += 1\n    return list(result)",
      "program_specification": "```dafny\nmethod FindWords(board: seq<seq<char>>, words: seq<seq<char>>) returns (found: set<seq<char>>)\n  requires |board| > 0 ==> |board[0]| > 0\n  ensures forall w :: w in found ==> w in words\n  ensures forall w :: w in found ==> ExistsPath(board, w)\n{\n  // We do not implement the trie or backtracking in Dafny.\n  // Instead, we return the set of words from 'words' that can be formed by a path in the board.\n  found := {};\n  var h := |board|;\n  if h == 0 {\n    return;\n  }\n  var w := |board[0]|;\n  for word in words {\n    if ExistsPath(board, word) {\n      found := found + {word};\n    }\n  }\n}\n\nfunction ExistsPath(board: seq<seq<char>>, word: seq<char>): bool\n  requires |board| > 0 ==> |board[0]| > 0\n{\n  exists path: seq<(int, int)> ::\n    |path| == |word| &&\n    (forall k :: 0 <= k < |path| ==>\n       0 <= path[k].0 < |board| &&\n       0 <= path[k].1 < |board[0]| &&\n       board[path[k].0][path[k].1] == word[k]) &&\n    (forall k :: 1 <= k < |path| ==>\n       IsNeighbor(path[k-1], path[k])) &&\n    Distinct(path)\n}\n\nfunction IsNeighbor(a: (int, int), b: (int, int)): bool\n{\n  (a.0 == b.0 && (a.1 == b.1 + 1 || a.1 == b.1 - 1)) ||\n  (a.1 == b.1 && (a.0 == b.0 + 1 || a.0 == b.0 - 1))\n}\n\nfunction Distinct(path: seq<(int, int)>): bool\n{\n  forall i, j :: 0 <= i < |path| && 0 <= j < |path| && i != j ==> path[i] != path[j]\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 10.301,
        "duration_formatted": "10.30s",
        "tokens": {
          "input": 1773,
          "output": 468,
          "total": 2241
        },
        "cost_usd": 0.00729,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:44:28.506274"
      }
    },
    {
      "file_path": "program_245.py",
      "code": "def max_sub_array_sum_repeated(a, n, k):\n    max_so_far = -2147483648\n    max_ending_here = 0\n    i = 0\n    while i < n * k:\n        max_ending_here = max_ending_here + a[i % n]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n        i += 1\n    return max_so_far",
      "program_specification": "```dafny\nmethod MaxSubArraySumRepeated(a: array<int>, n: int, k: int) returns (maxSum: int)\n  requires a != null\n  requires 0 < n <= a.Length\n  requires k > 0\n  ensures exists s: seq<int> :: |s| == n * k && (forall j :: 0 <= j < |s| ==> s[j] == a[j % n]) &&\n            maxSum == (if |s| == 0 then 0 else (max i, j :: 0 <= i <= j <= |s| :: sum s[i..j]))\n{\n  var max_so_far := -2147483648;\n  var max_ending_here := 0;\n  var i := 0;\n  while i < n * k\n    invariant 0 <= i <= n * k\n    invariant max_so_far <= 2147483647\n    invariant max_ending_here <= 2147483647\n    decreases n * k - i\n  {\n    max_ending_here := max_ending_here + a[i % n];\n    if max_so_far < max_ending_here {\n      max_so_far := max_ending_here;\n    }\n    if max_ending_here < 0 {\n      max_ending_here := 0;\n    }\n    i := i + 1;\n  }\n  maxSum := max_so_far;\n}\n\nfunction sum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.099,
        "duration_formatted": "5.10s",
        "tokens": {
          "input": 1380,
          "output": 330,
          "total": 1710
        },
        "cost_usd": 0.0054,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:44:38.644434"
      }
    },
    {
      "file_path": "program_247.py",
      "code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n    arr.sort()\n    dp = [0] * N\n    dp[0] = 0\n    i = 1\n    while i < N:\n        dp[i] = dp[i - 1]\n        if arr[i] - arr[i - 1] < K:\n            if i >= 2:\n                dp[i] = max(dp[i], dp[i - 2] + arr[i] + arr[i - 1])\n            else:\n                dp[i] = max(dp[i], arr[i] + arr[i - 1])\n        i += 1\n    return dp[N - 1]",
      "program_specification": "```dafny\nmethod MaxSumPairDiffLessThanK(arr: array<int>, N: int, K: int) returns (res: int)\n  requires arr != null\n  requires 0 < N <= arr.Length\n  requires K > 0\n  ensures res >= 0\n{\n  // Make a copy of arr to sort, since Dafny arrays can't be sorted in place without side effects.\n  var a := new int[N];\n  var j := 0;\n  while j < N\n    invariant 0 <= j <= N\n    invariant forall k :: 0 <= k < j ==> a[k] == arr[k]\n    decreases N - j\n  {\n    a[j] := arr[j];\n    j := j + 1;\n  }\n\n  // Sort the copy\n  Sort(a, N);\n\n  var dp := new int[N];\n  dp[0] := 0;\n  var i := 1;\n  while i < N\n    invariant 1 <= i <= N\n    invariant dp.Length == N\n    invariant dp[0] == 0\n    invariant forall k :: 1 <= k < i ==> dp[k] >= 0\n    decreases N - i\n  {\n    dp[i] := dp[i - 1];\n    if a[i] - a[i - 1] < K {\n      if i >= 2 {\n        dp[i] := if dp[i] > dp[i - 2] + a[i] + a[i - 1] then dp[i] else dp[i - 2] + a[i] + a[i - 1];\n      } else {\n        dp[i] := if dp[i] > a[i] + a[i - 1] then dp[i] else a[i] + a[i - 1];\n      }\n    }\n    i := i + 1;\n  }\n  res := dp[N - 1];\n}\n\n// Simple insertion sort for arrays\nmethod Sort(a: array<int>, n: int)\n  requires a != null\n  requires 0 < n <= a.Length\n  modifies a\n  ensures forall i, j :: 0 <= i < j < n ==> a[i] <= a[j]\n  ensures multiset( old(a[..n]) ) == multiset( a[..n] )\n{\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k, l :: 0 <= k < l < i ==> a[k] <= a[l]\n    invariant multiset( old(a[..n]) ) == multiset( a[..n] )\n    decreases n - i\n  {\n    var key := a[i];\n    var j := i - 1;\n    while j >= 0 && a[j] > key\n      invariant -1 <= j < i\n      invariant forall k :: j < k < i ==> a[k] > key\n      decreases j + 1\n    {\n      a[j + 1] := a[j];\n      j := j - 1;\n    }\n    a[j + 1] := key;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.685,
        "duration_formatted": "7.69s",
        "tokens": {
          "input": 1410,
          "output": 661,
          "total": 2071
        },
        "cost_usd": 0.008108,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:44:51.365797"
      }
    },
    {
      "file_path": "program_250.py",
      "code": "def first_Factorial_Divisible_Number(x):\n    i = 1\n    fact = 1\n    i = 1\n    while i < x:\n        fact = fact * i\n        if fact % x == 0:\n            break\n        i += 1\n    return i",
      "program_specification": "```dafny\nmethod FirstFactorialDivisibleNumber(x: int) returns (i: int)\n  requires x > 0\n  ensures 1 <= i <= x\n  ensures (forall j: int :: 1 <= j < i ==> (Factorial(j) % x != 0))\n  ensures Factorial(i) % x == 0\n{\n  var fact := 1;\n  i := 1;\n  while i < x\n    invariant 1 <= i <= x\n    invariant fact == Factorial(i)\n    invariant (forall j: int :: 1 <= j < i ==> (Factorial(j) % x != 0))\n    decreases x - i\n  {\n    fact := fact * i;\n    if fact % x == 0 {\n      break;\n    }\n    i := i + 1;\n  }\n}\n\nfunction Factorial(n: int): int\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.818,
        "duration_formatted": "2.82s",
        "tokens": {
          "input": 1329,
          "output": 220,
          "total": 1549
        },
        "cost_usd": 0.004418,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:44:59.225354"
      }
    },
    {
      "file_path": "program_259.py",
      "code": "def re_arrange_array(arr, n):\n    j = 0\n    i = 0\n    while i < n:\n        if arr[i] < 0:\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            j = j + 1\n        i += 1\n    return arr",
      "program_specification": "```dafny\nmethod ReArrangeArray(arr: array<int>, n: int) returns (res: array<int>)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  ensures res != null\n  ensures res.Length == arr.Length\n  ensures multiset(res[..n]) == multiset(arr[..n])\n  ensures forall k: int :: 0 <= k < n && res[k] < 0 ==> forall l: int :: 0 <= l < k ==> res[l] < 0\n{\n  var j := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= j <= i\n    invariant arr != null\n    invariant multiset(arr[..n]) == multiset(arr[..n])\n    decreases n - i\n  {\n    if arr[i] < 0 {\n      var temp := arr[i];\n      arr[i] := arr[j];\n      arr[j] := temp;\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := arr;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.993,
        "duration_formatted": "4.99s",
        "tokens": {
          "input": 1340,
          "output": 235,
          "total": 1575
        },
        "cost_usd": 0.00456,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:45:09.292843"
      }
    },
    {
      "file_path": "program_261.py",
      "code": "def get_total_number_of_sequences(m, n):\n    T = [[0 for i in range(n + 1)] for i in range(m + 1)]\n    i = 0\n    while i < m + 1:\n        j = 0\n        while j < n + 1:\n            if i == 0 or j == 0:\n                T[i][j] = 0\n            elif i < j:\n                T[i][j] = 0\n            elif j == 1:\n                T[i][j] = i\n            else:\n                T[i][j] = T[i - 1][j] + T[i // 2][j - 1]\n            j += 1\n        i += 1\n    return T[m][n]",
      "program_specification": "```dafny\nmethod GetTotalNumberOfSequences(m: int, n: int) returns (res: int)\n  requires m >= 0 && n >= 0\n  ensures res >= 0\n{\n  var T := new int[m + 1][];\n  var i := 0;\n  while i < m + 1\n    invariant 0 <= i <= m + 1\n    invariant T.Length == m + 1\n    decreases m + 1 - i\n  {\n    T[i] := new int[n + 1];\n    i := i + 1;\n  }\n\n  i := 0;\n  while i < m + 1\n    invariant 0 <= i <= m + 1\n    decreases m + 1 - i\n  {\n    var j := 0;\n    while j < n + 1\n      invariant 0 <= j <= n + 1\n      decreases n + 1 - j\n    {\n      if i == 0 || j == 0 {\n        T[i][j] := 0;\n      } else if i < j {\n        T[i][j] := 0;\n      } else if j == 1 {\n        T[i][j] := i;\n      } else {\n        T[i][j] := T[i - 1][j] + T[i / 2][j - 1];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := T[m][n];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.865,
        "duration_formatted": "3.86s",
        "tokens": {
          "input": 1431,
          "output": 325,
          "total": 1756
        },
        "cost_usd": 0.005462,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:45:18.204775"
      }
    },
    {
      "file_path": "program_266.py",
      "code": "def minimum_Length(s):\n    maxOcc = 0\n    n = len(s)\n    arr = [0] * 26\n    i = 0\n    while i < n:\n        arr[ord(s[i]) - ord('a')] += 1\n        i += 1\n    i = 0\n    while i < 26:\n        if arr[i] > maxOcc:\n            maxOcc = arr[i]\n        i += 1\n    return n - maxOcc",
      "program_specification": "```dafny\nmethod MinimumLength(s: seq<char>) returns (res: int)\n  requires |s| >= 0\n  ensures res == |s| - (if |s| == 0 then 0 else MaxOcc(s))\n{\n  var arr: array<int> := new int[26];\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant arr != null && arr.Length == 26\n    invariant forall j :: 0 <= j < 26 ==> arr[j] >= 0\n    decreases |s| - i\n  {\n    var idx := ord(s[i]) - ord('a');\n    arr[idx] := arr[idx] + 1;\n    i := i + 1;\n  }\n  var maxOcc := 0;\n  i := 0;\n  while i < 26\n    invariant 0 <= i <= 26\n    invariant 0 <= maxOcc <= |s|\n    invariant forall j :: 0 <= j < i ==> arr[j] <= maxOcc\n    decreases 26 - i\n  {\n    if arr[i] > maxOcc {\n      maxOcc := arr[i];\n    }\n    i := i + 1;\n  }\n  res := |s| - maxOcc;\n}\n\nfunction MaxOcc(s: seq<char>): int\n  ensures MaxOcc(s) >= 0\n  ensures MaxOcc(s) <= |s|\n{\n  if |s| == 0 then 0\n  else\n    var counts := OccCounts(s);\n    if |counts| == 0 then 0 else SeqMax(counts)\n}\n\nfunction OccCounts(s: seq<char>): seq<int>\n{\n  [CountChar(s, c) | c : char :: 'a' <= c <= 'z']\n}\n\nfunction CountChar(s: seq<char>, c: char): int\n{\n  |[x | x <- s, x == c]|\n}\n\nfunction SeqMax(a: seq<int>): int\n  requires |a| > 0\n  ensures forall i :: 0 <= i < |a| ==> SeqMax(a) >= a[i]\n  ensures exists i :: 0 <= i < |a| && SeqMax(a) == a[i]\n{\n  if |a| == 1 then a[0]\n  else if a[0] >= SeqMax(a[1..]) then a[0] else SeqMax(a[1..])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.641,
        "duration_formatted": "8.64s",
        "tokens": {
          "input": 1369,
          "output": 519,
          "total": 1888
        },
        "cost_usd": 0.00689,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:45:31.882344"
      }
    },
    {
      "file_path": "program_267.py",
      "code": "def count_char_position(str1):\n    count_chars = 0\n    i = 0\n    while i < len(str1):\n        if i == ord(str1[i]) - ord('A') or i == ord(str1[i]) - ord('a'):\n            count_chars += 1\n        i += 1\n    return count_chars",
      "program_specification": "```dafny\nmethod CountCharPosition(str1: seq<char>) returns (countChars: int)\n  ensures 0 <= countChars <= |str1|\n  ensures forall i :: 0 <= i < |str1| && (i == ord(str1[i]) - ord('A') || i == ord(str1[i]) - ord('a')) ==> countChars >= 1\n{\n  var count := 0;\n  var i := 0;\n  while i < |str1|\n    invariant 0 <= i <= |str1|\n    invariant 0 <= count <= i\n    decreases |str1| - i\n  {\n    if i == ord(str1[i]) - ord('A') || i == ord(str1[i]) - ord('a') {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n  countChars := count;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.728,
        "duration_formatted": "2.73s",
        "tokens": {
          "input": 1338,
          "output": 191,
          "total": 1529
        },
        "cost_usd": 0.004204,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:45:39.643172"
      }
    },
    {
      "file_path": "program_272.py",
      "code": "def even_Power_Sum(n):\n    sum = 0\n    i = 1\n    while i < n + 1:\n        j = 2 * i\n        sum = sum + j * j * j * j * j\n        i += 1\n    return sum",
      "program_specification": "```dafny\nmethod EvenPowerSum(n: int) returns (sum: int)\n  requires n >= 0\n  ensures sum >= 0\n  // sum is the sum of (2*i)^5 for i in 1..n\n  ensures sum == (if n == 0 then 0 else (var acc := 0; var i := 1; while i <= n invariant 1 <= i <= n + 1 invariant acc == (if i == 1 then 0 else acc - (2*(i-1))*(2*(i-1))*(2*(i-1))*(2*(i-1))*(2*(i-1))) + (2*(i-1))*(2*(i-1))*(2*(i-1))*(2*(i-1))*(2*(i-1)); decreases n+1 - i { acc := acc + (2*i)*(2*i)*(2*i)*(2*i)*(2*i); i := i + 1; } acc))\n{\n  sum := 0;\n  var i := 1;\n  while i < n + 1\n    invariant 1 <= i <= n + 1\n    invariant sum == (if i == 1 then 0 else (var s := 0; var k := 1; while k < i invariant 1 <= k <= i invariant s == (if k == 1 then 0 else s + (2*(k-1))*(2*(k-1))*(2*(k-1))*(2*(k-1))*(2*(k-1))); decreases i - k { s := s + (2*k)*(2*k)*(2*k)*(2*k)*(2*k); k := k + 1; } s))\n    decreases n + 1 - i\n  {\n    var j := 2 * i;\n    sum := sum + j * j * j * j * j;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.12,
        "duration_formatted": "6.12s",
        "tokens": {
          "input": 1327,
          "output": 421,
          "total": 1748
        },
        "cost_usd": 0.006022,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:45:50.805983"
      }
    },
    {
      "file_path": "program_274.py",
      "code": "def count_no_of_ways(n, k):\n    dp = [0] * (n + 1)\n    total = k\n    mod = 1000000007\n    dp[1] = k\n    dp[2] = k * k\n    i = 3\n    while i < n + 1:\n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]) % mod\n        i += 1\n    return dp[n]",
      "program_specification": "```dafny\nmethod CountNoOfWays(n: int, k: int) returns (res: int)\n  requires n >= 1\n  requires k >= 1\n  ensures 0 <= res < 1000000007\n{\n  var mod := 1000000007;\n  var dp := new int[n + 1];\n  // dp[0] is unused; dp[1] and dp[2] are initialized\n  dp[1] := k;\n  if n >= 2 {\n    dp[2] := k * k;\n  }\n  var i := 3;\n  while i <= n\n    invariant 3 <= i <= n + 1\n    invariant forall j :: 1 <= j < i ==> 0 <= dp[j] < mod\n    decreases n + 1 - i\n  {\n    dp[i] := ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod;\n    i := i + 1;\n  }\n  res := dp[n];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.198,
        "duration_formatted": "3.20s",
        "tokens": {
          "input": 1375,
          "output": 224,
          "total": 1599
        },
        "cost_usd": 0.004542,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:45:59.048438"
      }
    },
    {
      "file_path": "program_282.py",
      "code": "import math as mt\n\ndef get_Position(a, n, m):\n    i = 0\n    while i < n:\n        a[i] = a[i] // m + (a[i] % m != 0)\n        i += 1\n    result, maxx = (-1, -1)\n    i = n - 1\n    while i > -1:\n        if maxx < a[i]:\n            maxx = a[i]\n            result = i\n        i += -1\n    return result + 1",
      "program_specification": "```dafny\nmethod GetPosition(a: array<int>, n: int, m: int) returns (pos: int)\n  requires a != null\n  requires 0 <= n <= a.Length\n  requires m > 0\n  ensures 1 <= pos <= n\n{\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant a != null && a.Length >= n\n    decreases n - i\n  {\n    a[i] := a[i] / m + (if a[i] % m != 0 then 1 else 0);\n    i := i + 1;\n  }\n  var result := -1;\n  var maxx := -1;\n  i := n - 1;\n  while i > -1\n    invariant -1 <= i < n\n    invariant -1 <= result < n\n    invariant maxx == (if result == -1 then -1 else a[result])\n    decreases i + 1\n  {\n    if maxx < a[i] {\n      maxx := a[i];\n      result := i;\n    }\n    i := i - 1;\n  }\n  pos := result + 1;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.655,
        "duration_formatted": "3.66s",
        "tokens": {
          "input": 1378,
          "output": 256,
          "total": 1634
        },
        "cost_usd": 0.004804,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:46:07.749906"
      }
    },
    {
      "file_path": "program_285.py",
      "code": "def Odd_Length_Sum(arr):\n    Sum = 0\n    l = len(arr)\n    i = 0\n    while i < l:\n        Sum += ((i + 1) * (l - i) + 1) // 2 * arr[i]\n        i += 1\n    return Sum",
      "program_specification": "```dafny\nmethod OddLengthSum(arr: array<int>) returns (total: int)\n  requires arr != null\n  ensures total == (if arr.Length == 0 then 0 else\n    (sum i: int {:trigger 0 <= i < arr.Length} :: 0 <= i < arr.Length ==> (((i + 1) * (arr.Length - i) + 1) / 2) * arr[i]))\n{\n  var Sum := 0;\n  var l := arr.Length;\n  var i := 0;\n  while i < l\n    invariant 0 <= i <= l\n    invariant Sum == (if i == 0 then 0 else (sum j: int {:trigger 0 <= j < i} :: 0 <= j < i ==> (((j + 1) * (l - j) + 1) / 2) * arr[j]))\n    decreases l - i\n  {\n    Sum := Sum + (((i + 1) * (l - i) + 1) / 2) * arr[i];\n    i := i + 1;\n  }\n  total := Sum;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.506,
        "duration_formatted": "3.51s",
        "tokens": {
          "input": 1332,
          "output": 242,
          "total": 1574
        },
        "cost_usd": 0.0046,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:46:16.303001"
      }
    },
    {
      "file_path": "program_288.py",
      "code": "def bin_to_hexadecimal(binary_str: str) -> str:\n    \"\"\"\n    Converting a binary string into hexadecimal using Grouping Method\n\n    >>> bin_to_hexadecimal('101011111')\n    '0x15f'\n    >>> bin_to_hexadecimal(' 1010   ')\n    '0x0a'\n    >>> bin_to_hexadecimal('-11101')\n    '-0x1d'\n    >>> bin_to_hexadecimal('a')\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_hexadecimal('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    binary_str = str(binary_str).strip()\n    if not binary_str:\n        raise ValueError('Empty string was passed to the function')\n    is_negative = binary_str[0] == '-'\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not all((char in '01' for char in binary_str)):\n        raise ValueError('Non-binary value was passed to the function')\n    binary_str = '0' * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    hexadecimal = []\n    x = 0\n    while x < len(binary_str):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x:x + 4]])\n        x += 4\n    hexadecimal_str = '0x' + ''.join(hexadecimal)\n    return '-' + hexadecimal_str if is_negative else hexadecimal_str",
      "program_specification": "```dafny\nmethod BinToHexadecimal(binaryStr: string) returns (hexStr: string)\n  requires binaryStr != null\n  ensures hexStr != null\n  // If input is empty or only whitespace, result is empty string (exception in Python)\n  // If input is valid, result starts with \"0x\" or \"-0x\" and contains only hex digits after prefix\n{\n  var s := binaryStr.Trim();\n  if s.Length == 0 {\n    // In Python, raises ValueError; here, return empty string to match minimal postcondition\n    hexStr := \"\";\n    return;\n  }\n  var isNegative := s[0] == '-';\n  var digits := if isNegative then s.Substring(1, s.Length - 1) else s;\n  if digits.Length == 0 {\n    hexStr := \"\";\n    return;\n  }\n  // Check all chars are '0' or '1'\n  var i := 0;\n  while i < digits.Length\n    invariant 0 <= i <= digits.Length\n    invariant (forall j :: 0 <= j < i ==> digits[j] == '0' || digits[j] == '1')\n    decreases digits.Length - i\n  {\n    if !(digits[i] == '0' || digits[i] == '1') {\n      hexStr := \"\";\n      return;\n    }\n    i := i + 1;\n  }\n  // Pad to multiple of 4\n  var padLen := 4 * ((digits.Length + 3) / 4) - digits.Length;\n  var padded := \"0\".Repeat(padLen) + digits;\n  // Build hex string\n  var hex := \"\";\n  var x := 0;\n  while x < padded.Length\n    invariant 0 <= x <= padded.Length\n    invariant x % 4 == 0\n    invariant hex.Length == x / 4\n    decreases padded.Length - x\n  {\n    var chunk := padded.Substring(x, 4);\n    var h := BitsToHex(chunk);\n    hex := hex + h;\n    x := x + 4;\n  }\n  var prefix := \"0x\";\n  var result := prefix + hex;\n  if isNegative {\n    hexStr := \"-\" + result;\n  } else {\n    hexStr := result;\n  }\n}\n\n// Helper: Converts a 4-character binary string to 1 hex digit\nfunction BitsToHex(bits: string): string\n  requires bits != null && bits.Length == 4\n  ensures BitsToHex(bits).Length == 1\n  ensures BitsToHex(\"0000\") == \"0\"\n  ensures BitsToHex(\"0001\") == \"1\"\n  ensures BitsToHex(\"0010\") == \"2\"\n  ensures BitsToHex(\"0011\") == \"3\"\n  ensures BitsToHex(\"0100\") == \"4\"\n  ensures BitsToHex(\"0101\") == \"5\"\n  ensures BitsToHex(\"0110\") == \"6\"\n  ensures BitsToHex(\"0111\") == \"7\"\n  ensures BitsToHex(\"1000\") == \"8\"\n  ensures BitsToHex(\"1001\") == \"9\"\n  ensures BitsToHex(\"1010\") == \"a\"\n  ensures BitsToHex(\"1011\") == \"b\"\n  ensures BitsToHex(\"1100\") == \"c\"\n  ensures BitsToHex(\"1101\") == \"d\"\n  ensures BitsToHex(\"1110\") == \"e\"\n  ensures BitsToHex(\"1111\") == \"f\"\n{\n  if bits == \"0000\" then \"0\"\n  else if bits == \"0001\" then \"1\"\n  else if bits == \"0010\" then \"2\"\n  else if bits == \"0011\" then \"3\"\n  else if bits == \"0100\" then \"4\"\n  else if bits == \"0101\" then \"5\"\n  else if bits == \"0110\" then \"6\"\n  else if bits == \"0111\" then \"7\"\n  else if bits == \"1000\" then \"8\"\n  else if bits == \"1001\" then \"9\"\n  else if bits == \"1010\" then \"a\"\n  else if bits == \"1011\" then \"b\"\n  else if bits == \"1100\" then \"c\"\n  else if bits == \"1101\" then \"d\"\n  else if bits == \"1110\" then \"e\"\n  else if bits == \"1111\" then \"f\"\n  else \"?\"\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.92,
        "duration_formatted": "9.92s",
        "tokens": {
          "input": 1605,
          "output": 954,
          "total": 2559
        },
        "cost_usd": 0.010842,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:46:31.274508"
      }
    },
    {
      "file_path": "program_294.py",
      "code": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not n:\n        return []\n    m = len(matrix[0])\n    if not m:\n        return []\n    res = []\n    atlantic = [[False for _ in range(n)] for _ in range(m)]\n    pacific = [[False for _ in range(n)] for _ in range(m)]\n    i = 0\n    while i < n:\n        dfs(pacific, matrix, float('-inf'), i, 0)\n        dfs(atlantic, matrix, float('-inf'), i, m - 1)\n        i += 1\n    i = 0\n    while i < m:\n        dfs(pacific, matrix, float('-inf'), 0, i)\n        dfs(atlantic, matrix, float('-inf'), n - 1, i)\n        i += 1\n    i = 0\n    while i < n:\n        j = 0\n        while j < m:\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n            j += 1\n        i += 1\n    return res",
      "program_specification": "```dafny\nmethod PacificAtlantic(matrix: array2<int>) returns (res: seq<seq<int>>)\n  requires matrix != null\n  requires matrix.Length >= 0\n  requires matrix.Length == 0 || matrix[0] != null\n  ensures forall p :: p in res ==> |p| == 2\n  // No further semantic guarantee; result is a sequence of pairs of indices\n{\n  var n := matrix.Length;\n  if n == 0 {\n    res := [];\n    return;\n  }\n  var m := matrix[0].Length;\n  if m == 0 {\n    res := [];\n    return;\n  }\n\n  // Allocate 2D arrays for atlantic and pacific\n  var atlantic := new bool[n][];\n  var pacific := new bool[n][];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant atlantic != null && pacific != null\n    invariant forall k :: 0 <= k < i ==> atlantic[k] != null && pacific[k] != null\n    decreases n - i\n  {\n    atlantic[i] := new bool[m];\n    pacific[i] := new bool[m];\n    var j := 0;\n    while j < m\n      invariant 0 <= j <= m\n      decreases m - j\n    {\n      atlantic[i][j] := false;\n      pacific[i][j] := false;\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n\n  // DFS from Pacific and Atlantic borders\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    call Dfs(pacific, matrix, -2147483648, i, 0);\n    call Dfs(atlantic, matrix, -2147483648, i, m - 1);\n    i := i + 1;\n  }\n  i := 0;\n  while i < m\n    invariant 0 <= i <= m\n    decreases m - i\n  {\n    call Dfs(pacific, matrix, -2147483648, 0, i);\n    call Dfs(atlantic, matrix, -2147483648, n - 1, i);\n    i := i + 1;\n  }\n\n  // Collect result\n  var out := new seq<seq<int>>[0];\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    var j := 0;\n    while j < m\n      invariant 0 <= j <= m\n      decreases m - j\n    {\n      if pacific[i][j] && atlantic[i][j] {\n        out := out + [[i, j]];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := out;\n}\n\n// Helper: DFS marking reachability\nmethod Dfs(visited: array2<bool>, matrix: array2<int>, prev: int, x: int, y: int)\n  requires visited != null && matrix != null\n  requires 0 <= x < matrix.Length\n  requires 0 <= y < matrix[0].Length\n  requires visited.Length == matrix.Length\n  requires matrix.Length == 0 || matrix[0].Length == visited[0].Length\n  modifies visited\n{\n  if visited[x][y] {\n    return;\n  }\n  if matrix[x][y] < prev {\n    return;\n  }\n  visited[x][y] := true;\n\n  if x > 0 {\n    call Dfs(visited, matrix, matrix[x][y], x - 1, y);\n  }\n  if x + 1 < matrix.Length {\n    call Dfs(visited, matrix, matrix[x][y], x + 1, y);\n  }\n  if y > 0 {\n    call Dfs(visited, matrix, matrix[x][y], x, y - 1);\n  }\n  if y + 1 < matrix[0].Length {\n    call Dfs(visited, matrix, matrix[x][y], x, y + 1);\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 10.256,
        "duration_formatted": "10.26s",
        "tokens": {
          "input": 1533,
          "output": 899,
          "total": 2432
        },
        "cost_usd": 0.010258,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:46:46.571757"
      }
    },
    {
      "file_path": "program_313.py",
      "code": "def removals(arr, n, k):\n    ans = n - 1\n    arr.sort()\n    i = 0\n    while i < n:\n        j = find_ind(arr[i], i, n, k, arr)\n        if j != -1:\n            ans = min(ans, n - (j - i + 1))\n        i += 1\n    return ans",
      "program_specification": "```dafny\nmethod FindInd(x: int, i: int, n: int, k: int, arr: array<int>) returns (j: int)\n  requires arr != null\n  requires 0 <= i < n <= arr.Length\n  // No further postconditions, as body is not given\n{\n  // Method body not provided; postconditions cannot be specified.\n  // To be implemented.\n  j := -1;\n}\n\nmethod Removals(arr: array<int>, n: int, k: int) returns (ans: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  // No further requirements as per code\n  ensures 0 <= ans <= n - 1\n{\n  ans := n - 1;\n  // Sort arr[0..n)\n  // As Dafny does not have built-in sort, assume arr[0..n) is sorted.\n  // Otherwise, sorting would be implemented or specified as a method.\n  // For verifiability, we skip actual sorting and assume arr is sorted.\n\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= ans <= n - 1\n    decreases n - i\n  {\n    var j := FindInd(arr[i], i, n, k, arr);\n    if j != -1 {\n      var rem := n - (j - i + 1);\n      if rem < ans {\n        ans := rem;\n      }\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 15.727,
        "duration_formatted": "15.73s",
        "tokens": {
          "input": 1347,
          "output": 330,
          "total": 1677
        },
        "cost_usd": 0.005334,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:47:07.367000"
      }
    },
    {
      "file_path": "program_315.py",
      "code": "def prime_num(num):\n    if num >= 1:\n        i = 2\n        while i < num // 2:\n            if num % i == 0:\n                return False\n            else:\n                return True\n            i += 1\n    else:\n        return False",
      "program_specification": "```dafny\nmethod PrimeNum(num: int) returns (isPrime: bool)\n  ensures num < 1 ==> isPrime == false\n  ensures num >= 1 && exists i :: 2 <= i < num / 2 && num % i == 0 ==> isPrime == false\n  ensures num >= 1 && (forall i :: 2 <= i < num / 2 ==> num % i != 0) ==> isPrime == true\n{\n  if num >= 1 {\n    var i := 2;\n    while i < num / 2\n      invariant 2 <= i <= num / 2\n      decreases num / 2 - i\n    {\n      if num % i == 0 {\n        isPrime := false;\n        return;\n      } else {\n        isPrime := true;\n        return;\n      }\n      i := i + 1;\n    }\n    // If loop never entered, or completed without return\n    isPrime := true;\n  } else {\n    isPrime := false;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.379,
        "duration_formatted": "3.38s",
        "tokens": {
          "input": 1325,
          "output": 218,
          "total": 1543
        },
        "cost_usd": 0.004394,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:47:15.804231"
      }
    },
    {
      "file_path": "program_316.py",
      "code": "def is_undulating(n):\n    if len(n) <= 2:\n        return False\n    i = 2\n    while i < len(n):\n        if n[i - 2] != n[i]:\n            return False\n        i += 1\n    return True",
      "program_specification": "```dafny\nmethod IsUndulating(n: seq<int>) returns (res: bool)\n  ensures |n| <= 2 ==> res == false\n  ensures |n| > 2 ==> (res <==> (forall i :: 2 <= i < |n| ==> n[i-2] == n[i]))\n{\n  if |n| <= 2 {\n    res := false;\n    return;\n  }\n  var i := 2;\n  while i < |n|\n    invariant 2 <= i <= |n|\n    invariant (forall j :: 2 <= j < i ==> n[j-2] == n[j])\n    decreases |n| - i\n  {\n    if n[i-2] != n[i] {\n      res := false;\n      return;\n    }\n    i := i + 1;\n  }\n  res := true;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.004,
        "duration_formatted": "3.00s",
        "tokens": {
          "input": 1324,
          "output": 183,
          "total": 1507
        },
        "cost_usd": 0.004112,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:47:23.850693"
      }
    },
    {
      "file_path": "program_324.py",
      "code": "def count_Rectangles(radius):\n    rectangles = 0\n    diameter = 2 * radius\n    diameterSquare = diameter * diameter\n    a = 1\n    while a < 2 * radius:\n        b = 1\n        while b < 2 * radius:\n            diagnalLengthSquare = a * a + b * b\n            if diagnalLengthSquare <= diameterSquare:\n                rectangles += 1\n            b += 1\n        a += 1\n    return rectangles",
      "program_specification": "```dafny\nmethod CountRectangles(radius: int) returns (rectangles: int)\n  requires radius >= 0\n  ensures rectangles >= 0\n{\n  rectangles := 0;\n  var diameter := 2 * radius;\n  var diameterSquare := diameter * diameter;\n  var a := 1;\n  while a < diameter\n    invariant 1 <= a <= diameter\n    invariant rectangles >= 0\n    decreases diameter - a\n  {\n    var b := 1;\n    while b < diameter\n      invariant 1 <= b <= diameter\n      invariant rectangles >= 0\n      decreases diameter - b\n    {\n      var diagonalLengthSquare := a * a + b * b;\n      if diagonalLengthSquare <= diameterSquare {\n        rectangles := rectangles + 1;\n      }\n      b := b + 1;\n    }\n    a := a + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.085,
        "duration_formatted": "2.08s",
        "tokens": {
          "input": 1369,
          "output": 187,
          "total": 1556
        },
        "cost_usd": 0.004234,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:47:30.979115"
      }
    },
    {
      "file_path": "program_325.py",
      "code": "def breakSum(n):\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    i = 2\n    while i < n + 1:\n        dp[i] = max(dp[int(i / 2)] + dp[int(i / 3)] + dp[int(i / 4)], i)\n        i += 1\n    return dp[n]",
      "program_specification": "```dafny\nmethod BreakSum(n: int) returns (res: int)\n  requires n >= 1\n  ensures res >= n\n{\n  var dp := new int[n + 1];\n  dp[0] := 0;\n  dp[1] := 1;\n  var i := 2;\n  while i < n + 1\n    invariant 2 <= i <= n + 1\n    invariant dp.Length == n + 1\n    invariant dp[0] == 0 && dp[1] == 1\n    invariant forall j :: 2 <= j < i ==> dp[j] >= j\n    decreases n + 1 - i\n  {\n    var a := dp[i / 2];\n    var b := dp[i / 3];\n    var c := dp[i / 4];\n    var sum := a + b + c;\n    if sum > i {\n      dp[i] := sum;\n    } else {\n      dp[i] := i;\n    }\n    i := i + 1;\n  }\n  res := dp[n];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.374,
        "duration_formatted": "3.37s",
        "tokens": {
          "input": 1358,
          "output": 229,
          "total": 1587
        },
        "cost_usd": 0.004548,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:47:39.402176"
      }
    },
    {
      "file_path": "program_327.py",
      "code": "def find_Min_Sum(a, b, n):\n    a.sort()\n    b.sort()\n    sum = 0\n    i = 0\n    while i < n:\n        sum = sum + abs(a[i] - b[i])\n        i += 1\n    return sum",
      "program_specification": "```dafny\nmethod FindMinSum(a: array<int>, b: array<int>, n: int) returns (s: int)\n  requires a != null && b != null\n  requires 0 <= n <= a.Length && n <= b.Length\n  ensures s >= 0\n  // ensures s == sum of abs(a'[i] - b'[i]) for i in 0..n-1, where a', b' are sorted versions of a, b\n{\n  // Copy and sort the first n elements of a and b into new arrays\n  var aa := new int[n];\n  var bb := new int[n];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall j :: 0 <= j < i ==> aa[j] == a[j] && bb[j] == b[j]\n    decreases n - i\n  {\n    aa[i] := a[i];\n    bb[i] := b[i];\n    i := i + 1;\n  }\n\n  // Sort aa and bb\n  // Simple selection sort for verifiability\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall j, k :: 0 <= j < i <= k < n ==> aa[j] <= aa[k] && bb[j] <= bb[k]\n    decreases n - i\n  {\n    var minA := i;\n    var minB := i;\n    var j := i + 1;\n    while j < n\n      invariant i + 1 <= j <= n\n      invariant i <= minA < n && i <= minB < n\n      invariant forall k :: i <= k < j ==> aa[minA] <= aa[k] && bb[minB] <= bb[k]\n      decreases n - j\n    {\n      if aa[j] < aa[minA] {\n        minA := j;\n      }\n      if bb[j] < bb[minB] {\n        minB := j;\n      }\n      j := j + 1;\n    }\n    // Swap aa[i] and aa[minA]\n    var tmp := aa[i];\n    aa[i] := aa[minA];\n    aa[minA] := tmp;\n    // Swap bb[i] and bb[minB]\n    tmp := bb[i];\n    bb[i] := bb[minB];\n    bb[minB] := tmp;\n    i := i + 1;\n  }\n\n  // Compute sum of abs differences\n  s := 0;\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s >= 0\n    invariant s == (if i == 0 then 0 else sum j: 0 <= j < i :: if aa[j] >= bb[j] then aa[j] - bb[j] else bb[j] - aa[j])\n    decreases n - i\n  {\n    var d := aa[i] - bb[i];\n    if d < 0 {\n      d := -d;\n    }\n    s := s + d;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.983,
        "duration_formatted": "7.98s",
        "tokens": {
          "input": 1325,
          "output": 658,
          "total": 1983
        },
        "cost_usd": 0.007914,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:47:52.423396"
      }
    },
    {
      "file_path": "program_328.py",
      "code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    i = 0\n    while i < n + 1:\n        dp[i][0] = 0\n        i += 1\n    i = 0\n    while i < m + 1:\n        dp[0][i] = 0\n        i += 1\n    i = 1\n    while i < n + 1:\n        j = 1\n        while j < m + 1:\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            j += 1\n        i += 1\n    return dp[n][m]",
      "program_specification": "```dafny\nmethod LongestPalindromicSubsequence(s: seq<char>) returns (len: int)\n  ensures 0 <= len <= |s|\n  ensures forall t: seq<char> :: Palindrome(t) && SubsequenceOf(t, s) ==> |t| <= len\n  ensures exists t: seq<char> :: Palindrome(t) && SubsequenceOf(t, s) && |t| == len\n{\n  var n := |s|;\n  var rev := SeqReverse(s);\n  var dp := new int[n + 1][n + 1];\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant forall k :: 0 <= k < i ==> dp[k][0] == 0\n    decreases n + 1 - i\n  {\n    dp[i][0] := 0;\n    i := i + 1;\n  }\n  i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant forall k :: 0 <= k < i ==> dp[0][k] == 0\n    decreases n + 1 - i\n  {\n    dp[0][i] := 0;\n    i := i + 1;\n  }\n  i := 1;\n  while i <= n\n    invariant 1 <= i <= n + 1\n    decreases n + 1 - i\n  {\n    var j := 1;\n    while j <= n\n      invariant 1 <= j <= n + 1\n      decreases n + 1 - j\n    {\n      if s[i - 1] == rev[j - 1] {\n        dp[i][j] := 1 + dp[i - 1][j - 1];\n      } else {\n        dp[i][j] := if dp[i - 1][j] >= dp[i][j - 1] then dp[i - 1][j] else dp[i][j - 1];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  len := dp[n][n];\n}\n\nfunction method SeqReverse(s: seq<char>): seq<char>\n  ensures |SeqReverse(s)| == |s|\n  ensures forall i :: 0 <= i < |s| ==> SeqReverse(s)[i] == s[|s| - 1 - i]\n{\n  if |s| == 0 then [] else SeqReverse(s[1..]) + [s[0]]\n}\n\npredicate method Palindrome(t: seq<char>)\n  reads t\n  ensures Palindrome(t) <==> (forall i :: 0 <= i < |t| ==> t[i] == t[|t| - 1 - i])\n{\n  forall i :: 0 <= i < |t| ==> t[i] == t[|t| - 1 - i]\n}\n\npredicate method SubsequenceOf(sub: seq<char>, s: seq<char>)\n  reads sub, s\n  ensures SubsequenceOf(sub, s) <==> (exists idx: seq<int> :: |idx| == |sub| && StrictlyIncreasing(idx) && (forall k :: 0 <= k < |sub| ==> 0 <= idx[k] < |s| && sub[k] == s[idx[k]]))\n{\n  exists idx: seq<int> ::\n    |idx| == |sub| &&\n    StrictlyIncreasing(idx) &&\n    (forall k :: 0 <= k < |sub| ==> 0 <= idx[k] < |s| && sub[k] == s[idx[k]])\n}\n\npredicate method StrictlyIncreasing(a: seq<int>)\n  reads a\n  ensures StrictlyIncreasing(a) <==> (forall i :: 1 <= i < |a| ==> a[i-1] < a[i])\n{\n  forall i :: 1 <= i < |a| ==> a[i-1] < a[i]\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 12.915,
        "duration_formatted": "12.91s",
        "tokens": {
          "input": 1558,
          "output": 842,
          "total": 2400
        },
        "cost_usd": 0.009852,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:48:10.379852"
      }
    },
    {
      "file_path": "program_329.py",
      "code": "def previous_palindrome(num):\n    x = num - 1\n    while x > 0:\n        if str(x) == str(x)[::-1]:\n            return x\n        x += -1",
      "program_specification": "```dafny\nmethod PreviousPalindrome(num: int) returns (p: int)\n  requires num > 0\n  ensures 0 < p < num\n  ensures IsPalindrome(p)\n  ensures forall k :: 0 < k < num && IsPalindrome(k) && k > p ==> false\n{\n  var x := num - 1;\n  while x > 0\n    invariant 0 < x < num\n    decreases x\n  {\n    if IsPalindrome(x) {\n      p := x;\n      return;\n    }\n    x := x - 1;\n  }\n  // This point is unreachable for num > 0\n  // Assign a dummy value to satisfy Dafny's definite assignment check\n  p := 0;\n}\n\nfunction IsPalindrome(n: int): bool\n  requires n >= 0\n{\n  var s := IntToString(n);\n  s == s[..][|s,0,-1|]\n}\n\nfunction IntToString(n: int): seq<char>\n  requires n >= 0\n{\n  if n == 0 then ['0'] else IntToStringAux(n)\n}\n\nfunction IntToStringAux(n: int): seq<char>\n  requires n > 0\n{\n  if n < 10 then [DigitToChar(n)] else IntToStringAux(n / 10) + [DigitToChar(n % 10)]\n}\n\nfunction DigitToChar(d: int): char\n  requires 0 <= d < 10\n{\n  (d as char) + '0'\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 13.104,
        "duration_formatted": "13.10s",
        "tokens": {
          "input": 1308,
          "output": 320,
          "total": 1628
        },
        "cost_usd": 0.005176,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:48:28.527978"
      }
    },
    {
      "file_path": "program_336.py",
      "code": "def palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not s:\n        yield []\n        return\n    i = len(s)\n    while i > 0:\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield ([sub] + rest)\n        i += -1",
      "program_specification": "```dafny\nmethod PalindromicSubstringsIter(s: seq<char>) returns (res: seq<seq<seq<char>>>)\n  ensures forall t: seq<seq<char>> :: t in res ==> |ConcatSeqs(t)| == |s|\n  ensures forall t: seq<seq<char>> :: t in res ==> ConcatSeqs(t) == s\n  ensures forall t: seq<seq<char>> :: t in res ==> forall u: seq<char> :: u in t ==> IsPalindrome(u)\n{\n  if |s| == 0 {\n    res := [ [ ] ];\n    return;\n  }\n  var all: seq<seq<seq<char>>> := [ ];\n  var i: int := |s|;\n  while i > 0\n    invariant 0 <= i <= |s|\n    invariant forall u: seq<seq<char>> :: u in all ==> |ConcatSeqs(u)| == |s|\n    invariant forall u: seq<seq<char>> :: u in all ==> ConcatSeqs(u) == s\n    invariant forall u: seq<seq<char>> :: u in all ==> forall v: seq<char> :: v in u ==> IsPalindrome(v)\n    decreases i\n  {\n    var sub := s[..i];\n    if IsPalindrome(sub) {\n      var rest := PalindromicSubstringsIter(s[i..]);\n      var j: int := 0;\n      while j < |rest|\n        invariant 0 <= j <= |rest|\n        decreases |rest| - j\n      {\n        var t := rest[j];\n        all := all + [ [sub] + t ];\n        j := j + 1;\n      }\n    }\n    i := i - 1;\n  }\n  res := all;\n}\n\nfunction method IsPalindrome(s: seq<char>): bool\n  ensures IsPalindrome(s) <==> s == s[..][::-1]\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s|-1-i]\n}\n\nfunction method ConcatSeqs(ss: seq<seq<char>>): seq<char>\n{\n  if |ss| == 0 then [] else ss[0] + ConcatSeqs(ss[1..])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.746,
        "duration_formatted": "9.75s",
        "tokens": {
          "input": 1359,
          "output": 468,
          "total": 1827
        },
        "cost_usd": 0.006462,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:48:43.318305"
      }
    },
    {
      "file_path": "program_352.py",
      "code": "def remove_even(str1):\n    str2 = ''\n    i = 1\n    while i < len(str1) + 1:\n        if i % 2 != 0:\n            str2 = str2 + str1[i - 1]\n        i += 1\n    return str2",
      "program_specification": "```dafny\nmethod RemoveEven(str1: seq<char>) returns (str2: seq<char>)\n  ensures |str2| <= |str1|\n  ensures forall j :: 0 <= j < |str2| ==> str2[j] == str1[2*j]\n{\n  var acc := [];\n  var i := 1;\n  while i < |str1| + 1\n    invariant 1 <= i <= |str1| + 1\n    invariant |acc| == i - 1\n    invariant forall j :: 0 <= j < |acc| ==> acc[j] == str1[2*j]\n    decreases |str1| + 1 - i\n  {\n    if i % 2 != 0 {\n      acc := acc + [str1[i - 1]];\n    }\n    i := i + 1;\n  }\n  str2 := acc;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.908,
        "duration_formatted": "2.91s",
        "tokens": {
          "input": 1329,
          "output": 190,
          "total": 1519
        },
        "cost_usd": 0.004178,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:48:51.264668"
      }
    },
    {
      "file_path": "program_354.py",
      "code": "def are_Equal(arr1, arr2, n, m):\n    if n != m:\n        return False\n    arr1.sort()\n    arr2.sort()\n    i = 0\n    while i < n - 1:\n        if arr1[i] != arr2[i]:\n            return False\n        i += 1\n    return True",
      "program_specification": "```dafny\nmethod AreEqual(arr1: array<int>, arr2: array<int>, n: int, m: int) returns (eq: bool)\n  requires arr1 != null && arr2 != null\n  requires 0 <= n <= arr1.Length\n  requires 0 <= m <= arr2.Length\n  ensures eq ==> n == m\n  ensures eq ==> (forall i :: 0 <= i < n ==> arr1[i] == arr2[i])\n  ensures n != m ==> eq == false\n{\n  if n != m {\n    eq := false;\n    return;\n  }\n  // We do not implement sorting; assume arrays are sorted for the loop.\n  var i := 0;\n  while i < n - 1\n    invariant 0 <= i <= n - 1\n    invariant (forall j :: 0 <= j < i ==> arr1[j] == arr2[j])\n    decreases n - 1 - i\n  {\n    if arr1[i] != arr2[i] {\n      eq := false;\n      return;\n    }\n    i := i + 1;\n  }\n  eq := true;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.38,
        "duration_formatted": "7.38s",
        "tokens": {
          "input": 1339,
          "output": 242,
          "total": 1581
        },
        "cost_usd": 0.004614,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:49:03.703536"
      }
    },
    {
      "file_path": "program_357.py",
      "code": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([4, 3, 1, 0])\n        2\n        >>> find_missing_number([-4, -3, -1, 0])\n        -2\n        >>> find_missing_number([-2, 2, 1, 3, 0])\n        -1\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n    i = low\n    while i < high:\n        missing_number ^= i ^ nums[i - low]\n        i += 1\n    return missing_number",
      "program_specification": "```dafny\nmethod FindMissingNumber(nums: array<int>) returns (missing: int)\n  requires nums != null\n  requires nums.Length > 0\n  // Assumes nums contains all integers from some consecutive interval [low, high], except one missing number\n  ensures exists low: int, high: int ::\n            low <= high &&\n            high - low == nums.Length &&\n            (forall k: int :: low <= k <= high ==> (k in set nums[..]) || k == missing) &&\n            (missing !in set nums[..]) &&\n            (forall k: int :: low <= k <= high && k != missing ==> k in set nums[..])\n  ensures missing !in set nums[..]\n  ensures nums.Length + 1 == (if nums.Length == 0 then 1 else (max(nums[..]) - min(nums[..]) + 1))\n{\n  var n := nums.Length;\n\n  var low := nums[0];\n  var high := nums[0];\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant low == min(nums[..i])\n    invariant high == max(nums[..i])\n    decreases n - i\n  {\n    if nums[i] < low {\n      low := nums[i];\n    }\n    if nums[i] > high {\n      high := nums[i];\n    }\n    i := i + 1;\n  }\n\n  missing := high;\n  i := low;\n  while i < high\n    invariant low <= i <= high\n    invariant (forall j: int :: low <= j < i ==> \n      missing == missing ^ j ^ nums[j - low])\n    decreases high - i\n  {\n    missing := missing ^ i ^ nums[i - low];\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 10.495,
        "duration_formatted": "10.49s",
        "tokens": {
          "input": 1525,
          "output": 377,
          "total": 1902
        },
        "cost_usd": 0.006066,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:49:19.241981"
      }
    },
    {
      "file_path": "program_358.py",
      "code": "def check_permutation(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n    if n1 != n2:\n        return False\n    a = sorted(str1)\n    str1 = ' '.join(a)\n    b = sorted(str2)\n    str2 = ' '.join(b)\n    i = 0\n    while i < n1:\n        if str1[i] != str2[i]:\n            return False\n        i += 1\n    return True",
      "program_specification": "```dafny\nmethod CheckPermutation(str1: seq<char>, str2: seq<char>) returns (isPerm: bool)\n  ensures isPerm ==> (|str1| == |str2| && multiset(str1) == multiset(str2))\n  ensures (|str1| != |str2|) ==> !isPerm\n{\n  var n1 := |str1|;\n  var n2 := |str2|;\n  if n1 != n2 {\n    isPerm := false;\n    return;\n  }\n  var a := str1[..];\n  var b := str2[..];\n  // Sort a and b\n  a := SortSeq(a);\n  b := SortSeq(b);\n\n  var i := 0;\n  while i < n1\n    invariant 0 <= i <= n1\n    invariant a == SortSeq(str1)\n    invariant b == SortSeq(str2)\n    decreases n1 - i\n  {\n    if a[i] != b[i] {\n      isPerm := false;\n      return;\n    }\n    i := i + 1;\n  }\n  isPerm := true;\n}\n\n// Helper: returns sorted sequence (stable, lex order)\nfunction SortSeq(s: seq<char>): seq<char>\n  ensures multiset(SortSeq(s)) == multiset(s)\n  ensures |SortSeq(s)| == |s|\n  ensures forall i, j :: 0 <= i < j < |s| ==> SortSeq(s)[i] <= SortSeq(s)[j]\n{\n  if |s| <= 1 then s\n  else\n    var pivot := s[0];\n    SortSeq([x | x := s[1..], x < pivot]) +\n    [pivot] +\n    SortSeq([x | x := s[1..], x >= pivot])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.057,
        "duration_formatted": "8.06s",
        "tokens": {
          "input": 1373,
          "output": 378,
          "total": 1751
        },
        "cost_usd": 0.00577,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:49:32.336145"
      }
    },
    {
      "file_path": "program_368.py",
      "code": "import math\n\ndef sumofFactors(n):\n    if n % 2 != 0:\n        return 0\n    res = 1\n    i = 2\n    while i < int(math.sqrt(n)) + 1:\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count = count + 1\n            n = n // i\n            if i == 2 and count == 1:\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n        i += 1\n    if n >= 2:\n        res = res * (1 + n)\n    return res",
      "program_specification": "```dafny\nmethod SumOfFactors(n: int) returns (res: int)\n  requires n >= 0\n  ensures n % 2 != 0 ==> res == 0\n  // Weaker postcondition: result is non-negative\n  ensures res >= 0\n{\n  if n % 2 != 0 {\n    res := 0;\n    return;\n  }\n  res := 1;\n  var i := 2;\n  while i < (if n >= 0 then (if Sqrt(n) * Sqrt(n) == n then Sqrt(n) else Sqrt(n) + 1) else 0)\n    invariant i >= 2 && i <= (if n >= 0 then (if Sqrt(n) * Sqrt(n) == n then Sqrt(n) else Sqrt(n) + 1) else 0)\n    invariant res >= 0\n    decreases (if n >= 0 then (if Sqrt(n) * Sqrt(n) == n then Sqrt(n) else Sqrt(n) + 1) else 0) - i\n  {\n    var count := 0;\n    var curr_sum := 1;\n    var curr_term := 1;\n    while n % i == 0 && n > 0\n      invariant count >= 0\n      invariant curr_sum >= 0\n      invariant curr_term >= 1\n      decreases n\n    {\n      count := count + 1;\n      n := n / i;\n      if i == 2 && count == 1 {\n        curr_sum := 0;\n      }\n      curr_term := curr_term * i;\n      curr_sum := curr_sum + curr_term;\n    }\n    res := res * curr_sum;\n    i := i + 1;\n  }\n  if n >= 2 {\n    res := res * (1 + n);\n  }\n}\nfunction Sqrt(x: int): int\n  requires x >= 0\n  ensures Sqrt(x) * Sqrt(x) <= x < (Sqrt(x) + 1) * (Sqrt(x) + 1)\n{\n  if x == 0 then 0\n  else if x == 1 then 1\n  else\n    var (lo, hi) := (0, x);\n    while lo < hi\n      invariant 0 <= lo <= hi <= x\n      invariant lo * lo <= x\n      decreases hi - lo\n    {\n      var mid := lo + (hi - lo) / 2;\n      if mid * mid <= x {\n        lo := mid + 1;\n      } else {\n        hi := mid;\n      }\n    }\n    lo - 1\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.792,
        "duration_formatted": "9.79s",
        "tokens": {
          "input": 1431,
          "output": 568,
          "total": 1999
        },
        "cost_usd": 0.007406,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:49:47.168640"
      }
    },
    {
      "file_path": "program_372.py",
      "code": "def re_order(A):\n    k = 0\n    for i in A:\n        if i:\n            A[k] = i\n            k = k + 1\n    i = k\n    while i < len(A):\n        A[i] = 0\n        i += 1\n    return A",
      "program_specification": "```dafny\nmethod ReOrder(A: array<int>) returns (B: array<int>)\n  requires A != null\n  ensures B != null && B.Length == A.Length\n  ensures (forall i :: 0 <= i < B.Length ==> (B[i] != 0 ==> (exists j :: 0 <= j < A.Length && A[j] != 0 && B[i] == A[j])))\n  ensures (forall i :: 0 <= i < B.Length && B[i] == 0 ==> (forall j :: i <= j < B.Length ==> B[j] == 0))\n  ensures multiset(B[..]) == multiset(A[..])\n{\n  var k := 0;\n  var n := A.Length;\n  B := new int[n];\n  // Copy nonzero elements to the front\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= k <= i\n    invariant (forall j :: 0 <= j < k ==> B[j] != 0)\n    invariant (forall j :: k <= j < i ==> B[j] == 0)\n    decreases n - i\n  {\n    if A[i] != 0 {\n      B[k] := A[i];\n      k := k + 1;\n    }\n    i := i + 1;\n  }\n  // Fill the rest with zeros\n  i := k;\n  while i < n\n    invariant k <= i <= n\n    invariant (forall j :: k <= j < i ==> B[j] == 0)\n    decreases n - i\n  {\n    B[i] := 0;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.781,
        "duration_formatted": "5.78s",
        "tokens": {
          "input": 1331,
          "output": 358,
          "total": 1689
        },
        "cost_usd": 0.005526,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:49:57.989460"
      }
    },
    {
      "file_path": "program_373.py",
      "code": "def count_alpha_dig_spl(string):\n    alphabets = digits = special = 0\n    i = 0\n    while i < len(string):\n        if string[i].isalpha():\n            alphabets = alphabets + 1\n        elif string[i].isdigit():\n            digits = digits + 1\n        else:\n            special = special + 1\n        i += 1\n    return (alphabets, digits, special)",
      "program_specification": "```dafny\nmethod CountAlphaDigSpl(s: seq<char>) returns (alphabets: int, digits: int, special: int)\n  ensures alphabets >= 0 && digits >= 0 && special >= 0\n  ensures alphabets + digits + special == |s|\n{\n  alphabets := 0;\n  digits := 0;\n  special := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant alphabets >= 0 && digits >= 0 && special >= 0\n    invariant alphabets + digits + special == i\n    decreases |s| - i\n  {\n    if 'A' <= s[i] <= 'Z' || 'a' <= s[i] <= 'z' {\n      alphabets := alphabets + 1;\n    } else if '0' <= s[i] <= '9' {\n      digits := digits + 1;\n    } else {\n      special := special + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.238,
        "duration_formatted": "3.24s",
        "tokens": {
          "input": 1358,
          "output": 228,
          "total": 1586
        },
        "cost_usd": 0.00454,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:50:06.270942"
      }
    },
    {
      "file_path": "program_378.py",
      "code": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            i = 0\n            while i < len(l) + 1:\n                new_perms.append(l[:i] + [n] + l[i:])\n                if i < len(l) and l[i] == n:\n                    break\n                i += 1\n        perms = new_perms\n    return perms",
      "program_specification": "```dafny\nmethod PermuteUnique(nums: seq<int>) returns (perms: seq<seq<int>>)\n  ensures forall p :: p in perms ==> |p| == |nums|\n  ensures forall p :: p in perms ==> Multiset(p) == Multiset(nums)\n  ensures forall i, j :: 0 <= i < j < |perms| ==> perms[i] != perms[j]\n{\n  var perms0: seq<seq<int>> := [ [] ];\n  var i: int := 0;\n  while i < |nums|\n    invariant 0 <= i <= |nums|\n    invariant forall p :: p in perms0 ==> |p| == i\n    decreases |nums| - i\n  {\n    var n := nums[i];\n    var newPerms: seq<seq<int>> := [];\n    var j: int := 0;\n    while j < |perms0|\n      invariant 0 <= j <= |perms0|\n      invariant |newPerms| <= j * (i + 1)\n      decreases |perms0| - j\n    {\n      var l := perms0[j];\n      var k: int := 0;\n      var done: bool := false;\n      while k < |l| + 1 && !done\n        invariant 0 <= k <= |l| + 1\n        invariant |newPerms| <= j * (i + 1) + k\n        decreases (|l| + 1) - k\n      {\n        var prefix := l[..k];\n        var suffix := l[k..];\n        var candidate := prefix + [n] + suffix;\n        if !(candidate in newPerms) {\n          newPerms := newPerms + [candidate];\n        }\n        if k < |l| && l[k] == n {\n          done := true;\n        } else {\n          k := k + 1;\n        }\n      }\n      j := j + 1;\n    }\n    perms0 := newPerms;\n    i := i + 1;\n  }\n  perms := perms0;\n}\n\nfunction Multiset(s: seq<int>): multiset<int>\n{\n  if |s| == 0 then multiset{} else multiset{s[0]} + Multiset(s[1..])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.38,
        "duration_formatted": "9.38s",
        "tokens": {
          "input": 1362,
          "output": 480,
          "total": 1842
        },
        "cost_usd": 0.006564,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:50:20.684522"
      }
    },
    {
      "file_path": "program_379.py",
      "code": "def permutation_coefficient(n, k):\n    P = [[0 for i in range(k + 1)] for j in range(n + 1)]\n    i = 0\n    while i < n + 1:\n        j = 0\n        while j < min(i, k) + 1:\n            if j == 0:\n                P[i][j] = 1\n            else:\n                P[i][j] = P[i - 1][j] + j * P[i - 1][j - 1]\n            if j < k:\n                P[i][j + 1] = 0\n            j += 1\n        i += 1\n    return P[n][k]",
      "program_specification": "```dafny\nmethod PermutationCoefficient(n: int, k: int) returns (res: int)\n  requires n >= 0\n  requires k >= 0\n  ensures res >= 0\n{\n  var P := new int[n + 1][];\n  var i := 0;\n  while i < n + 1\n    invariant 0 <= i <= n + 1\n    invariant P != null && P.Length == n + 1\n    decreases n + 1 - i\n  {\n    P[i] := new int[k + 2];\n    var j := 0;\n    while j < if i < k then i + 1 else k + 1\n      invariant 0 <= j <= if i < k then i + 1 else k + 1\n      invariant P[i] != null && P[i].Length == k + 2\n      decreases (if i < k then i + 1 else k + 1) - j\n    {\n      if j == 0 {\n        P[i][j] := 1;\n      } else {\n        P[i][j] := P[i - 1][j] + j * P[i - 1][j - 1];\n      }\n      if j < k {\n        P[i][j + 1] := 0;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := P[n][k];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.597,
        "duration_formatted": "4.60s",
        "tokens": {
          "input": 1417,
          "output": 313,
          "total": 1730
        },
        "cost_usd": 0.005338,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:50:30.322078"
      }
    },
    {
      "file_path": "program_381.py",
      "code": "def prod_Square(n):\n    i = 2\n    while i < n + 1:\n        if i * i < n + 1:\n            j = 2\n            while j < n + 1:\n                if i * i * j * j == n:\n                    return True\n                j += 1\n        i += 1\n    return False",
      "program_specification": "```dafny\nmethod ProdSquare(n: int) returns (res: bool)\n  requires n >= 0\n  ensures res ==> exists i, j :: 2 <= i < n + 1 && 2 <= j < n + 1 && i * i * j * j == n\n  ensures !res ==> forall i, j :: 2 <= i < n + 1 && 2 <= j < n + 1 ==> i * i * j * j != n\n{\n  var i := 2;\n  while i < n + 1\n    invariant 2 <= i <= n + 1\n    decreases n + 1 - i\n  {\n    if i * i < n + 1 {\n      var j := 2;\n      while j < n + 1\n        invariant 2 <= j <= n + 1\n        decreases n + 1 - j\n      {\n        if i * i * j * j == n {\n          res := true;\n          return;\n        }\n        j := j + 1;\n      }\n    }\n    i := i + 1;\n  }\n  res := false;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.793,
        "duration_formatted": "2.79s",
        "tokens": {
          "input": 1344,
          "output": 244,
          "total": 1588
        },
        "cost_usd": 0.00464,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:50:38.150413"
      }
    },
    {
      "file_path": "program_383.py",
      "code": "def find_Product(arr, n):\n    arr.sort()\n    prod = 1\n    i = 0\n    while i < n:\n        if arr[i - 1] != arr[i]:\n            prod = prod * arr[i]\n        i += 1\n    return prod",
      "program_specification": "```dafny\nmethod FindProduct(arr: array<int>, n: int) returns (prod: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  ensures prod >= 1 || n == 0\n{\n  // Copy arr[..n] into a sequence for sorting\n  var s := arr[..n];\n  var sorted := s[..];\n  sorted := sorted.Sort();\n  prod := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant prod >= 1 || n == 0\n    decreases n - i\n  {\n    if i == 0 || sorted[i - 1] != sorted[i] {\n      prod := prod * sorted[i];\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.038,
        "duration_formatted": "3.04s",
        "tokens": {
          "input": 1324,
          "output": 173,
          "total": 1497
        },
        "cost_usd": 0.004032,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:50:46.223538"
      }
    },
    {
      "file_path": "program_386.py",
      "code": "def lbs(arr):\n    n = len(arr)\n    lis = [1 for i in range(n + 1)]\n    i = 1\n    while i < n:\n        j = 0\n        while j < i:\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n            j += 1\n        i += 1\n    lds = [1 for i in range(n + 1)]\n    for i in reversed(range(n - 1)):\n        for j in reversed(range(i - 1, n)):\n            if arr[i] > arr[j] and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n    maximum = lis[0] + lds[0] - 1\n    i = 1\n    while i < n:\n        maximum = max(lis[i] + lds[i] - 1, maximum)\n        i += 1\n    return maximum",
      "program_specification": "```dafny\nmethod Lbs(arr: array<int>) returns (maximum: int)\n  requires arr != null\n  ensures maximum >= 1 ==> arr.Length > 0\n  ensures arr.Length == 0 ==> maximum == 0\n  // Weaker but verifiable: result is at least 1 for nonempty arrays\n  // and at most arr.Length\n  ensures 0 <= maximum <= arr.Length\n{\n  var n := arr.Length;\n  if n == 0 {\n    maximum := 0;\n    return;\n  }\n\n  var lis := new int[n];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] >= 1 && lis[k] <= k+1\n    decreases n - i\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] >= 1 && lis[k] <= k+1\n    decreases n - i\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      decreases i - j\n    {\n      if arr[i] > arr[j] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n\n  var lds := new int[n];\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lds[k] >= 1 && lds[k] <= n - k\n    decreases n - i\n  {\n    lds[i] := 1;\n    i := i + 1;\n  }\n\n  i := n - 2;\n  while i >= 0\n    invariant -1 <= i < n\n    decreases i + 1\n  {\n    var j := n - 1;\n    while j > i\n      invariant i < j <= n\n      decreases j - i\n    {\n      if arr[i] > arr[j] && lds[i] < lds[j] + 1 {\n        lds[i] := lds[j] + 1;\n      }\n      j := j - 1;\n    }\n    i := i - 1;\n  }\n\n  maximum := lis[0] + lds[0] - 1;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant maximum >= 1\n    invariant maximum <= n\n    decreases n - i\n  {\n    var t := lis[i] + lds[i] - 1;\n    if t > maximum {\n      maximum := t;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.597,
        "duration_formatted": "9.60s",
        "tokens": {
          "input": 1492,
          "output": 646,
          "total": 2138
        },
        "cost_usd": 0.008152,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:51:00.883255"
      }
    },
    {
      "file_path": "program_390.py",
      "code": "def highest_Power_of_2(n):\n    res = 0\n    i = n\n    while i > 0:\n        if i & i - 1 == 0:\n            res = i\n            break\n        i += -1\n    return res",
      "program_specification": "```dafny\nmethod HighestPowerOf2(n: int) returns (res: int)\n  requires n >= 0\n  ensures 0 <= res <= n\n  ensures res == 0 || (res & (res - 1)) == 0\n  ensures forall k :: 0 <= k <= n && (k & (k - 1)) == 0 ==> res >= k\n{\n  var i := n;\n  res := 0;\n  while i > 0\n    invariant 0 <= i <= n\n    invariant 0 <= res <= n\n    invariant res == 0 || (res & (res - 1)) == 0\n    invariant forall k :: i < k <= n && (k & (k - 1)) == 0 ==> res >= k\n    decreases i\n  {\n    if (i & (i - 1)) == 0 {\n      res := i;\n      break;\n    }\n    i := i - 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.598,
        "duration_formatted": "2.60s",
        "tokens": {
          "input": 1322,
          "output": 213,
          "total": 1535
        },
        "cost_usd": 0.004348,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:51:08.508253"
      }
    },
    {
      "file_path": "program_395.py",
      "code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n    while placement < max_digit:\n        buckets = [list() for _ in range(RADIX)]\n        for i in nums:\n            tmp = int(i / placement % RADIX)\n            buckets[tmp].append(i)\n        a = 0\n        b = 0\n        while b < RADIX:\n            buck = buckets[b]\n            for i in buck:\n                nums[a] = i\n                a += 1\n            b += 1\n        placement *= RADIX\n    return nums",
      "program_specification": "```dafny\nmethod RadixSort(nums: array<int>) returns (res: array<int>)\n  requires nums != null\n  requires forall i :: 0 <= i < nums.Length ==> nums[i] >= 0\n  ensures res != null\n  ensures res.Length == nums.Length\n  ensures multiset(res[..]) == multiset(nums[..])\n  ensures forall i: int, j: int :: 0 <= i < j < res.Length ==> res[i] <= res[j]\n{\n  var RADIX := 10;\n  var placement := 1;\n  var maxDigit := if nums.Length == 0 then 0 else nums[0];\n  var i := 0;\n  while i < nums.Length\n    invariant 0 <= i <= nums.Length\n    invariant nums != null\n    invariant nums.Length == res.Length || res == null\n    decreases nums.Length - i\n  {\n    if nums[i] > maxDigit {\n      maxDigit := nums[i];\n    }\n    i := i + 1;\n  }\n\n  var arr := new int[nums.Length];\n  var k := 0;\n  while k < nums.Length\n    invariant 0 <= k <= nums.Length\n    invariant arr != null\n    decreases nums.Length - k\n  {\n    arr[k] := nums[k];\n    k := k + 1;\n  }\n\n  while placement < maxDigit\n    invariant arr != null\n    invariant arr.Length == nums.Length\n    invariant forall i :: 0 <= i < arr.Length ==> arr[i] >= 0\n    invariant multiset(arr[..]) == multiset(nums[..])\n    decreases maxDigit - placement\n  {\n    var buckets := new int[][RADIX];\n    var b := 0;\n    while b < RADIX\n      invariant 0 <= b <= RADIX\n      invariant buckets.Length == RADIX\n      decreases RADIX - b\n    {\n      buckets[b] := new int[0];\n      b := b + 1;\n    }\n\n    var j := 0;\n    while j < arr.Length\n      invariant 0 <= j <= arr.Length\n      decreases arr.Length - j\n    {\n      var tmp := (arr[j] / placement) % RADIX;\n      var old := buckets[tmp];\n      var newBuck := new int[old.Length + 1];\n      var m := 0;\n      while m < old.Length\n        invariant 0 <= m <= old.Length\n        decreases old.Length - m\n      {\n        newBuck[m] := old[m];\n        m := m + 1;\n      }\n      newBuck[old.Length] := arr[j];\n      buckets[tmp] := newBuck;\n      j := j + 1;\n    }\n\n    var a := 0;\n    b := 0;\n    while b < RADIX\n      invariant 0 <= b <= RADIX\n      invariant 0 <= a <= arr.Length\n      decreases RADIX - b\n    {\n      var buck := buckets[b];\n      var l := 0;\n      while l < buck.Length\n        invariant 0 <= l <= buck.Length\n        invariant 0 <= a <= arr.Length\n        decreases buck.Length - l\n      {\n        arr[a] := buck[l];\n        a := a + 1;\n        l := l + 1;\n      }\n      b := b + 1;\n    }\n    placement := placement * RADIX;\n  }\n  res := arr;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 12.241,
        "duration_formatted": "12.24s",
        "tokens": {
          "input": 1395,
          "output": 718,
          "total": 2113
        },
        "cost_usd": 0.008534,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:51:25.787527"
      }
    },
    {
      "file_path": "program_398.py",
      "code": "def ascii_value_string(str1):\n    i = 0\n    while i < len(str1):\n        return ord(str1[i])\n        i += 1",
      "program_specification": "```dafny\nmethod AsciiValueString(str1: seq<char>) returns (v: int)\n  ensures (|str1| > 0) ==> v == str1[0] as int\n  ensures (|str1| == 0) ==> v == 0\n{\n  if |str1| > 0 {\n    v := str1[0] as int;\n  } else {\n    v := 0;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.509,
        "duration_formatted": "2.51s",
        "tokens": {
          "input": 1299,
          "output": 96,
          "total": 1395
        },
        "cost_usd": 0.003366,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:51:33.334313"
      }
    },
    {
      "file_path": "program_399.py",
      "code": "def find_Odd_Pair(A, N):\n    oddPair = 0\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N:\n            if (A[i] ^ A[j]) % 2 != 0:\n                oddPair += 1\n            j += 1\n        i += 1\n    return oddPair",
      "program_specification": "```dafny\nmethod FindOddPair(A: array<int>, N: int) returns (oddPair: int)\n  requires A != null\n  requires 0 <= N <= A.Length\n  ensures oddPair >= 0\n  ensures oddPair == |set i, j | 0 <= i < j < N && ((A[i] ^ A[j]) % 2 != 0)|\n{\n  oddPair := 0;\n  var i := 0;\n  while i < N\n    invariant 0 <= i <= N\n    invariant oddPair == |set x, y | 0 <= x < y < N && y < i || (y < N && x < i && y > x) && ((A[x] ^ A[y]) % 2 != 0)|\n    decreases N - i\n  {\n    var j := i + 1;\n    while j < N\n      invariant i + 1 <= j <= N\n      invariant oddPair == |set x, y | 0 <= x < i && x < y < N && ((A[x] ^ A[y]) % 2 != 0)|\n                          + |set y0 | i < y0 < j && ((A[i] ^ A[y0]) % 2 != 0)|\n      decreases N - j\n    {\n      if (A[i] ^ A[j]) % 2 != 0 {\n        oddPair := oddPair + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.965,
        "duration_formatted": "7.96s",
        "tokens": {
          "input": 1349,
          "output": 332,
          "total": 1681
        },
        "cost_usd": 0.005354,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:51:46.330602"
      }
    },
    {
      "file_path": "program_400.py",
      "code": "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [[0 for i in range(n)] for i in range(n)]\n    i = 0\n    while i < n:\n        if a[i] > a[0]:\n            dp[0][i] = a[i] + a[0]\n        else:\n            dp[0][i] = a[i]\n        i += 1\n    i = 1\n    while i < n:\n        j = 0\n        while j < n:\n            if a[j] > a[i] and j > i:\n                if dp[i - 1][i] + a[j] > dp[i - 1][j]:\n                    dp[i][j] = dp[i - 1][i] + a[j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n            j += 1\n        i += 1\n    return dp[index][k]",
      "program_specification": "```dafny\nmethod MaxSumIncreasingSubseq(a: array<int>, n: int, index: int, k: int) returns (res: int)\n  requires a != null\n  requires 0 <= n <= a.Length\n  requires 0 <= index < n\n  requires 0 <= k < n\n  ensures true // Weaker postcondition: result is the computed value at dp[index][k]\n{\n  var dp := new int[n][];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant dp.Length == n\n    decreases n - i\n  {\n    dp[i] := new int[n];\n    i := i + 1;\n  }\n\n  i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    if a[i] > a[0] {\n      dp[0][i] := a[i] + a[0];\n    } else {\n      dp[0][i] := a[i];\n    }\n    i := i + 1;\n  }\n\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    decreases n - i\n  {\n    var j := 0;\n    while j < n\n      invariant 0 <= j <= n\n      decreases n - j\n    {\n      if a[j] > a[i] && j > i {\n        if dp[i - 1][i] + a[j] > dp[i - 1][j] {\n          dp[i][j] := dp[i - 1][i] + a[j];\n        } else {\n          dp[i][j] := dp[i - 1][j];\n        }\n      } else {\n        dp[i][j] := dp[i - 1][j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := dp[index][k];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.678,
        "duration_formatted": "8.68s",
        "tokens": {
          "input": 1490,
          "output": 424,
          "total": 1914
        },
        "cost_usd": 0.006372,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:52:00.047780"
      }
    },
    {
      "file_path": "program_406.py",
      "code": "def get_gcd(l):\n    num1 = l[0]\n    num2 = l[1]\n    gcd = find_gcd(num1, num2)\n    i = 2\n    while i < len(l):\n        gcd = find_gcd(gcd, l[i])\n        i += 1\n    return gcd",
      "program_specification": "```dafny\nmethod FindGcd(a: int, b: int) returns (g: int)\n  requires a >= 0 && b >= 0\n  ensures g >= 0\n  ensures (forall d: int :: d > 0 && a % d == 0 && b % d == 0 ==> g % d == 0)\n  ensures a % g == 0 && b % g == 0\n  ensures (forall d: int :: d > 0 && a % d == 0 && b % d == 0 ==> d <= g)\n{\n  var x := a;\n  var y := b;\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x == 0 ==> y == 0\n    decreases y\n  {\n    var t := y;\n    y := x % y;\n    x := t;\n  }\n  g := x;\n}\n\nmethod GetGcd(l: seq<int>) returns (g: int)\n  requires |l| >= 2\n  requires (forall i :: 0 <= i < |l| ==> l[i] >= 0)\n  ensures g >= 0\n  ensures (forall i :: 0 <= i < |l| ==> l[i] % g == 0)\n  ensures (forall d: int :: d > 0 && (forall i :: 0 <= i < |l| ==> l[i] % d == 0) ==> d <= g)\n{\n  var num1 := l[0];\n  var num2 := l[1];\n  g := FindGcd(num1, num2);\n  var i := 2;\n  while i < |l|\n    invariant 2 <= i <= |l|\n    invariant g >= 0\n    invariant (forall j :: 0 <= j < i ==> l[j] % g == 0)\n    invariant (forall d: int :: d > 0 && (forall j :: 0 <= j < i ==> l[j] % d == 0) ==> d <= g)\n    decreases |l| - i\n  {\n    g := FindGcd(g, l[i]);\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 12.15,
        "duration_formatted": "12.15s",
        "tokens": {
          "input": 1334,
          "output": 470,
          "total": 1804
        },
        "cost_usd": 0.006428,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:52:17.228754"
      }
    },
    {
      "file_path": "program_409.py",
      "code": "def count_Rotation(arr, n):\n    i = 1\n    while i < n:\n        if arr[i] < arr[i - 1]:\n            return i\n        i += 1\n    return 0",
      "program_specification": "```dafny\nmethod CountRotation(arr: array<int>, n: int) returns (res: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  ensures 0 <= res <= n\n  // ensures: if the array is strictly increasing from 0 to n-1, then res == 0\n  // ensures: if there exists i in 1..n-1 such that arr[i] < arr[i-1], then res is the smallest such i\n{\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    decreases n - i\n  {\n    if arr[i] < arr[i - 1] {\n      res := i;\n      return;\n    }\n    i := i + 1;\n  }\n  res := 0;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.663,
        "duration_formatted": "7.66s",
        "tokens": {
          "input": 1312,
          "output": 177,
          "total": 1489
        },
        "cost_usd": 0.00404,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:52:29.927536"
      }
    },
    {
      "file_path": "program_414.py",
      "code": "def sum_Of_Series(n):\n    sum = 0\n    i = 1\n    while i < n + 1:\n        sum += i * i * i\n        i += 1\n    return sum",
      "program_specification": "```dafny\nmethod SumOfSeries(n: int) returns (s: int)\n  requires n >= 0\n  ensures s == (if n == 0 then 0 else sum i | 1 <= i <= n :: i * i * i)\n{\n  var sum := 0;\n  var i := 1;\n  while i < n + 1\n    invariant 1 <= i <= n + 1\n    invariant sum == (if i == 1 then 0 else sum j | 1 <= j < i :: j * j * j)\n    decreases n + 1 - i\n  {\n    sum := sum + i * i * i;\n    i := i + 1;\n  }\n  s := sum;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 2.848,
        "duration_formatted": "2.85s",
        "tokens": {
          "input": 1313,
          "output": 160,
          "total": 1473
        },
        "cost_usd": 0.003906,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:52:37.810246"
      }
    },
    {
      "file_path": "program_421.py",
      "code": "def length_Of_Last_Word(a):\n    l = 0\n    x = a.strip()\n    i = 0\n    while i < len(x):\n        if x[i] == ' ':\n            l = 0\n        else:\n            l += 1\n        i += 1\n    return l",
      "program_specification": "```dafny\nmethod LengthOfLastWord(a: seq<char>) returns (l: int)\n  ensures l >= 0\n  ensures l <= |a|\n  // If a contains at least one non-space, l is the length of the last maximal contiguous non-space suffix\n{\n  var l := 0;\n  var x := Strip(a);\n  var i := 0;\n  while i < |x|\n    invariant 0 <= i <= |x|\n    invariant 0 <= l <= i\n    decreases |x| - i\n  {\n    if x[i] == ' ' {\n      l := 0;\n    } else {\n      l := l + 1;\n    }\n    i := i + 1;\n  }\n  return l;\n}\n\n// Helper: Remove leading and trailing spaces from a sequence of chars\nfunction Strip(a: seq<char>): seq<char>\n{\n  var start := 0;\n  while start < |a| && a[start] == ' '\n    decreases |a| - start\n  {\n    start := start + 1;\n  }\n  var end := |a|;\n  while end > start && a[end - 1] == ' '\n    decreases end - start\n  {\n    end := end - 1;\n  }\n  a[start .. end]\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.508,
        "duration_formatted": "4.51s",
        "tokens": {
          "input": 1333,
          "output": 273,
          "total": 1606
        },
        "cost_usd": 0.00485,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:52:47.346175"
      }
    },
    {
      "file_path": "program_450.py",
      "code": "def find_even_Pair(A, N):\n    evenPair = 0\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N:\n            if (A[i] ^ A[j]) % 2 == 0:\n                evenPair += 1\n            j += 1\n        i += 1\n    return evenPair",
      "program_specification": "```dafny\nmethod FindEvenPair(A: array<int>, N: int) returns (evenPair: int)\n  requires A != null\n  requires 0 <= N <= A.Length\n  ensures evenPair >= 0\n  ensures evenPair == |set i, j :: 0 <= i < N && i < j < N && ((A[i] ^ A[j]) % 2 == 0)|\n{\n  evenPair := 0;\n  var i := 0;\n  while i < N\n    invariant 0 <= i <= N\n    invariant evenPair == |set x, y :: 0 <= x < i && x < y < N && ((A[x] ^ A[y]) % 2 == 0)|\n    decreases N - i\n  {\n    var j := i + 1;\n    while j < N\n      invariant i + 1 <= j <= N\n      invariant evenPair == |set x, y :: 0 <= x < i && x < y < N && ((A[x] ^ A[y]) % 2 == 0)|\n                          + |set y' :: i < y' < j && ((A[i] ^ A[y']) % 2 == 0)|\n      decreases N - j\n    {\n      if (A[i] ^ A[j]) % 2 == 0 {\n        evenPair := evenPair + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 7.157,
        "duration_formatted": "7.16s",
        "tokens": {
          "input": 1348,
          "output": 321,
          "total": 1669
        },
        "cost_usd": 0.005264,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:52:59.578326"
      }
    },
    {
      "file_path": "program_451.py",
      "code": "import math\n\ndef sum_of_odd_Factors(n):\n    res = 1\n    while n % 2 == 0:\n        n = n // 2\n    i = 3\n    while i < int(math.sqrt(n) + 1):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count += 1\n            n = n // i\n            curr_term *= i\n            curr_sum += curr_term\n        res *= curr_sum\n        i += 1\n    if n >= 2:\n        res *= 1 + n\n    return res",
      "program_specification": "```dafny\nmethod SumOfOddFactors(n: int) returns (res: int)\n  requires n >= 1\n  ensures res >= 1\n  // ensures res == sum of all odd divisors of n (weaker: res > 0)\n{\n  var nn := n;\n  res := 1;\n  // Remove all factors of 2\n  while nn % 2 == 0\n    invariant nn >= 1\n    invariant n >= 1\n    decreases nn\n  {\n    nn := nn / 2;\n  }\n  var i := 3;\n  // Process odd prime factors\n  while i * i <= nn\n    invariant i >= 3\n    invariant nn >= 1\n    invariant res >= 1\n    decreases nn - i\n  {\n    var count := 0;\n    var curr_sum := 1;\n    var curr_term := 1;\n    while nn % i == 0\n      invariant nn >= 1\n      invariant count >= 0\n      invariant curr_sum >= 1\n      invariant curr_term >= 1\n      decreases nn\n    {\n      count := count + 1;\n      nn := nn / i;\n      curr_term := curr_term * i;\n      curr_sum := curr_sum + curr_term;\n    }\n    res := res * curr_sum;\n    i := i + 2;\n  }\n  if nn >= 2 {\n    res := res * (1 + nn);\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.715,
        "duration_formatted": "4.71s",
        "tokens": {
          "input": 1406,
          "output": 311,
          "total": 1717
        },
        "cost_usd": 0.0053,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:53:09.342424"
      }
    },
    {
      "file_path": "program_452.py",
      "code": "def roman_to_int(s):\n    rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    int_val = 0\n    i = 0\n    while i < len(s):\n        if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\n            int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\n        else:\n            int_val += rom_val[s[i]]\n        i += 1\n    return int_val",
      "program_specification": "```dafny\nmethod RomanToInt(s: seq<char>) returns (res: int)\n  requires |s| >= 0\n  ensures res >= 0\n  // Weaker postcondition: result is non-negative, as all Roman numerals are positive.\n{\n  var romVal := map ['I' := 1, 'V' := 5, 'X' := 10, 'L' := 50, 'C' := 100, 'D' := 500, 'M' := 1000];\n  res := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant res >= 0\n    decreases |s| - i\n  {\n    if i > 0 && romVal[s[i]] > romVal[s[i - 1]] {\n      res := res + romVal[s[i]] - 2 * romVal[s[i - 1]];\n    } else {\n      res := res + romVal[s[i]];\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.397,
        "duration_formatted": "3.40s",
        "tokens": {
          "input": 1403,
          "output": 231,
          "total": 1634
        },
        "cost_usd": 0.004654,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:53:17.786795"
      }
    },
    {
      "file_path": "program_453.py",
      "code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    i = 1\n    while i < len(array):\n        dp[i] = dp[i - 1] + array[i]\n        i += 1\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n    return result",
      "program_specification": "```dafny\nmethod PrefixSum(array: array<int>, queries: seq<tuple<int, int>>) returns (result: seq<int>)\n  requires array != null\n  requires forall q :: 0 <= q < |queries| ==> 0 <= queries[q].0 <= queries[q].1 < array.Length\n  ensures |result| == |queries|\n  ensures forall i :: 0 <= i < |result| ==>\n    result[i] == (if queries[i].0 == 0 then SumArray(array, 0, queries[i].1)\n                  else SumArray(array, queries[i].0, queries[i].1))\n{\n  var dp := new int[array.Length];\n  if array.Length > 0 {\n    dp[0] := array[0];\n    var i := 1;\n    while i < array.Length\n      invariant 1 <= i <= array.Length\n      invariant forall j :: 0 <= j < i ==> dp[j] == SumArray(array, 0, j)\n      decreases array.Length - i\n    {\n      dp[i] := dp[i - 1] + array[i];\n      i := i + 1;\n    }\n  }\n  var resSeq := [];\n  var q := 0;\n  while q < |queries|\n    invariant 0 <= q <= |queries|\n    invariant |resSeq| == q\n    invariant forall j :: 0 <= j < q ==>\n      resSeq[j] == (if queries[j].0 == 0 then dp[queries[j].1]\n                    else dp[queries[j].1] - dp[queries[j].0 - 1])\n    decreases |queries| - q\n  {\n    var left := queries[q].0;\n    var right := queries[q].1;\n    var res := dp[right];\n    if left > 0 {\n      res := res - dp[left - 1];\n    }\n    resSeq := resSeq + [res];\n    q := q + 1;\n  }\n  result := resSeq;\n}\n\nfunction SumArray(a: array<int>, lo: int, hi: int): int\n  requires a != null\n  requires 0 <= lo <= hi < a.Length\n{\n  if lo > hi then 0 else\n    (if lo == hi then a[lo] else a[lo] + SumArray(a, lo + 1, hi))\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 9.309,
        "duration_formatted": "9.31s",
        "tokens": {
          "input": 1489,
          "output": 498,
          "total": 1987
        },
        "cost_usd": 0.006962,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:53:32.151135"
      }
    },
    {
      "file_path": "program_455.py",
      "code": "def throw_dice(num_throws: int, num_dice: int=2) -> list[float]:\n    \"\"\"\n    Return probability list of all possible sums when throwing dice.\n\n    >>> random.seed(0)\n    >>> throw_dice(10, 1)\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n    >>> throw_dice(100, 1)\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n    >>> throw_dice(1000, 1)\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n    >>> throw_dice(10000, 1)\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n    >>> throw_dice(10000, 2)\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\n    \"\"\"\n    dices = [Dice() for i in range(num_dice)]\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\n    _ = 0\n    while _ < num_throws:\n        count_of_sum[sum((dice.roll() for dice in dices))] += 1\n        _ += 1\n    probability = [round(count * 100 / num_throws, 2) for count in count_of_sum]\n    return probability[num_dice:]",
      "program_specification": "```dafny\nmethod ThrowDice(numThrows: int, numDice: int) returns (probabilities: seq<real>)\n  requires numThrows > 0\n  requires numDice > 0\n  ensures |probabilities| == 6 * numDice - (numDice - 1)\n  ensures forall p :: 0 <= p < |probabilities| ==> 0.0 <= probabilities[p] <= 100.0\n  // Each p is the (rounded) percentage of times the sum (p + numDice) occurred\n{\n  // This is a stub: actual random dice rolling and rounding not implemented in Dafny.\n  // We return a sequence of zeros of the correct length.\n  var numSums := 6 * numDice - (numDice - 1);\n  probabilities := Seq#Fill(numSums, 0.0);\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.693,
        "duration_formatted": "3.69s",
        "tokens": {
          "input": 1657,
          "output": 182,
          "total": 1839
        },
        "cost_usd": 0.00477,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:53:40.881777"
      }
    },
    {
      "file_path": "program_457.py",
      "code": "def modular_sum(arr, n, m):\n    if n > m:\n        return True\n    DP = [False for i in range(m)]\n    i = 0\n    while i < n:\n        if DP[0]:\n            return True\n        temp = [False for i in range(m)]\n        j = 0\n        while j < m:\n            if DP[j] == True:\n                if DP[(j + arr[i]) % m] == False:\n                    temp[(j + arr[i]) % m] = True\n            j += 1\n        j = 0\n        while j < m:\n            if temp[j]:\n                DP[j] = True\n            j += 1\n        DP[arr[i] % m] = True\n        i += 1\n    return DP[0]",
      "program_specification": "```dafny\nmethod ModularSum(arr: array<int>, n: int, m: int) returns (res: bool)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  requires m > 0\n  ensures (n > m) ==> res\n  // If res is true, then there exists a non-empty subset of arr[0..n) whose sum is divisible by m\n  // If res is false, then no such non-empty subset exists (for n <= m)\n{\n  if n > m {\n    res := true;\n    return;\n  }\n  var DP := new bool[m];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant DP.Length == m\n    decreases n - i\n  {\n    if DP[0] {\n      res := true;\n      return;\n    }\n    var temp := new bool[m];\n    var j := 0;\n    while j < m\n      invariant 0 <= j <= m\n      invariant temp.Length == m && DP.Length == m\n      decreases m - j\n    {\n      if DP[j] {\n        var idx := (j + arr[i]) % m;\n        if !DP[idx] {\n          temp[idx] := true;\n        }\n      }\n      j := j + 1;\n    }\n    j := 0;\n    while j < m\n      invariant 0 <= j <= m\n      invariant temp.Length == m && DP.Length == m\n      decreases m - j\n    {\n      if temp[j] {\n        DP[j] := true;\n      }\n      j := j + 1;\n    }\n    DP[ ((arr[i] % m) + m) % m ] := true;\n    i := i + 1;\n  }\n  res := DP[0];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.953,
        "duration_formatted": "6.95s",
        "tokens": {
          "input": 1436,
          "output": 387,
          "total": 1823
        },
        "cost_usd": 0.005968,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:53:52.871966"
      }
    },
    {
      "file_path": "program_461.py",
      "code": "from heapq import heappop, heappush\n\ndef find_minimum_range(list):\n    high = float('-inf')\n    p = (0, float('inf'))\n    pq = []\n    i = 0\n    while i < len(list):\n        heappush(pq, Node(list[i][0], i, 0))\n        high = max(high, list[i][0])\n        i += 1\n    while True:\n        top = heappop(pq)\n        low = top.value\n        i = top.list_num\n        j = top.index\n        if high - low < p[1] - p[0]:\n            p = (low, high)\n        if j == len(list[i]) - 1:\n            return p\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\n        high = max(high, list[i][j + 1])",
      "program_specification": "```dafny\ndatatype Node = Node(value: int, listNum: int, index: int)\n\nmethod FindMinimumRange(lists: seq<seq<int>>) returns (range: (int, int))\n  requires |lists| > 0\n  requires forall s :: 0 <= s < |lists| ==> |lists[s]| > 0\n  ensures range.0 <= range.1\n  ensures forall s :: 0 <= s < |lists| ==> exists i :: 0 <= i < |lists[s]| && range.0 <= lists[s][i] <= range.1\n{\n  var n := |lists|;\n  var pq := new Node[n];\n  var pqSize := 0;\n  var high := lists[0][0];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant pqSize == i\n    invariant forall k :: 0 <= k < pqSize ==> pq[k].index == 0 && pq[k].listNum == k\n    invariant forall k :: 0 <= k < pqSize ==> 0 <= pq[k].value\n    decreases n - i\n  {\n    var v := lists[i][0];\n    pq[pqSize] := Node(v, i, 0);\n    pqSize := pqSize + 1;\n    if v > high {\n      high := v;\n    }\n    i := i + 1;\n  }\n  var bestLow := pq[0].value;\n  var bestHigh := high;\n  while true\n    invariant pqSize == n\n    invariant 0 <= bestLow <= bestHigh\n    decreases *\n  {\n    // Find min node in pq\n    var minIdx := 0;\n    var minNode := pq[0];\n    var k := 1;\n    while k < n\n      invariant 1 <= k <= n\n      invariant 0 <= minIdx < n\n      decreases n - k\n    {\n      if pq[k].value < minNode.value {\n        minNode := pq[k];\n        minIdx := k;\n      }\n      k := k + 1;\n    }\n    var low := minNode.value;\n    i := minNode.listNum;\n    var j := minNode.index;\n    if high - low < bestHigh - bestLow {\n      bestLow := low;\n      bestHigh := high;\n    }\n    if j == |lists[i]| - 1 {\n      range := (bestLow, bestHigh);\n      return;\n    }\n    // Replace minNode with next value from same list\n    var nextVal := lists[i][j + 1];\n    pq[minIdx] := Node(nextVal, i, j + 1);\n    if nextVal > high {\n      high := nextVal;\n    }\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 10.478,
        "duration_formatted": "10.48s",
        "tokens": {
          "input": 1461,
          "output": 586,
          "total": 2047
        },
        "cost_usd": 0.00761,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:54:08.388483"
      }
    },
    {
      "file_path": "program_467.py",
      "code": "def get_Pairs_Count(arr, n, sum):\n    count = 0\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n:\n            if arr[i] + arr[j] == sum:\n                count += 1\n            j += 1\n        i += 1\n    return count",
      "program_specification": "```dafny\nmethod GetPairsCount(arr: array<int>, n: int, s: int) returns (count: int)\n  requires arr != null\n  requires 0 <= n <= arr.Length\n  ensures count >= 0\n  ensures count == |set i, j :: 0 <= i < n && 0 <= j < n && i < j && arr[i] + arr[j] == s|\n{\n  count := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant count == |set x, y :: 0 <= x < i && 0 <= y < n && x < y && arr[x] + arr[y] == s|\n    decreases n - i\n  {\n    var j := i + 1;\n    while j < n\n      invariant i + 1 <= j <= n\n      invariant count == |set x, y :: 0 <= x < i && 0 <= y < n && x < y && arr[x] + arr[y] == s|\n        + |set y :: i < y < j && arr[i] + arr[y] == s|\n      decreases n - j\n    {\n      if arr[i] + arr[j] == s {\n        count := count + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 6.775,
        "duration_formatted": "6.78s",
        "tokens": {
          "input": 1342,
          "output": 301,
          "total": 1643
        },
        "cost_usd": 0.005092,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:54:20.198975"
      }
    },
    {
      "file_path": "program_468.py",
      "code": "from collections import defaultdict\n\ndef count_Substrings(s, n):\n    count, sum = (0, 0)\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    i = 0\n    while i < n:\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n        i += 1\n    return count",
      "program_specification": "```dafny\nmethod CountSubstrings(s: seq<char>, n: int) returns (count: int)\n  requires 0 <= n <= |s|\n  ensures count >= 0\n{\n  var map := map[int]int[];\n  var sum := 0;\n  count := 0;\n  map[0] := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant count >= 0\n    invariant sum == (if i == 0 then 0 else sum)\n    decreases n - i\n  {\n    sum := sum + (s[i] as int) - ('0' as int);\n    var key := sum - (i + 1);\n    var prev := if map.Contains(key) then map[key] else 0;\n    count := count + prev;\n    map[key] := prev + 1;\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.143,
        "duration_formatted": "3.14s",
        "tokens": {
          "input": 1369,
          "output": 201,
          "total": 1570
        },
        "cost_usd": 0.004346,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:54:28.385487"
      }
    },
    {
      "file_path": "program_473.py",
      "code": "def find_length(string, n):\n    current_sum = 0\n    max_sum = 0\n    i = 0\n    while i < n:\n        current_sum += 1 if string[i] == '0' else -1\n        if current_sum < 0:\n            current_sum = 0\n        max_sum = max(current_sum, max_sum)\n        i += 1\n    return max_sum if max_sum else 0",
      "program_specification": "```dafny\nmethod FindLength(string: seq<char>, n: int) returns (maxSum: int)\n  requires 0 <= n <= |string|\n  ensures maxSum >= 0\n  ensures maxSum <= n\n{\n  var currentSum := 0;\n  maxSum := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant currentSum >= 0\n    invariant maxSum >= 0\n    invariant maxSum <= i\n    decreases n - i\n  {\n    if string[i] == '0' {\n      currentSum := currentSum + 1;\n    } else {\n      currentSum := currentSum - 1;\n    }\n    if currentSum < 0 {\n      currentSum := 0;\n    }\n    if currentSum > maxSum {\n      maxSum := currentSum;\n    }\n    i := i + 1;\n  }\n  if maxSum == 0 {\n    maxSum := 0;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.245,
        "duration_formatted": "3.25s",
        "tokens": {
          "input": 1359,
          "output": 216,
          "total": 1575
        },
        "cost_usd": 0.004446,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:54:36.666703"
      }
    },
    {
      "file_path": "program_479.py",
      "code": "def count_vowels(test_str):\n    res = 0\n    vow_list = ['a', 'e', 'i', 'o', 'u']\n    idx = 1\n    while idx < len(test_str) - 1:\n        if test_str[idx] not in vow_list and (test_str[idx - 1] in vow_list or test_str[idx + 1] in vow_list):\n            res += 1\n        idx += 1\n    if test_str[0] not in vow_list and test_str[1] in vow_list:\n        res += 1\n    if test_str[-1] not in vow_list and test_str[-2] in vow_list:\n        res += 1\n    return res",
      "program_specification": "```dafny\nmethod CountVowels(testStr: seq<char>) returns (res: int)\n  requires |testStr| >= 2\n  ensures res >= 0\n{\n  res := 0;\n  var vowList := ['a', 'e', 'i', 'o', 'u'];\n  var idx := 1;\n  while idx < |testStr| - 1\n    invariant 1 <= idx <= |testStr|\n    invariant res >= 0\n    decreases |testStr| - idx\n  {\n    if !(testStr[idx] in vowList) &&\n       ((testStr[idx - 1] in vowList) || (testStr[idx + 1] in vowList)) {\n      res := res + 1;\n    }\n    idx := idx + 1;\n  }\n  if !(testStr[0] in vowList) && (testStr[1] in vowList) {\n    res := res + 1;\n  }\n  if !(testStr[|testStr| - 1] in vowList) && (testStr[|testStr| - 2] in vowList) {\n    res := res + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 3.508,
        "duration_formatted": "3.51s",
        "tokens": {
          "input": 1419,
          "output": 253,
          "total": 1672
        },
        "cost_usd": 0.004862,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:54:45.238987"
      }
    },
    {
      "file_path": "program_483.py",
      "code": "def sum_range_list(list1, m, n):\n    sum_range = 0\n    i = m\n    while i < n + 1:\n        sum_range += list1[i]\n        i += 1\n    return sum_range",
      "program_specification": "```dafny\nmethod SumRangeList(list1: array<int>, m: int, n: int) returns (sumRange: int)\n  requires list1 != null\n  requires 0 <= m <= n < list1.Length\n  ensures sumRange == (if m > n then 0 else (sum i | m <= i <= n :: list1[i]))\n{\n  sumRange := 0;\n  var i := m;\n  while i <= n\n    invariant m <= i <= n + 1\n    invariant sumRange == (if i > n then 0 else (sum j | m <= j < i :: list1[j]))\n    decreases n - i + 1\n  {\n    sumRange := sumRange + list1[i];\n    i := i + 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 4.133,
        "duration_formatted": "4.13s",
        "tokens": {
          "input": 1316,
          "output": 170,
          "total": 1486
        },
        "cost_usd": 0.003992,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:54:54.407518"
      }
    },
    {
      "file_path": "program_485.py",
      "code": "def max_product(arr):\n    arr_len = len(arr)\n    if arr_len < 2:\n        return None\n    x = arr[0]\n    y = arr[1]\n    i = 0\n    while i < arr_len:\n        j = i + 1\n        while j < arr_len:\n            if arr[i] * arr[j] > x * y:\n                x = arr[i]\n                y = arr[j]\n            j += 1\n        i += 1\n    return (x, y)",
      "program_specification": "```dafny\nmethod MaxProduct(arr: array<int>) returns (res: (int, int)?)\n  requires arr != null\n  ensures (arr.Length < 2) ==> res == null\n  ensures (arr.Length >= 2) ==>\n    (res.Some? ==>\n      (exists i, j :: 0 <= i < j < arr.Length && res.v0 == arr[i] && res.v1 == arr[j]) &&\n      (forall i, j :: 0 <= i < j < arr.Length ==> res.v0 * res.v1 >= arr[i] * arr[j]))\n{\n  if arr.Length < 2 {\n    res := null;\n    return;\n  }\n  var x := arr[0];\n  var y := arr[1];\n  var i := 0;\n  while i < arr.Length\n    invariant 0 <= i <= arr.Length\n    invariant arr.Length >= 2\n    invariant exists a, b :: 0 <= a < b < arr.Length && x == arr[a] && y == arr[b]\n    invariant forall a, b :: 0 <= a < b < i ==> x * y >= arr[a] * arr[b]\n    decreases arr.Length - i\n  {\n    var j := i + 1;\n    while j < arr.Length\n      invariant i + 1 <= j <= arr.Length\n      invariant exists a, b :: 0 <= a < b < arr.Length && x == arr[a] && y == arr[b]\n      invariant forall a, b :: 0 <= a < b < arr.Length && (a < i || (a == i && b < j)) ==> x * y >= arr[a] * arr[b]\n      decreases arr.Length - j\n    {\n      if arr[i] * arr[j] > x * y {\n        x := arr[i];\n        y := arr[j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  res := (x, y);\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 8.212,
        "duration_formatted": "8.21s",
        "tokens": {
          "input": 1376,
          "output": 422,
          "total": 1798
        },
        "cost_usd": 0.006128,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:55:07.671320"
      }
    },
    {
      "file_path": "program_498.py",
      "code": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        i = gap\n        while i < len(my_list):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n            i += 1\n        gap //= 2\n    return my_list",
      "program_specification": "```dafny\nmethod ShellSort(arr: array<int>) returns (res: array<int>)\n  requires arr != null\n  ensures res != null\n  ensures res.Length == arr.Length\n  ensures multiset(res[..]) == multiset(arr[..])\n  ensures forall k: int :: 0 <= k < res.Length - 1 ==> res[k] <= res[k+1]\n{\n  var n := arr.Length;\n  // Copy arr to a new array to avoid modifying the input\n  res := new int[n];\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k: int :: 0 <= k < i ==> res[k] == arr[k]\n    decreases n - i\n  {\n    res[i] := arr[i];\n    i := i + 1;\n  }\n\n  var gap := n / 2;\n  while gap > 0\n    invariant 0 <= gap <= n/2\n    invariant res != null && res.Length == n\n    invariant multiset(res[..]) == multiset(arr[..])\n    decreases gap\n  {\n    var i := gap;\n    while i < n\n      invariant gap <= i <= n\n      invariant res != null && res.Length == n\n      invariant multiset(res[..]) == multiset(arr[..])\n      decreases n - i\n    {\n      var current := res[i];\n      var j := i;\n      while j >= gap && res[j - gap] > current\n        invariant gap <= j <= i\n        invariant res != null && res.Length == n\n        invariant multiset(res[..]) == multiset(arr[..])\n        decreases j\n      {\n        res[j] := res[j - gap];\n        j := j - gap;\n      }\n      res[j] := current;\n      i := i + 1;\n    }\n    gap := gap / 2;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "loop_exchange",
      "usage_stats": {
        "duration_seconds": 5.741,
        "duration_formatted": "5.74s",
        "tokens": {
          "input": 1375,
          "output": 399,
          "total": 1774
        },
        "cost_usd": 0.005942,
        "model": "gpt-4.1",
        "timestamp": "2025-10-24T15:55:18.444571"
      }
    }
  ]
}