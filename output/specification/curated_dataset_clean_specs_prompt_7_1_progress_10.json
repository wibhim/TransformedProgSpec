{
  "metadata": {
    "summary": {
      "total_programs": 9,
      "api_requests": 0,
      "cached_results": 9,
      "errors": 0,
      "success_rate": "100.0%"
    },
    "note": "Built from cache on 2025-08-15T14:57:56.782698",
    "cache_info": {
      "table": "transformed_specifications",
      "spec_type": "transformed",
      "first_cached": "2025-08-15T14:55:08.339107",
      "last_cached": "2025-08-15T14:57:56.740669"
    }
  },
  "specifications": [
    {
      "file_path": "1-100q/11.py",
      "code": "class Solution(object):\n\n    def maxArea(self, height):\n        left, right, maxArea = (0, len(height) - 1, 0)\n        while left < right:\n            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return maxArea",
      "program_specification": "```dafny\nmethod MaxArea(height: seq<int>) returns (maxArea: int)\n    requires |height| >= 2\n    ensures maxArea >= 0\n    ensures forall i: int, j: int :: 0 <= i < j < |height| ==> maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n{\n    var left: int := 0;\n    var right: int := |height| - 1;\n    maxArea := 0;\n\n    // Loop to find the maximum area\n    while left < right\n        invariant 0 <= left <= right < |height|\n        invariant maxArea >= 0\n        invariant forall i: int, j: int :: 0 <= i < j < |height| && (i < left || j > right) ==> maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n        decreases right - left\n    {\n        var hLeft := height[left];\n        var hRight := height[right];\n        var width := right - left;\n        var area := (if hLeft < hRight then hLeft else hRight) * width;\n        assert area >= 0;\n        if area > maxArea {\n            maxArea := area;\n        }\n        assert maxArea >= area;\n\n        if hLeft < hRight {\n            left := left + 1;\n        } else {\n            right := right - 1;\n        }\n    }\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:55:08.339107",
        "source": "cache"
      }
    },
    {
      "file_path": "1000-1100q/1027.py",
      "code": "class Solution(object):\n\n    def longestArithSeqLength(self, A):\n        from collections import defaultdict\n        dp = defaultdict(int)\n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[index_i, diff] = max(dp[index_i, diff], dp[index_j, diff] + 1)\n        return max(dp.itervalues()) + 1",
      "program_specification": "```dafny\nmethod LongestArithSeqLength(A: seq<int>) returns (result: int)\n    requires |A| >= 1\n    ensures result >= 1\n{\n    // We use a 2D map: dp[i][diff] = length of longest arithmetic subsequence ending at i with difference diff\n    var n := |A|;\n    var dp := new map<(int, int), int>;\n    var maxLen := 1;\n\n    var index_i: int := 0;\n    while index_i < n\n        invariant 0 <= index_i <= n\n        invariant maxLen >= 1\n        invariant forall i: int, d: int :: 0 <= i < index_i ==> dp[(i, d)] >= 0\n        decreases n - index_i\n    {\n        var index_j: int := 0;\n        while index_j < index_i\n            invariant 0 <= index_j <= index_i\n            invariant forall j: int, d: int :: 0 <= j < index_j ==> dp[(j, d)] >= 0\n            decreases index_i - index_j\n        {\n            var diff := A[index_i] - A[index_j];\n            var key_i := (index_i, diff);\n            var key_j := (index_j, diff);\n\n            var prevLen: int := 0;\n            if dp.Contains(key_j) {\n                prevLen := dp[key_j];\n            }\n            var curLen := if dp.Contains(key_i) then dp[key_i] else 0;\n            var newLen := if curLen > prevLen + 1 then curLen else prevLen + 1;\n            dp := dp[key_i := newLen];\n\n            if newLen > maxLen {\n                maxLen := newLen;\n            }\n\n            assert dp[key_i] >= 1;\n            index_j := index_j + 1;\n        }\n        index_i := index_i + 1;\n    }\n\n    result := maxLen;\n    assert result >= 1;\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:55:25.738280",
        "source": "cache"
      }
    },
    {
      "file_path": "1000-1100q/1052.py",
      "code": "class Solution(object):\n\n    def maxSatisfied(self, customers, grumpy, X):\n        result = 0\n        prefix_sum = [0] * (len(customers) + 1)\n        index = 0\n        for customer, grump in zip(customers, grumpy):\n            prefix_sum[index + 1] = prefix_sum[index]\n            if grump == 0:\n                result += customer\n            else:\n                prefix_sum[index + 1] += customer\n            index += 1\n        curr_max = result + prefix_sum[X]\n        for index in range(X + 1, len(prefix_sum)):\n            temp_max = result + prefix_sum[index] - prefix_sum[index - X]\n            curr_max = max(curr_max, temp_max)\n        return curr_max",
      "program_specification": "```dafny\nmethod MaxSatisfied(customers: seq<int>, grumpy: seq<int>, X: int) returns (curr_max: int)\n    requires |customers| == |grumpy|\n    requires X >= 0 && X <= |customers|\n    ensures curr_max >= 0\n    ensures curr_max <= sum(customers)\n{\n    var n := |customers|;\n    var result: int := 0;\n    var prefix_sum := new int[n + 1];\n    var index: int := 0;\n\n    // prefix_sum[0] is always 0\n    prefix_sum[0] := 0;\n\n    // Build prefix_sum and result\n    while index < n\n        invariant 0 <= index <= n\n        invariant prefix_sum[0] == 0\n        invariant forall i :: 0 <= i <= index ==> prefix_sum[i] >= 0\n        invariant result >= 0\n        invariant result <= sum(customers[..index])\n        decreases n - index\n    {\n        prefix_sum[index + 1] := prefix_sum[index];\n        if grumpy[index] == 0 {\n            result := result + customers[index];\n        } else {\n            prefix_sum[index + 1] := prefix_sum[index + 1] + customers[index];\n        }\n        index := index + 1;\n    }\n\n    // At this point, result is the sum of customers[i] where grumpy[i] == 0\n    // prefix_sum[i] is the sum of customers[j] for j in 0..i-1 where grumpy[j] == 1\n\n    // Initial curr_max: result + sum of first X grumpy customers\n    curr_max := result + prefix_sum[X];\n    assert curr_max >= result;\n    assert curr_max <= sum(customers);\n\n    index := X + 1;\n    while index <= n\n        invariant X + 1 <= index <= n + 1\n        invariant curr_max >= result\n        invariant curr_max <= sum(customers)\n        decreases n + 1 - index\n    {\n        var temp_max := result + prefix_sum[index] - prefix_sum[index - X];\n        assert temp_max >= result;\n        assert temp_max <= sum(customers);\n        if temp_max > curr_max {\n            curr_max := temp_max;\n        }\n        index := index + 1;\n    }\n}\n\n// Helper function for sum of a sequence\nfunction sum(s: seq<int>): int\n    decreases |s|\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:55:41.528491",
        "source": "cache"
      }
    },
    {
      "file_path": "1000-1100q/1065.py",
      "code": "class Solution(object):\n\n    def indexPairs(self, text, words):\n        if not words:\n            return []\n        result = []\n        for word in words:\n            starting = [index for index in range(len(text)) if text.startswith(word, index)]\n            for start in starting:\n                result.append([start, start + len(word) - 1])\n        result.sort()\n        return result",
      "program_specification": "```dafny\nmethod IndexPairs(text: seq<char>, words: seq<seq<char>>) returns (result: seq<seq<int>>)\n    ensures |result| >= 0\n    ensures forall pair :: pair in result ==> |pair| == 2\n    ensures forall pair :: pair in result ==> 0 <= pair[0] <= pair[1] < |text|\n    ensures forall pair :: pair in result ==>\n        exists word :: word in words && pair[0] + |word| - 1 == pair[1] &&\n            pair[0] + |word| <= |text| &&\n            text[pair[0] .. pair[0] + |word|] == word\n{\n    if |words| == 0 {\n        result := [];\n        return;\n    }\n\n    var res: seq<seq<int>> := [];\n    var i: int := 0;\n    // For each word in words\n    while i < |words|\n        invariant 0 <= i <= |words|\n        invariant |res| >= 0\n        invariant forall pair :: pair in res ==> |pair| == 2\n        invariant forall pair :: pair in res ==> 0 <= pair[0] <= pair[1] < |text|\n        invariant forall pair :: pair in res ==>\n            exists j :: 0 <= j < i && \n                words[j] in words &&\n                pair[0] + |words[j]| - 1 == pair[1] &&\n                pair[0] + |words[j]| <= |text| &&\n                text[pair[0] .. pair[0] + |words[j]|] == words[j]\n        decreases |words| - i\n    {\n        var word := words[i];\n        var starting: seq<int> := [];\n        var idx: int := 0;\n        // Find all start indices where text startswith word at idx\n        while idx <= |text| - |word|\n            invariant 0 <= idx <= |text|\n            invariant |starting| >= 0\n            invariant forall j :: 0 <= j < |starting| ==> 0 <= starting[j] <= |text| - |word|\n            invariant forall j :: 0 <= j < |starting| ==> text[starting[j] .. starting[j] + |word|] == word\n            decreases |text| - idx\n        {\n            if |word| <= |text| - idx && text[idx .. idx + |word|] == word {\n                starting := starting + [idx];\n            }\n            idx := idx + 1;\n        }\n        var j: int := 0;\n        // For each start index, append [start, start + |word| - 1] to res\n        while j < |starting|\n            invariant 0 <= j <= |starting|\n            invariant |res| >= 0\n            invariant forall pair :: pair in res ==> |pair| == 2\n            invariant forall pair :: pair in res ==> 0 <= pair[0] <= pair[1] < |text|\n            invariant forall pair :: pair in res ==>\n                exists k :: 0 <= k < i && \n                    words[k] in words &&\n                    pair[0] + |words[k]| - 1 == pair[1] &&\n                    pair[0] + |words[k]| <= |text| &&\n                    text[pair[0] .. pair[0] + |words[k]|] == words[k]\n                ||\n                (k == i && exists m :: 0 <= m < j && pair[0] == starting[m] && pair[1] == starting[m] + |word| - 1)\n            decreases |starting| - j\n        {\n            var start := starting[j];\n            assert 0 <= start <= |text| - |word|;\n            assert text[start .. start + |word|] == word;\n            res := res + [[start, start + |word| - 1]];\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n\n    // Sort the result\n    result := SortPairs(res);\n    assert |result| == |res|;\n    assert forall pair :: pair in result ==> |pair| == 2;\n}\n\nmethod SortPairs(pairs: seq<seq<int>>) returns (sorted: seq<seq<int>>)\n    requires forall pair :: pair in pairs ==> |pair| == 2\n    ensures |sorted| == |pairs|\n    ensures multiset(sorted) == multiset(pairs)\n    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i][0] <= sorted[j][0] || (sorted[i][0] == sorted[j][0] && sorted[i][1] <= sorted[j][1])\n{\n    // Simple insertion sort for pairs\n    var res := pairs[..];\n    var i: int := 1;\n    while i < |res|\n        invariant 1 <= i <= |res|\n        invariant |res| == |pairs|\n        invariant multiset(res) == multiset(pairs)\n        invariant forall k :: 1 <= k < i ==> res[k-1][0] <= res[k][0] || (res[k-1][0] == res[k][0] && res[k-1][1] <= res[k][1])\n        decreases |res| - i\n    {\n        var j := i;\n        while j > 0 && (res[j][0] < res[j-1][0] || (res[j][0] == res[j-1][0] && res[j][1] < res[j-1][1]))\n            invariant 0 <= j <= i\n            invariant |res| == |pairs|\n            invariant multiset(res) == multiset(pairs)\n            decreases j\n        {\n            var tmp := res[j-1];\n            res[j-1] := res[j];\n            res[j] := tmp;\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n    sorted := res;\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:56:15.034158",
        "source": "cache"
      }
    },
    {
      "file_path": "900-1000q/926.py",
      "code": "class Solution(object):\n\n    def minFlipsMonoIncr(self, S):\n        ones = [0]\n        for char in S:\n            ones.append(ones[-1] + int(char))\n        result = float('inf')\n        for index in range(len(ones)):\n            zeroes = len(S) - index - (ones[-1] - ones[index])\n            result = min(zeroes + ones[index], result)\n        return result",
      "program_specification": "```dafny\nmethod MinFlipsMonoIncr(S: seq<char>) returns (result: int)\n    requires forall c :: c in S ==> c == '0' || c == '1'\n    ensures result >= 0\n{\n    var n: int := |S|;\n    // ones[i] will be the number of '1's in S[..i)\n    var ones := new int[n + 1];\n    ones[0] := 0;\n\n    var i: int := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant ones[0] == 0\n        invariant forall j :: 0 <= j <= i ==> ones[j] == (if j == 0 then 0 else ones[j-1] + (if S[j-1] == '1' then 1 else 0))\n        decreases n - i\n    {\n        if S[i] == '1' {\n            ones[i+1] := ones[i] + 1;\n        } else {\n            ones[i+1] := ones[i];\n        }\n        assert ones[i+1] == ones[i] + (if S[i] == '1' then 1 else 0);\n        i := i + 1;\n    }\n    assert ones[n] == (if n == 0 then 0 else ones[n-1] + (if S[n-1] == '1' then 1 else 0));\n\n    // Now, ones[i] == number of '1's in S[..i)\n    var minResult: int := n + 1; // upper bound\n    var index: int := 0;\n    while index <= n\n        invariant 0 <= index <= n + 1\n        invariant minResult >= 0\n        decreases n + 1 - index\n    {\n        // zeroes = n - index - (ones[n] - ones[index])\n        var zeroes: int := n - index - (ones[n] - ones[index]);\n        assert zeroes + ones[index] >= 0;\n        var flips: int := zeroes + ones[index];\n        if flips < minResult {\n            minResult := flips;\n        }\n        index := index + 1;\n    }\n    result := minResult;\n    assert result >= 0;\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:56:41.057479",
        "source": "cache"
      }
    },
    {
      "file_path": "Python/4-keys-keyboard.py",
      "code": "class Solution(object):\n\n    def maxA(self, N):\n        if N < 7:\n            return N\n        if N == 10:\n            return 20\n        n = N // 5 + 1\n        n3 = 5 * n - N - 1\n        n4 = n - n3\n        return 3 ** n3 * 4 ** n4\n\nclass Solution2(object):\n\n    def maxA(self, N):\n        if N < 7:\n            return N\n        dp = range(N + 1)\n        for i in xrange(7, N + 1):\n            dp[i % 6] = max(dp[(i - 4) % 6] * 3, dp[(i - 5) % 6] * 4)\n        return dp[N % 6]",
      "program_specification": "```dafny\n// Dafny translation of Solution.maxA\n\nmethod MaxA(N: int) returns (result: int)\n    requires N >= 0\n    ensures result >= 0\n    ensures N < 7 ==> result == N\n{\n    if N < 7 {\n        result := N;\n        return;\n    }\n    if N == 10 {\n        result := 20;\n        return;\n    }\n    var n: int := N / 5 + 1;\n    assert n >= 1;\n    var n3: int := 5 * n - N - 1;\n    var n4: int := n - n3;\n    assert n3 >= 0 && n4 >= 0;\n    var pow3: int := 1;\n    var i: int := 0;\n    while i < n3\n        invariant 0 <= i <= n3\n        invariant pow3 == 3 ^ i\n        decreases n3 - i\n    {\n        pow3 := pow3 * 3;\n        i := i + 1;\n    }\n    var pow4: int := 1;\n    var j: int := 0;\n    while j < n4\n        invariant 0 <= j <= n4\n        invariant pow4 == 4 ^ j\n        decreases n4 - j\n    {\n        pow4 := pow4 * 4;\n        j := j + 1;\n    }\n    result := pow3 * pow4;\n}\n\n// Dafny translation of Solution2.maxA\n\nmethod MaxA2(N: int) returns (result: int)\n    requires N >= 0\n    ensures result >= 0\n    ensures N < 7 ==> result == N\n{\n    if N < 7 {\n        result := N;\n        return;\n    }\n    var dp: array<int> := new int[6];\n    var k: int := 0;\n    while k <= N && k < 6\n        invariant 0 <= k <= 6\n        invariant forall m :: 0 <= m < k ==> dp[m] == m\n        decreases 6 - k\n    {\n        dp[k] := k;\n        k := k + 1;\n    }\n    // If N < 6, already returned above\n    var i: int := 7;\n    while i <= N\n        invariant 7 <= i <= N + 1\n        invariant forall m :: 0 <= m < 6 ==> dp[m] >= 0\n        decreases N - i + 1\n    {\n        var idx4: int := (i - 4) % 6;\n        var idx5: int := (i - 5) % 6;\n        assert 0 <= idx4 < 6;\n        assert 0 <= idx5 < 6;\n        var cand1: int := dp[idx4] * 3;\n        var cand2: int := dp[idx5] * 4;\n        if cand1 > cand2 {\n            dp[i % 6] := cand1;\n        } else {\n            dp[i % 6] := cand2;\n        }\n        i := i + 1;\n    }\n    result := dp[N % 6];\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:56:59.351574",
        "source": "cache"
      }
    },
    {
      "file_path": "Python/adjacent-increasing-subarrays-detection-i.py",
      "code": "class Solution(object):\n\n    def hasIncreasingSubarrays(self, nums, k):\n        result = 0\n        curr, prev = (1, 0)\n        for i in xrange(len(nums) - 1):\n            if nums[i] < nums[i + 1]:\n                curr += 1\n            else:\n                prev = curr\n                curr = 1\n            result = max(result, curr // 2, min(prev, curr))\n        return result >= k",
      "program_specification": "```dafny\nmethod HasIncreasingSubarrays(nums: seq<int>, k: int) returns (res: bool)\n    requires k >= 0\n    ensures res ==> exists i, j :: 0 <= i < j <= |nums| && j - i >= 2 && forall m :: i <= m < j - 1 ==> nums[m] < nums[m + 1]\n    ensures res ==> k <= |nums|\n{\n    var n := |nums|;\n    var result: int := 0;\n    var curr: int := 1;\n    var prev: int := 0;\n    var i: int := 0;\n\n    while i < n - 1\n        invariant 0 <= i <= n - 1\n        invariant curr >= 1\n        invariant prev >= 0\n        invariant result >= 0\n        invariant forall j: int :: 0 <= j < i ==> nums[j] < nums[j+1] ==> curr >= 2\n        decreases n - 1 - i\n    {\n        if nums[i] < nums[i + 1] {\n            curr := curr + 1;\n        } else {\n            prev := curr;\n            curr := 1;\n        }\n        var max1 := curr / 2;\n        var min1 := if prev < curr then prev else curr;\n        var max2 := if result > max1 then result else max1;\n        result := if max2 > min1 then max2 else min1;\n\n        assert result >= 0;\n        i := i + 1;\n    }\n    res := result >= k;\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:57:14.257003",
        "source": "cache"
      }
    },
    {
      "file_path": "Python/adjacent-increasing-subarrays-detection-ii.py",
      "code": "class Solution(object):\n\n    def maxIncreasingSubarrays(self, nums):\n        result = 0\n        curr, prev = (1, 0)\n        for i in xrange(len(nums) - 1):\n            if nums[i] < nums[i + 1]:\n                curr += 1\n            else:\n                prev = curr\n                curr = 1\n            result = max(result, curr // 2, min(prev, curr))\n        return result",
      "program_specification": "```dafny\nmethod MaxIncreasingSubarrays(nums: seq<int>) returns (result: int)\n    requires |nums| >= 1\n    ensures result >= 0\n    ensures result <= |nums|\n{\n    var n: int := |nums|;\n    var curr: int := 1;\n    var prev: int := 0;\n    result := 0;\n\n    var i: int := 0;\n    while i < n - 1\n        invariant 0 <= i <= n - 1\n        invariant 1 <= curr <= i + 1\n        invariant 0 <= prev <= i\n        invariant result >= 0\n        invariant result <= i + 1\n        decreases n - 1 - i\n    {\n        if nums[i] < nums[i + 1] {\n            curr := curr + 1;\n        } else {\n            prev := curr;\n            curr := 1;\n        }\n        var max1 := curr / 2;\n        var minPrevCurr := if prev < curr then prev else curr;\n        var max2 := if max1 > minPrevCurr then max1 else minPrevCurr;\n        if result < max2 {\n            result := max2;\n        }\n        // Intermediate assertions for verification\n        assert curr >= 1;\n        assert prev >= 0;\n        assert result >= 0;\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:57:28.797574",
        "source": "cache"
      }
    },
    {
      "file_path": "Python/all-divisions-with-the-highest-score-of-a-binary-array.py",
      "code": "class Solution(object):\n\n    def maxScoreIndices(self, nums):\n        result = []\n        mx = zeros = 0\n        total = sum(nums)\n        for i in xrange(len(nums) + 1):\n            zeros += (nums[i - 1] if i else 0) == 0\n            if zeros + (total - (i - zeros)) > mx:\n                mx = zeros + (total - (i - zeros))\n                result = []\n            if zeros + (total - (i - zeros)) == mx:\n                result.append(i)\n        return result",
      "program_specification": "```dafny\nmethod MaxScoreIndices(nums: seq<int>) returns (result: seq<int>)\n    requires forall x :: 0 <= x < |nums| ==> nums[x] == 0 || nums[x] == 1\n    ensures 0 <= |result| <= |nums| + 1\n    ensures forall i :: 0 <= i < |result| ==> 0 <= result[i] <= |nums|\n    // Each index in result gives a split with maximal score\n    ensures forall i :: 0 <= i < |result| ==>\n        var idx := result[i];\n        MaxScoreAtIndex(nums, idx) == MaxScore(nums)\n    // All indices with maximal score are in result\n    ensures forall idx :: 0 <= idx <= |nums| && MaxScoreAtIndex(nums, idx) == MaxScore(nums) ==> idx in result\n{\n    var n := |nums|;\n    var total: int := 0;\n    // Compute total number of 1s\n    var j: int := 0;\n    while j < n\n        invariant 0 <= j <= n\n        invariant total == SumOnes(nums, 0, j)\n        decreases n - j\n    {\n        if nums[j] == 1 {\n            total := total + 1;\n        }\n        j := j + 1;\n    }\n    assert total == SumOnes(nums, 0, n);\n\n    var zeros: int := 0;\n    var mx: int := 0;\n    var res: seq<int> := [];\n    var i: int := 0;\n    while i <= n\n        invariant 0 <= i <= n + 1\n        invariant 0 <= zeros <= i\n        invariant |res| <= i + 1\n        invariant mx == MaxScoreSoFar(nums, total, i, zeros)\n        invariant forall k :: 0 <= k < |res| ==> 0 <= res[k] <= i\n        decreases n + 1 - i\n    {\n        if i > 0 {\n            if nums[i - 1] == 0 {\n                zeros := zeros + 1;\n            }\n        }\n        var ones_right := total - (i - zeros);\n        var score := zeros + ones_right;\n        assert score == MaxScoreAtIndex(nums, i);\n        if score > mx {\n            mx := score;\n            res := [];\n        }\n        if score == mx {\n            res := res + [i];\n        }\n        i := i + 1;\n    }\n    result := res;\n}\n\nfunction SumOnes(nums: seq<int>, lo: int, hi: int): int\n    requires 0 <= lo <= hi <= |nums|\n{\n    if lo == hi then 0 else (if nums[lo] == 1 then 1 else 0) + SumOnes(nums, lo + 1, hi)\n}\n\nfunction MaxScoreAtIndex(nums: seq<int>, idx: int): int\n    requires 0 <= idx <= |nums|\n{\n    var zeros_left := SumZeros(nums, 0, idx);\n    var ones_right := SumOnes(nums, idx, |nums|);\n    zeros_left + ones_right\n}\n\nfunction SumZeros(nums: seq<int>, lo: int, hi: int): int\n    requires 0 <= lo <= hi <= |nums|\n{\n    if lo == hi then 0 else (if nums[lo] == 0 then 1 else 0) + SumZeros(nums, lo + 1, hi)\n}\n\nfunction MaxScore(nums: seq<int>): int\n{\n    if |nums| == 0 then 0\n    else\n        var best := MaxScoreAtIndex(nums, 0);\n        MaxScoreHelper(nums, 1, best)\n}\n\nfunction MaxScoreHelper(nums: seq<int>, idx: int, best: int): int\n    requires 0 <= idx <= |nums|\n{\n    if idx == |nums| then best\n    else\n        var score := MaxScoreAtIndex(nums, idx);\n        MaxScoreHelper(nums, idx + 1, if score > best then score else best)\n}\n\nfunction MaxScoreSoFar(nums: seq<int>, total: int, upto: int, zeros: int): int\n    requires 0 <= upto <= |nums| + 1\n    requires 0 <= zeros <= upto\n{\n    if upto == 0 then 0\n    else\n        var maxSoFar := 0;\n        MaxScoreSoFarHelper(nums, total, upto, zeros, 0, 0, maxSoFar)\n}\n\nfunction MaxScoreSoFarHelper(nums: seq<int>, total: int, upto: int, zeros: int, i: int, currZeros: int, maxSoFar: int): int\n    requires 0 <= i <= upto\n    requires 0 <= currZeros <= i\n{\n    if i == upto then maxSoFar\n    else\n        var z := if i > 0 && nums[i - 1] == 0 then currZeros + 1 else currZeros;\n        var ones_right := total - (i - z);\n        var score := z + ones_right;\n        MaxScoreSoFarHelper(nums, total, upto, zeros, i + 1, z, if score > maxSoFar then score else maxSoFar)\n}\n```",
      "spec_type": "transformed",
      "usage_stats": {
        "model": "gpt-4.1",
        "temperature": 0.2,
        "timestamp": "2025-08-15T14:57:56.740669",
        "source": "cache"
      }
    }
  ]
}