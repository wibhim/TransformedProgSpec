{
  "metadata": {
    "summary": {
      "total_programs": 50,
      "api_requests": 50,
      "cached_results": 0,
      "errors": 0,
      "success_rate": "100.0%"
    },
    "timing": {
      "total_duration_seconds": 598.326,
      "total_duration_formatted": "9m 58.3s",
      "average_per_request_seconds": 11.967
    },
    "tokens": {
      "total": 57662,
      "input": 21319,
      "output": 36343,
      "average_per_request": 1153.2
    },
    "cost": {
      "total_usd": 0.333382,
      "average_per_request_usd": 0.006668,
      "cost_per_token_usd": 5.78e-06
    },
    "model": "gpt-4.1",
    "generation_timestamp": "2025-08-15T11:42:58.547492"
  },
  "specifications": [
    {
      "file_path": "1-100q/11.py",
      "code": "class Solution(object):\n\n    def maxArea(self, height):\n        left, right, maxArea = (0, len(height) - 1, 0)\n        while left < right:\n            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return maxArea",
      "program_specification": "```dafny\nmethod MaxArea(height: seq<int>) returns (maxArea: int)\n    requires |height| >= 2\n    requires forall h :: 0 <= h < |height| ==> height[h] >= 0\n    ensures maxArea >= 0\n    ensures forall i, j :: 0 <= i < j < |height| ==>\n        maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n    ensures exists i, j :: 0 <= i < j < |height| &&\n        maxArea == (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n{\n    var left := 0;\n    var right := |height| - 1;\n    maxArea := 0;\n\n    while left < right\n        invariant 0 <= left <= right < |height|\n        invariant maxArea >= 0\n        invariant forall i, j :: 0 <= i < j < |height| && (i < left || j > right) ==>\n            maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n    {\n        var hLeft := height[left];\n        var hRight := height[right];\n        var area := (if hLeft < hRight then hLeft else hRight) * (right - left);\n        if area > maxArea {\n            maxArea := area;\n        }\n        if hLeft < hRight {\n            left := left + 1;\n        } else {\n            right := right - 1;\n        }\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 5.425,
        "duration_formatted": "5.42s",
        "tokens": {
          "input": 362,
          "output": 347,
          "total": 709
        },
        "cost_usd": 0.0035,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:24:45.443389"
      }
    },
    {
      "file_path": "1000-1100q/1027.py",
      "code": "class Solution(object):\n\n    def longestArithSeqLength(self, A):\n        from collections import defaultdict\n        dp = defaultdict(int)\n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[index_i, diff] = max(dp[index_i, diff], dp[index_j, diff] + 1)\n        return max(dp.itervalues()) + 1",
      "program_specification": "```dafny\nmethod LongestArithSeqLength(A: array<int>) returns (result: int)\n    requires A != null\n    ensures result >= 1 ==> |A| > 0\n    ensures |A| == 0 ==> result == 0\n    ensures |A| == 1 ==> result == 1\n    // For any non-empty array, result is the length of the longest arithmetic subsequence in A\n{\n    if |A| == 0 {\n        result := 0;\n        return;\n    }\n    var n := |A|;\n    // We use a map to simulate dp[(i, diff)] = length of longest arithmetic subsequence ending at i with difference diff\n    var dp := map<(int, int), int>{};\n    var maxLen := 1;\n\n    var i: int := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant maxLen >= 1\n        invariant forall k: int, d: int :: (k, d) in dp ==> 1 <= dp[(k, d)] <= k + 1\n    {\n        var j: int := 0;\n        while j < i\n            invariant 0 <= j <= i\n            invariant forall k: int, d: int :: (k, d) in dp ==> 1 <= dp[(k, d)] <= k + 1\n        {\n            var diff := A[i] - A[j];\n            var prevLen := if (j, diff) in dp then dp[(j, diff)] else 1;\n            var currLen := if (i, diff) in dp then dp[(i, diff)] else 1;\n            if prevLen + 1 > currLen {\n                dp := dp[(i, diff) := prevLen + 1];\n                if prevLen + 1 > maxLen {\n                    maxLen := prevLen + 1;\n                }\n            } else if currLen > maxLen {\n                maxLen := currLen;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    result := maxLen;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 5.684,
        "duration_formatted": "5.68s",
        "tokens": {
          "input": 367,
          "output": 452,
          "total": 819
        },
        "cost_usd": 0.00435,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:25:01.133191"
      }
    },
    {
      "file_path": "1000-1100q/1028.py",
      "code": "class Solution(object):\n\n    def longestArithSeqLength(self, A):\n        from collections import defaultdict\n        dp = defaultdict(int)\n        for index_i in range(len(A)):\n            for index_j in range(index_i):\n                diff = A[index_i] - A[index_j]\n                dp[index_i, diff] = max(dp[index_i, diff], dp[index_j, diff] + 1)\n        return max(dp.itervalues()) + 1",
      "program_specification": "```dafny\nmethod LongestArithSeqLength(A: array<int>) returns (result: int)\n    requires A != null\n    ensures result >= 1 ==> |A| > 0\n    ensures |A| == 0 ==> result == 0\n    ensures |A| == 1 ==> result == 1\n    // result is the length of the longest arithmetic subsequence in A\n{\n    if |A| == 0 {\n        result := 0;\n        return;\n    }\n    var n := |A|;\n    // dp[i][diff] = length of longest arithmetic subsequence ending at index i with difference diff\n    // We'll use a sequence of maps to simulate the defaultdict in Python\n    var dp := new map<int, map<int, int>>[n];\n    var i: int := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant dp.Length == n\n        invariant forall k :: 0 <= k < i ==> dp[k] != null\n        invariant forall k :: i <= k < n ==> dp[k] == null\n    {\n        dp[i] := map[];\n        i := i + 1;\n    }\n\n    var maxLen: int := 1;\n    i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant maxLen >= 1\n        invariant forall k :: 0 <= k < n ==> dp[k] != null\n    {\n        var j: int := 0;\n        while j < i\n            invariant 0 <= j <= i\n            invariant forall k :: 0 <= k < n ==> dp[k] != null\n            invariant maxLen >= 1\n        {\n            var diff := A[i] - A[j];\n            var prevLen := if diff in dp[j] then dp[j][diff] else 1;\n            var currLen := if diff in dp[i] then dp[i][diff] else 1;\n            var newLen := if prevLen + 1 > currLen then prevLen + 1 else currLen;\n            dp[i] := dp[i][diff := newLen];\n            if newLen > maxLen {\n                maxLen := newLen;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n\n    result := maxLen;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 8.567,
        "duration_formatted": "8.57s",
        "tokens": {
          "input": 367,
          "output": 497,
          "total": 864
        },
        "cost_usd": 0.00471,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:25:19.705136"
      }
    },
    {
      "file_path": "1000-1100q/1052.py",
      "code": "class Solution(object):\n\n    def maxSatisfied(self, customers, grumpy, X):\n        result = 0\n        prefix_sum = [0] * (len(customers) + 1)\n        index = 0\n        for customer, grump in zip(customers, grumpy):\n            prefix_sum[index + 1] = prefix_sum[index]\n            if grump == 0:\n                result += customer\n            else:\n                prefix_sum[index + 1] += customer\n            index += 1\n        curr_max = result + prefix_sum[X]\n        for index in range(X + 1, len(prefix_sum)):\n            temp_max = result + prefix_sum[index] - prefix_sum[index - X]\n            curr_max = max(curr_max, temp_max)\n        return curr_max",
      "program_specification": "```dafny\nmethod MaxSatisfied(customers: seq<int>, grumpy: seq<int>, X: int) returns (curr_max: int)\n    requires |customers| == |grumpy|\n    requires X >= 0 && X <= |customers|\n    requires forall c :: 0 <= c < |customers| ==> customers[c] >= 0\n    requires forall g :: 0 <= g < |grumpy| ==> grumpy[g] == 0 || grumpy[g] == 1\n    ensures curr_max >= 0\n    ensures curr_max <= sum(customers)\n    ensures\n        exists i: int :: 0 <= i <= |customers| - X ==>\n            curr_max == (\n                sum({j: int | 0 <= j < |customers| && grumpy[j] == 0} customers[j]) +\n                sum({j: int | i <= j < i+X && grumpy[j] == 1} customers[j])\n            )\n{\n    var n := |customers|;\n    var result := 0;\n    var prefix_sum := new int[n + 1];\n    var index := 0;\n\n    // prefix_sum[0] == 0\n    prefix_sum[0] := 0;\n\n    // Loop to build prefix_sum and compute result\n    while index < n\n        invariant 0 <= index <= n\n        invariant prefix_sum[0] == 0\n        invariant forall k :: 0 <= k <= index ==>\n            prefix_sum[k] ==\n                sum({j: int | 0 <= j < k && grumpy[j] == 1} customers[j])\n        invariant result ==\n            sum({j: int | 0 <= j < index && grumpy[j] == 0} customers[j])\n    {\n        prefix_sum[index + 1] := prefix_sum[index];\n        if grumpy[index] == 0 {\n            result := result + customers[index];\n        } else {\n            prefix_sum[index + 1] := prefix_sum[index + 1] + customers[index];\n        }\n        index := index + 1;\n    }\n\n    curr_max := result + prefix_sum[X];\n\n    var idx := X + 1;\n    while idx <= n\n        invariant X + 1 <= idx <= n + 1\n        invariant curr_max >= result + prefix_sum[X]\n        invariant forall k :: X + 1 <= k < idx ==>\n            curr_max >= result + prefix_sum[k] - prefix_sum[k - X]\n    {\n        var temp_max := result + prefix_sum[idx] - prefix_sum[idx - X];\n        if temp_max > curr_max {\n            curr_max := temp_max;\n        }\n        idx := idx + 1;\n    }\n}\n\n// Helper function to sum elements of a sequence\nfunction sum(s: seq<int>): int\n    decreases |s|\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\n// Helper function to sum elements of a sequence at given indices\nfunction sum(indices: set<int>, f: int -> int): int\n    decreases |indices|\n{\n    if |indices| == 0 then 0 else\n        var i: int :| i in indices;\n        f(i) + sum(indices - {i}, f)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 10.565,
        "duration_formatted": "10.56s",
        "tokens": {
          "input": 436,
          "output": 687,
          "total": 1123
        },
        "cost_usd": 0.006368,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:25:40.271523"
      }
    },
    {
      "file_path": "1000-1100q/1065.py",
      "code": "class Solution(object):\n\n    def indexPairs(self, text, words):\n        if not words:\n            return []\n        result = []\n        for word in words:\n            starting = [index for index in range(len(text)) if text.startswith(word, index)]\n            for start in starting:\n                result.append([start, start + len(word) - 1])\n        result.sort()\n        return result",
      "program_specification": "```dafny\nmethod IndexPairs(text: string, words: seq<string>) returns (result: seq<seq<int>>)\n    requires text != null\n    requires forall w :: w in words ==> w != null\n    ensures\n        |words| == 0 ==> result == []\n    ensures\n        |words| > 0 ==>\n            result == \n                (flatten(\n                    [word := words[i] | i :: 0 <= i < |words|] \n                        ( [ [start, start + |word| - 1] | start :: 0 <= start < |text| && text[start..][..|word|] == word && |text| - start >= |word| ] )\n                ) ).Sorted()\n    ensures\n        forall pair :: pair in result ==>\n            |pair| == 2 &&\n            0 <= pair[0] <= pair[1] < |text| &&\n            exists word :: word in words && |word| == pair[1] - pair[0] + 1 && text[pair[0]..pair[1]+1] == word\n    decreases text, words\n{\n    if |words| == 0 {\n        result := [];\n        return;\n    }\n    var res := new List<seq<int>>();\n    var i: int := 0;\n    while i < |words|\n        invariant 0 <= i <= |words|\n        invariant res == flatten(\n            [word := words[j] | j :: 0 <= j < i] \n                ( [ [start, start + |word| - 1] | start :: 0 <= start < |text| && |text| - start >= |word| && text[start..][..|word|] == word ] )\n        )\n    {\n        var word := words[i];\n        var starting := new List<int>();\n        var idx: int := 0;\n        while idx < |text|\n            invariant 0 <= idx <= |text|\n            invariant starting == [start | start :: 0 <= start < idx && |text| - start >= |word| && text[start..][..|word|] == word]\n        {\n            if |text| - idx >= |word| && text[idx..][..|word|] == word {\n                starting.Add(idx);\n            }\n            idx := idx + 1;\n        }\n        var j: int := 0;\n        while j < starting.Count\n            invariant 0 <= j <= starting.Count\n            invariant forall k :: 0 <= k < j ==> res[res.Count - starting.Count + k] == [starting[k], starting[k] + |word| - 1]\n        {\n            res.Add([starting[j], starting[j] + |word| - 1]);\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    // Sort result lexicographically\n    result := res.ToArray();\n    result := SortPairs(result);\n}\n\n// Helper to flatten a sequence of sequences\nfunction flatten<T>(xss: seq<seq<T>>): seq<T>\n{\n    if |xss| == 0 then [] else xss[0] + flatten(xss[1..])\n}\n\n// Helper to sort pairs lexicographically\nmethod SortPairs(pairs: seq<seq<int>>) returns (sorted: seq<seq<int>>)\n    requires forall p :: p in pairs ==> |p| == 2\n    ensures sorted == pairs[..].Sorted()\n    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n{\n    var arr := pairs[..];\n    var n := |arr|;\n    var i: int := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant arr.Permutation(pairs)\n        invariant forall k :: 0 <= k < i ==> forall l :: k < l < n ==> arr[k] <= arr[l]\n    {\n        var minIdx := i;\n        var j: int := i + 1;\n        while j < n\n            invariant i + 1 <= j <= n\n            invariant i <= minIdx < n\n            invariant forall l :: i + 1 <= l < j ==> arr[minIdx] <= arr[l]\n        {\n            if arr[j][0] < arr[minIdx][0] || (arr[j][0] == arr[minIdx][0] && arr[j][1] < arr[minIdx][1]) {\n                minIdx := j;\n            }\n            j := j + 1;\n        }\n        if minIdx != i {\n            var tmp := arr[i];\n            arr[i] := arr[minIdx];\n            arr[minIdx] := tmp;\n        }\n        i := i + 1;\n    }\n    sorted := arr;\n}\n\n// Lexicographical comparison for seq<int> of length 2\nfunction method (a: seq<int>) <= (b: seq<int>): bool\n    requires |a| == 2 && |b| == 2\n{\n    a[0] < b[0] || (a[0] == b[0] && a[1] <= b[1])\n}\n\n// Permutation helper for sorting invariant\npredicate {:autocontracts} (a: seq<seq<int>>).Permutation(b: seq<seq<int>>)\n{\n    multiset a == multiset b\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 18.595,
        "duration_formatted": "18.60s",
        "tokens": {
          "input": 353,
          "output": 1129,
          "total": 1482
        },
        "cost_usd": 0.009738,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:26:08.867711"
      }
    },
    {
      "file_path": "900-1000q/926.py",
      "code": "class Solution(object):\n\n    def minFlipsMonoIncr(self, S):\n        ones = [0]\n        for char in S:\n            ones.append(ones[-1] + int(char))\n        result = float('inf')\n        for index in range(len(ones)):\n            zeroes = len(S) - index - (ones[-1] - ones[index])\n            result = min(zeroes + ones[index], result)\n        return result",
      "program_specification": "```dafny\nmethod MinFlipsMonoIncr(S: seq<char>) returns (result: int)\n    requires forall c :: c in S ==> c == '0' || c == '1'\n    ensures 0 <= result <= |S|\n    ensures forall i :: 0 <= i <= |S| ==>\n        result <= (NumOnes(S, i) + NumZeroes(S, i, |S|))\n    ensures exists i :: 0 <= i <= |S| &&\n        result == (NumOnes(S, i) + NumZeroes(S, i, |S|))\n{\n    var n := |S|;\n    var ones := new int[n + 1];\n    ones[0] := 0;\n\n    // Build prefix sum of ones\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant ones[0] == 0\n        invariant forall j :: 0 <= j <= i ==> ones[j] == NumOnes(S, j)\n    {\n        ones[i + 1] := ones[i] + (if S[i] == '1' then 1 else 0);\n        i := i + 1;\n    }\n\n    result := n + 1; // larger than any possible answer\n\n    var index := 0;\n    while index <= n\n        invariant 0 <= index <= n + 1\n        invariant result >= 0\n        invariant forall k :: 0 <= k < index ==>\n            result <= (ones[k] + (n - k - (ones[n] - ones[k])))\n    {\n        var zeroes := n - index - (ones[n] - ones[index]);\n        var flips := ones[index] + zeroes;\n        if flips < result {\n            result := flips;\n        }\n        index := index + 1;\n    }\n}\n\n// Helper function: number of '1's in S[0..i-1]\nfunction NumOnes(S: seq<char>, i: int): int\n    requires 0 <= i <= |S|\n{\n    if i == 0 then 0\n    else NumOnes(S, i - 1) + (if S[i - 1] == '1' then 1 else 0)\n}\n\n// Helper function: number of '0's in S[i..j-1]\nfunction NumZeroes(S: seq<char>, i: int, j: int): int\n    requires 0 <= i <= j <= |S|\n{\n    if i == j then 0\n    else (if S[i] == '0' then 1 else 0) + NumZeroes(S, i + 1, j)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.884,
        "duration_formatted": "7.88s",
        "tokens": {
          "input": 365,
          "output": 569,
          "total": 934
        },
        "cost_usd": 0.005282,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:26:26.757196"
      }
    },
    {
      "file_path": "Python/4-keys-keyboard.py",
      "code": "class Solution(object):\n\n    def maxA(self, N):\n        if N < 7:\n            return N\n        if N == 10:\n            return 20\n        n = N // 5 + 1\n        n3 = 5 * n - N - 1\n        n4 = n - n3\n        return 3 ** n3 * 4 ** n4\n\nclass Solution2(object):\n\n    def maxA(self, N):\n        if N < 7:\n            return N\n        dp = range(N + 1)\n        for i in xrange(7, N + 1):\n            dp[i % 6] = max(dp[(i - 4) % 6] * 3, dp[(i - 5) % 6] * 4)\n        return dp[N % 6]",
      "program_specification": "```dafny\n// Solution 1: Mathematical approach\nmethod MaxA1(N: int) returns (result: int)\n    requires N >= 0\n    ensures (N < 7 ==> result == N)\n    ensures (N == 10 ==> result == 20)\n    ensures (N < 7 || N == 10 || result == Power(3, 5 * ((N div 5) + 1) - N - 1) * Power(4, ((N div 5) + 1) - (5 * ((N div 5) + 1) - N - 1)))\n{\n    if N < 7 {\n        result := N;\n        return;\n    }\n    if N == 10 {\n        result := 20;\n        return;\n    }\n    var n := N / 5 + 1;\n    var n3 := 5 * n - N - 1;\n    var n4 := n - n3;\n    result := Power(3, n3) * Power(4, n4);\n}\n\n// Helper function for exponentiation\nfunction Power(base: int, exp: int): int\n    requires exp >= 0\n    decreases exp\n{\n    if exp == 0 then 1 else base * Power(base, exp - 1)\n}\n\n// Solution 2: Dynamic Programming approach\nmethod MaxA2(N: int) returns (result: int)\n    requires N >= 0\n    ensures (N < 7 ==> result == N)\n    ensures forall n :: 0 <= n <= N < 7 ==> MaxA2(n) == n\n    ensures forall n :: n == 10 ==> MaxA2(n) == 20\n    // For N >= 7, result is the maximum number of 'A's that can be printed in N key presses\n{\n    if N < 7 {\n        result := N;\n        return;\n    }\n    var dp: array<int> := new int[6];\n    var i: int := 0;\n    // Initialize dp[0..5] = 0..5\n    while i <= 5\n        invariant 0 <= i <= 6\n        invariant forall j :: 0 <= j < i ==> dp[j] == j\n    {\n        dp[i] := i;\n        i := i + 1;\n    }\n    i := 7;\n    while i <= N\n        invariant 7 <= i <= N + 1\n        invariant forall j :: 0 <= j < 6 ==> dp[j] >= 0\n        decreases N - i + 1\n    {\n        var val1 := dp[(i - 4) % 6] * 3;\n        var val2 := dp[(i - 5) % 6] * 4;\n        dp[i % 6] := if val1 > val2 then val1 else val2;\n        i := i + 1;\n    }\n    result := dp[N % 6];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 11.157,
        "duration_formatted": "11.16s",
        "tokens": {
          "input": 449,
          "output": 629,
          "total": 1078
        },
        "cost_usd": 0.00593,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:26:47.917113"
      }
    },
    {
      "file_path": "Python/adjacent-increasing-subarrays-detection-i.py",
      "code": "class Solution(object):\n\n    def hasIncreasingSubarrays(self, nums, k):\n        result = 0\n        curr, prev = (1, 0)\n        for i in xrange(len(nums) - 1):\n            if nums[i] < nums[i + 1]:\n                curr += 1\n            else:\n                prev = curr\n                curr = 1\n            result = max(result, curr // 2, min(prev, curr))\n        return result >= k",
      "program_specification": "```dafny\nmethod HasIncreasingSubarrays(nums: seq<int>, k: int) returns (res: bool)\n    requires k >= 0\n    ensures res == (exists i, j :: 0 <= i < j <= |nums| && IsIncreasing(nums[i..j]) && (j - i) >= 2 && MaxIncreasingSubarrayScore(nums) >= k)\n{\n    var result := 0;\n    var curr := 1;\n    var prev := 0;\n    var i := 0;\n    while i < |nums| - 1\n        invariant 0 <= i <= |nums| - 1\n        invariant curr >= 1\n        invariant prev >= 0\n        invariant result >= 0\n        invariant forall t: int :: 0 <= t < i ==> (nums[t] < nums[t+1] ==> true)\n        invariant result <= MaxIncreasingSubarrayScore(nums[..i+1])\n    {\n        if nums[i] < nums[i + 1] {\n            curr := curr + 1;\n        } else {\n            prev := curr;\n            curr := 1;\n        }\n        result := max(result, curr / 2, if prev < curr then prev else curr);\n        i := i + 1;\n    }\n    res := result >= k;\n}\n\nfunction method IsIncreasing(s: seq<int>): bool\n    decreases s\n{\n    |s| >= 2 && (forall i :: 0 <= i < |s| - 1 ==> s[i] < s[i+1])\n}\n\nfunction method MaxIncreasingSubarrayScore(nums: seq<int>): int\n    decreases nums\n{\n    if |nums| < 2 then 0\n    else\n        var maxScore := 0;\n        var curr := 1;\n        var prev := 0;\n        var i := 0;\n        while i < |nums| - 1\n            decreases |nums| - 1 - i\n        {\n            if nums[i] < nums[i + 1] {\n                curr := curr + 1;\n            } else {\n                prev := curr;\n                curr := 1;\n            }\n            maxScore := if maxScore > curr / 2 then maxScore else curr / 2;\n            maxScore := if maxScore > (if prev < curr then prev else curr) then maxScore else (if prev < curr then prev else curr);\n            i := i + 1;\n        }\n        maxScore\n}\n\nfunction method max(a: int, b: int, c: int): int\n{\n    if a >= b && a >= c then a\n    else if b >= a && b >= c then b\n    else c\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.927,
        "duration_formatted": "7.93s",
        "tokens": {
          "input": 372,
          "output": 566,
          "total": 938
        },
        "cost_usd": 0.005272,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:27:05.847646"
      }
    },
    {
      "file_path": "Python/adjacent-increasing-subarrays-detection-ii.py",
      "code": "class Solution(object):\n\n    def maxIncreasingSubarrays(self, nums):\n        result = 0\n        curr, prev = (1, 0)\n        for i in xrange(len(nums) - 1):\n            if nums[i] < nums[i + 1]:\n                curr += 1\n            else:\n                prev = curr\n                curr = 1\n            result = max(result, curr // 2, min(prev, curr))\n        return result",
      "program_specification": "```dafny\nmethod MaxIncreasingSubarrays(nums: seq<int>) returns (result: int)\n    requires |nums| >= 1\n    ensures result >= 0\n    // result is the maximum value of max(curr // 2, min(prev, curr)) over all positions in nums\n    ensures forall i: int, j: int :: \n        0 <= i < |nums| && 0 <= j < |nums| ==>\n            result >= \n                if i == 0 then 0\n                else\n                    var curr := 1 + (if nums[i-1] < nums[i] then 1 else 0);\n                    var prev := if i == 0 then 0 else curr;\n                    max(curr / 2, if i == 0 then 0 else min(prev, curr))\n{\n    var n := |nums|;\n    result := 0;\n    var curr := 1;\n    var prev := 0;\n    var i: int := 0;\n    while i < n - 1\n        invariant 0 <= i <= n - 1\n        invariant curr >= 1\n        invariant prev >= 0\n        invariant result >= 0\n        invariant forall k: int :: 0 <= k < i ==> \n            result >= \n                max(\n                    (if nums[k] < nums[k+1] then curr + 1 else 1) / 2,\n                    min(prev, curr)\n                )\n    {\n        if nums[i] < nums[i + 1] {\n            curr := curr + 1;\n        } else {\n            prev := curr;\n            curr := 1;\n        }\n        result := max(result, curr / 2, min(prev, curr));\n        i := i + 1;\n    }\n}\n\nfunction max(a: int, b: int, c: int): int\n    ensures max(a, b, c) == if a >= b && a >= c then a else if b >= c then b else c\n{\n    if a >= b && a >= c then a else if b >= c then b else c\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 6.475,
        "duration_formatted": "6.48s",
        "tokens": {
          "input": 368,
          "output": 442,
          "total": 810
        },
        "cost_usd": 0.004272,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:27:22.323722"
      }
    },
    {
      "file_path": "Python/all-divisions-with-the-highest-score-of-a-binary-array.py",
      "code": "class Solution(object):\n\n    def maxScoreIndices(self, nums):\n        result = []\n        mx = zeros = 0\n        total = sum(nums)\n        for i in xrange(len(nums) + 1):\n            zeros += (nums[i - 1] if i else 0) == 0\n            if zeros + (total - (i - zeros)) > mx:\n                mx = zeros + (total - (i - zeros))\n                result = []\n            if zeros + (total - (i - zeros)) == mx:\n                result.append(i)\n        return result",
      "program_specification": "```dafny\nmethod MaxScoreIndices(nums: seq<int>) returns (result: seq<int>)\n    requires forall x :: 0 <= x < |nums| ==> nums[x] == 0 || nums[x] == 1\n    ensures forall i :: 0 <= i < |result| ==> 0 <= result[i] <= |nums|\n    ensures forall i :: 0 <= i < |result| ==>\n                MaxScoreAt(nums, result[i]) == MaxScore(nums)\n    ensures forall k :: 0 <= k <= |nums| && MaxScoreAt(nums, k) == MaxScore(nums) ==>\n                exists j :: 0 <= j < |result| && result[j] == k\n{\n    var n := |nums|;\n    var total := Sum(nums);\n    var zeros := 0;\n    var mx := 0;\n    var res := new seq<int>[];\n\n    var i := 0;\n    while i <= n\n        invariant 0 <= i <= n + 1\n        invariant 0 <= zeros <= i\n        invariant mx == if |res| == 0 then 0 else MaxScore(nums)\n        invariant forall j :: 0 <= j < |res| ==> 0 <= res[j] <= n\n        invariant forall j :: 0 <= j < |res| ==> MaxScoreAt(nums, res[j]) == mx\n        invariant forall k :: 0 <= k < i ==> MaxScoreAt(nums, k) <= mx\n        decreases n - i\n    {\n        var prev := if i == 0 then 0 else nums[i - 1];\n        if prev == 0 && i != 0 {\n            zeros := zeros + 1;\n        }\n        var ones_right := total - (i - zeros);\n        var score := zeros + ones_right;\n        if score > mx {\n            mx := score;\n            res := [];\n        }\n        if score == mx {\n            res := res + [i];\n        }\n        i := i + 1;\n    }\n    result := res;\n}\n\nfunction method Sum(nums: seq<int>): int\n    decreases |nums|\n{\n    if |nums| == 0 then 0 else nums[0] + Sum(nums[1..])\n}\n\nfunction method MaxScoreAt(nums: seq<int>, i: int): int\n    requires 0 <= i <= |nums|\n{\n    NumZeros(nums[..i]) + NumOnes(nums[i..])\n}\n\nfunction method NumZeros(s: seq<int>): int\n{\n    if |s| == 0 then 0 else (if s[0] == 0 then 1 else 0) + NumZeros(s[1..])\n}\n\nfunction method NumOnes(s: seq<int>): int\n{\n    if |s| == 0 then 0 else (if s[0] == 1 then 1 else 0) + NumOnes(s[1..])\n}\n\nfunction method MaxScore(nums: seq<int>): int\n{\n    if |nums| == 0 then 0\n    else max({ MaxScoreAt(nums, i) | i in 0..|nums| })\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 12.093,
        "duration_formatted": "12.09s",
        "tokens": {
          "input": 392,
          "output": 658,
          "total": 1050
        },
        "cost_usd": 0.006048,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:27:44.420562"
      }
    },
    {
      "file_path": "Python/all-paths-from-source-to-target.py",
      "code": "class Solution(object):\n\n    def allPathsSourceTarget(self, graph):\n\n        def dfs(graph, curr, path, result):\n            if curr == len(graph) - 1:\n                result.append(path[:])\n                return\n            for node in graph[curr]:\n                path.append(node)\n                dfs(graph, node, path, result)\n                path.pop()\n        result = []\n        dfs(graph, 0, [0], result)\n        return result",
      "program_specification": "```dafny\nmodule SolutionModule {\n\n  method AllPathsSourceTarget(graph: seq<seq<int>>) returns (result: seq<seq<int>>)\n    requires |graph| > 0\n    requires forall i :: 0 <= i < |graph| ==> forall j :: 0 <= j < |graph[i]| ==> 0 <= graph[i][j] < |graph|\n    ensures forall path :: path in result ==> path[0] == 0 && path[|path|-1] == |graph|-1\n    ensures forall path :: path in result ==> \n                (forall k :: 0 <= k < |path|-1 ==> path[k+1] in graph[path[k]])\n    ensures forall path :: path in result ==> path.Length >= 2\n    ensures forall path :: path in result ==> path.Length <= |graph|\n    ensures result == AllPaths(graph)\n  {\n    var res := new seq<seq<int>>[];\n    var path := new seq<int>[];\n    path := path + [0];\n    dfs(graph, 0, path, res);\n    result := res[..];\n  }\n\n  method dfs(graph: seq<seq<int>>, curr: int, path: seq<int>, result: seq<seq<int>>)\n    requires 0 <= curr < |graph|\n    requires path[|path|-1] == curr\n    requires |graph| > 0\n    requires forall i :: 0 <= i < |graph| ==> forall j :: 0 <= j < |graph[i]| ==> 0 <= graph[i][j] < |graph|\n    modifies result\n    ensures \n      (curr == |graph|-1 ==> result[|result|-1] == path)\n    ensures\n      (curr == |graph|-1 ==> \n        forall k :: 0 <= k < |path|-1 ==> path[k+1] in graph[path[k]])\n    ensures\n      (curr == |graph|-1 ==> path[0] == 0 && path[|path|-1] == |graph|-1)\n    ensures\n      (curr == |graph|-1 ==> path.Length >= 2 && path.Length <= |graph|)\n    decreases |graph| - curr\n  {\n    if curr == |graph| - 1 {\n      result := result + [path];\n      return;\n    }\n    var i: int := 0;\n    while i < |graph[curr]|\n      invariant 0 <= i <= |graph[curr]|\n      invariant forall j :: 0 <= j < i ==> \n        (let node := graph[curr][j] in\n          true // no side effect, just for structure\n        )\n      modifies result\n    {\n      var node := graph[curr][i];\n      var newPath := path + [node];\n      dfs(graph, node, newPath, result);\n      i := i + 1;\n    }\n  }\n\n  function AllPaths(graph: seq<seq<int>>): seq<seq<int>>\n    requires |graph| > 0\n    requires forall i :: 0 <= i < |graph| ==> forall j :: 0 <= j < |graph[i]| ==> 0 <= graph[i][j] < |graph|\n    reads graph\n  {\n    set paths | \n      paths in AllPathsFromTo(graph, 0, |graph|-1)\n    }\n  \n  function AllPathsFromTo(graph: seq<seq<int>>, src: int, dst: int): set<seq<int>>\n    requires 0 <= src < |graph|\n    requires 0 <= dst < |graph|\n    reads graph\n  {\n    if src == dst then\n      { [src] }\n    else\n      set ps | \n        exists next :: next in graph[src] &&\n          ps in AllPathsFromTo(graph, next, dst) &&\n          ps[0] == next\n        :: [src] + ps\n  }\n\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 14.086,
        "duration_formatted": "14.09s",
        "tokens": {
          "input": 364,
          "output": 811,
          "total": 1175
        },
        "cost_usd": 0.007216,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:28:08.509775"
      }
    },
    {
      "file_path": "Python/alternating-groups-i.py",
      "code": "class Solution(object):\n\n    def numberOfAlternatingGroups(self, colors):\n        k = 3\n        result = curr = left = 0\n        for right in xrange(len(colors) + k - 1):\n            if right - left + 1 == k:\n                result += int(curr == k - 1)\n                curr -= int(colors[left] != colors[(left + 1) % len(colors)])\n                left += 1\n            curr += int(colors[right % len(colors)] != colors[(right + 1) % len(colors)])\n        return result\n\nclass Solution2(object):\n\n    def numberOfAlternatingGroups(self, colors):\n        return sum((colors[i] != colors[(i + 1) % len(colors)] != colors[(i + 2) % len(colors)] for i in xrange(len(colors))))",
      "program_specification": "```dafny\n// Dafny translation of Solution.numberOfAlternatingGroups\n\nmethod NumberOfAlternatingGroups(colors: seq<int>) returns (result: int)\n    requires |colors| >= 1\n    ensures result == NumberOfAlternatingGroupsSpec(colors)\n{\n    var k := 3;\n    result := 0;\n    var curr := 0;\n    var left := 0;\n    var n := |colors|;\n\n    var right := 0;\n    while right < n + k - 1\n        invariant 0 <= left <= right <= n + k - 1\n        invariant 0 <= curr <= k - 1\n        invariant result == CountAlternatingGroups(colors, left, right, k)\n        invariant left <= n\n    {\n        if right - left + 1 == k {\n            if curr == k - 1 {\n                result := result + 1;\n            }\n            if colors[left % n] != colors[(left + 1) % n] {\n                curr := curr - 1;\n            }\n            left := left + 1;\n        }\n        if colors[right % n] != colors[(right + 1) % n] {\n            curr := curr + 1;\n        }\n        right := right + 1;\n    }\n}\n\nfunction CountAlternatingGroups(colors: seq<int>, left: int, right: int, k: int): int\n    requires 0 <= left <= right <= |colors| + k - 1\n    requires |colors| >= 1\n    decreases right - left\n{\n    if left == 0 then 0\n    else\n        CountAlternatingGroups(colors, left - 1, right - 1, k) +\n        (if IsAlternatingGroup(colors, left - 1, k) then 1 else 0)\n}\n\nfunction IsAlternatingGroup(colors: seq<int>, start: int, k: int): bool\n    requires |colors| >= 1\n    requires 0 <= start < |colors|\n{\n    (forall i :: 0 <= i < k - 1 ==> colors[(start + i) % |colors|] != colors[(start + i + 1) % |colors|])\n}\n\nfunction NumberOfAlternatingGroupsSpec(colors: seq<int>): int\n    requires |colors| >= 1\n{\n    var n := |colors|;\n    |set i | 0 <= i < n && IsAlternatingGroup(colors, i, 3)|\n}\n\n// Dafny translation of Solution2.numberOfAlternatingGroups\n\nmethod NumberOfAlternatingGroups2(colors: seq<int>) returns (result: int)\n    requires |colors| >= 1\n    ensures result == NumberOfAlternatingGroupsSpec(colors)\n{\n    var n := |colors|;\n    result := 0;\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant result == |set j | 0 <= j < i && IsAlternatingGroup(colors, j, 3)|\n    {\n        if IsAlternatingGroup(colors, i, 3) {\n            result := result + 1;\n        }\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 8.569,
        "duration_formatted": "8.57s",
        "tokens": {
          "input": 445,
          "output": 674,
          "total": 1119
        },
        "cost_usd": 0.006282,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:28:27.085157"
      }
    },
    {
      "file_path": "Python/append-k-integers-with-minimal-sum.py",
      "code": "class Solution(object):\n\n    def minimalKSum(self, nums, k):\n        result = k * (k + 1) // 2\n        curr = k + 1\n        for x in sorted(set(nums)):\n            if x < curr:\n                result += curr - x\n                curr += 1\n        return result\n\nclass Solution2(object):\n\n    def minimalKSum(self, nums, k):\n        result = prev = 0\n        nums.append(float('inf'))\n        for x in sorted(set(nums)):\n            if not k:\n                break\n            cnt = min(x - 1 - prev, k)\n            k -= cnt\n            result += (prev + 1 + (prev + cnt)) * cnt // 2\n            prev = x\n        return result",
      "program_specification": "```dafny\n// Dafny translation of Solution.minimalKSum\n\nmethod MinimalKSum(nums: seq<int>, k: int) returns (result: int)\n    requires k >= 0\n    requires forall x :: 1 <= x // nums are positive integers in the original problem\n    ensures result == MinimalKSumSpec(nums, k)\n{\n    var s := SetFromSeq(nums);\n    var sortedNums := SeqSort(SetToSeq(s));\n    result := k * (k + 1) / 2;\n    var curr := k + 1;\n    var i := 0;\n    while i < |sortedNums|\n        invariant 0 <= i <= |sortedNums|\n        invariant result == k * (k + 1) / 2 + sum { j | 0 <= j < i && sortedNums[j] < k + 1 } (currAt(j, k) - sortedNums[j])\n        invariant curr == k + 1 + sum { j | 0 <= j < i && sortedNums[j] < k + 1 } 1\n    {\n        var x := sortedNums[i];\n        if x < curr {\n            result := result + curr - x;\n            curr := curr + 1;\n        }\n        i := i + 1;\n    }\n}\n\nfunction method MinimalKSumSpec(nums: seq<int>, k: int): int\n{\n    var s := set x | x in nums;\n    var res := k * (k + 1) / 2;\n    var curr := k + 1;\n    var sortedNums := SeqSort(SetToSeq(s));\n    var r := res;\n    var c := curr;\n    var i := 0;\n    while i < |sortedNums|\n        decreases |sortedNums| - i\n    {\n        var x := sortedNums[i];\n        if x < c {\n            r := r + c - x;\n            c := c + 1;\n        }\n        i := i + 1;\n    }\n    r\n}\n\n// Helper: convert sequence to set\nfunction SetFromSeq(s: seq<int>): set<int>\n{\n    set x | x in s\n}\n\n// Helper: convert set to sequence (arbitrary order)\nfunction SetToSeq(s: set<int>): seq<int>\n{\n    if |s| == 0 then [] else [s[*]] + SetToSeq(s - {s[*]})\n}\n\n// Helper: sort a sequence (ascending)\nfunction SeqSort(s: seq<int>): seq<int>\n    decreases |s|\n{\n    if |s| <= 1 then s\n    else\n        var pivot := s[0];\n        SeqSort([x | x in s[1..] && x < pivot]) +\n        [pivot] +\n        SeqSort([x | x in s[1..] && x >= pivot])\n}\n\n// Helper: for loop invariants\nfunction currAt(j: int, k: int): int\n{\n    k + 1 + sum { l | 0 <= l < j } 1\n}\n\n// -----------------------------------------------\n\n// Dafny translation of Solution2.minimalKSum\n\nmethod MinimalKSum2(nums: seq<int>, k: int) returns (result: int)\n    requires k >= 0\n    requires forall x :: 1 <= x\n    ensures result == MinimalKSum2Spec(nums, k)\n{\n    var s := SetFromSeq(nums);\n    var sortedNums := SeqSort(SetToSeq(s));\n    var inf := 0x7FFFFFFF; // Use a large int as \"infinity\"\n    var numsWithInf := sortedNums + [inf];\n    result := 0;\n    var prev := 0;\n    var kk := k;\n    var i := 0;\n    while i < |numsWithInf| && kk > 0\n        invariant 0 <= i <= |numsWithInf|\n        invariant kk >= 0\n        invariant result == PartialSum(numsWithInf, i, k)\n        invariant prev == if i == 0 then 0 else numsWithInf[i-1]\n    {\n        var x := numsWithInf[i];\n        var cnt := if x - 1 - prev < kk then x - 1 - prev else kk;\n        if cnt > 0 {\n            result := result + (prev + 1 + (prev + cnt)) * cnt / 2;\n            kk := kk - cnt;\n        }\n        prev := x;\n        i := i + 1;\n    }\n}\n\nfunction method MinimalKSum2Spec(nums: seq<int>, k: int): int\n{\n    var s := set x | x in nums;\n    var sortedNums := SeqSort(SetToSeq(s));\n    var inf := 0x7FFFFFFF;\n    var numsWithInf := sortedNums + [inf];\n    var result := 0;\n    var prev := 0;\n    var kk := k;\n    var i := 0;\n    while i < |numsWithInf| && kk > 0\n        decreases |numsWithInf| - i, kk\n    {\n        var x := numsWithInf[i];\n        var cnt := if x - 1 - prev < kk then x - 1 - prev else kk;\n        if cnt > 0 {\n            result := result + (prev + 1 + (prev + cnt)) * cnt / 2;\n            kk := kk - cnt;\n        }\n        prev := x;\n        i := i + 1;\n    }\n    result\n}\n\n// Helper for loop invariant: sum of all numbers added so far\nfunction PartialSum(numsWithInf: seq<int>, i: int, k: int): int\n{\n    var result := 0;\n    var prev := 0;\n    var kk := k;\n    var j := 0;\n    while j < i && kk > 0\n        decreases i - j, kk\n    {\n        var x := numsWithInf[j];\n        var cnt := if x - 1 - prev < kk then x - 1 - prev else kk;\n        if cnt > 0 {\n            result := result + (prev + 1 + (prev + cnt)) * cnt / 2;\n            kk := kk - cnt;\n        }\n        prev := x;\n        j := j + 1;\n    }\n    result\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 21.605,
        "duration_formatted": "21.61s",
        "tokens": {
          "input": 436,
          "output": 1318,
          "total": 1754
        },
        "cost_usd": 0.011416,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:28:58.694063"
      }
    },
    {
      "file_path": "algorithms/arrays/rotate.py",
      "code": "def rotate_v1(array, k):\n    array = array[:]\n    n = len(array)\n    for i in range(k):\n        temp = array[n - 1]\n        for j in range(n - 1, 0, -1):\n            array[j] = array[j - 1]\n        array[0] = temp\n    return array\n\ndef rotate_v2(array, k):\n    array = array[:]\n\n    def reverse(arr, a, b):\n        while a < b:\n            arr[a], arr[b] = (arr[b], arr[a])\n            a += 1\n            b -= 1\n    n = len(array)\n    k = k % n\n    reverse(array, 0, n - k - 1)\n    reverse(array, n - k, n - 1)\n    reverse(array, 0, n - 1)\n    return array\n\ndef rotate_v3(array, k):\n    if array is None:\n        return None\n    length = len(array)\n    k = k % length\n    return array[length - k:] + array[:length - k]",
      "program_specification": "```dafny\n// Rotates an array to the right by k steps using three different algorithms\n\n// Helper function: returns the rotated sequence\nfunction RotateSeq(s: seq<int>, k: int): seq<int>\n    requires |s| > 0\n{\n    var n := |s|;\n    var m := if n == 0 then 0 else k % n;\n    s[n - m ..] + s[.. n - m]\n}\n\n// Version 1: Rotate by shifting one by one, k times\nmethod RotateV1(a: array<int>, k: int) returns (b: array<int>)\n    requires a != null && |a| > 0 && k >= 0\n    ensures b != null && |b| == |a|\n    ensures b[..] == RotateSeq(a[..], k)\n{\n    var n := a.Length;\n    b := new int[n];\n    // Copy a into b\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==> b[j] == a[j]\n    {\n        b[i] := a[i];\n        i := i + 1;\n    }\n\n    var count := 0;\n    while count < k\n        invariant 0 <= count <= k\n        invariant b[..] == RotateSeq(a[..], count)\n    {\n        var temp := b[n - 1];\n        var j := n - 1;\n        while j > 0\n            invariant 0 <= j <= n - 1\n            invariant forall m :: j <= m < n ==> b[m] == b[m - 1]\n        {\n            b[j] := b[j - 1];\n            j := j - 1;\n        }\n        b[0] := temp;\n        count := count + 1;\n    }\n}\n\n// Version 2: Rotate using reversal\nmethod RotateV2(a: array<int>, k: int) returns (b: array<int>)\n    requires a != null && |a| > 0 && k >= 0\n    ensures b != null && |b| == |a|\n    ensures b[..] == RotateSeq(a[..], k)\n{\n    var n := a.Length;\n    b := new int[n];\n    // Copy a into b\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==> b[j] == a[j]\n    {\n        b[i] := a[i];\n        i := i + 1;\n    }\n\n    var m := if n == 0 then 0 else k % n;\n\n    Reverse(b, 0, n - m - 1);\n    Reverse(b, n - m, n - 1);\n    Reverse(b, 0, n - 1);\n}\n\n// Helper method: reverse b[a..b]\nmethod Reverse(arr: array<int>, left: int, right: int)\n    requires arr != null && 0 <= left <= right + 1 <= arr.Length\n    modifies arr\n    ensures arr[..left] + arr[left..right+1][..][^1] + arr[right+1..] ==\n            old(arr[..left]) + old(arr[left..right+1][..][^1]) + old(arr[right+1..])\n{\n    var l := left;\n    var r := right;\n    while l < r\n        invariant left <= l <= r + 1 <= right + 1\n        invariant forall i :: 0 <= i < left ==> arr[i] == old(arr[i])\n        invariant forall i :: right + 1 <= i < arr.Length ==> arr[i] == old(arr[i])\n        invariant forall i :: 0 <= i < (r - l + 1) / 2 ==>\n            arr[l + i] == old(arr[right - i]) && arr[r - i] == old(arr[left + i])\n    {\n        var tmp := arr[l];\n        arr[l] := arr[r];\n        arr[r] := tmp;\n        l := l + 1;\n        r := r - 1;\n    }\n}\n\n// Version 3: Rotate using slicing (returns a new sequence)\nmethod RotateV3(a: array<int>, k: int) returns (b: array<int>)\n    requires a != null ==> (|a| > 0 && k >= 0)\n    ensures a == null ==> b == null\n    ensures a != null ==> b != null && |b| == |a| && b[..] == RotateSeq(a[..], k)\n{\n    if a == null {\n        b := null;\n        return;\n    }\n    var n := a.Length;\n    var m := if n == 0 then 0 else k % n;\n    b := new int[n];\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==>\n            (j < n - m ==> b[j] == a[j + m])\n            && (j >= n - m ==> b[j] == a[j - (n - m)])\n    {\n        if i < n - m {\n            b[i] := a[i + m];\n        } else {\n            b[i] := a[i - (n - m)];\n        }\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 15.797,
        "duration_formatted": "15.80s",
        "tokens": {
          "input": 505,
          "output": 1139,
          "total": 1644
        },
        "cost_usd": 0.010122,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:29:24.495093"
      }
    },
    {
      "file_path": "python/016_3Sum_Closest.py",
      "code": "class Solution(object):\n\n    def threeSumClosest(self, nums, target):\n        ls = len(nums)\n        sort_nums = sorted(nums)\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(ls - 2):\n            j, k = (i + 1, ls - 1)\n            while j < k:\n                temp = sort_nums[i] + sort_nums[j] + sort_nums[k]\n                if abs(target - temp) < abs(target - res):\n                    res = temp\n                if temp < target:\n                    j += 1\n                else:\n                    k -= 1\n        return res",
      "program_specification": "```dafny\nmethod ThreeSumClosest(nums: array<int>, target: int) returns (res: int)\n    requires nums != null\n    requires nums.Length >= 3\n    ensures exists i, j, k :: 0 <= i < j < k < nums.Length && res == nums[i] + nums[j] + nums[k]\n    ensures forall i, j, k :: 0 <= i < j < k < nums.Length ==>\n        abs(target - res) <= abs(target - (nums[i] + nums[j] + nums[k]))\n{\n    var ls := nums.Length;\n\n    // Copy and sort nums\n    var sort_nums := new int[ls];\n    var idx := 0;\n    while idx < ls\n        invariant 0 <= idx <= ls\n        invariant forall m :: 0 <= m < idx ==> sort_nums[m] == nums[m]\n    {\n        sort_nums[idx] := nums[idx];\n        idx := idx + 1;\n    }\n    // Simple insertion sort\n    var i := 1;\n    while i < ls\n        invariant 1 <= i <= ls\n        invariant multiset(sort_nums[..i]) == multiset(nums[..i])\n        invariant forall m :: 0 <= m < i-1 ==> sort_nums[m] <= sort_nums[m+1]\n    {\n        var key := sort_nums[i];\n        var j := i - 1;\n        while j >= 0 && sort_nums[j] > key\n            invariant -1 <= j < i\n            invariant forall m :: j+1 <= m < i ==> sort_nums[m] > key\n            decreases j\n        {\n            sort_nums[j+1] := sort_nums[j];\n            j := j - 1;\n        }\n        sort_nums[j+1] := key;\n        i := i + 1;\n    }\n\n    res := sort_nums[0] + sort_nums[1] + sort_nums[2];\n\n    i := 0;\n    while i < ls - 2\n        invariant 0 <= i <= ls - 2\n        invariant exists a, b, c :: 0 <= a < b < c < ls && res == sort_nums[a] + sort_nums[b] + sort_nums[c]\n        invariant forall a, b, c :: 0 <= a < b < c <= i+2 && a < b < c < ls ==>\n            abs(target - res) <= abs(target - (sort_nums[a] + sort_nums[b] + sort_nums[c]))\n        decreases ls - 2 - i\n    {\n        var j := i + 1;\n        var k := ls - 1;\n        while j < k\n            invariant i+1 <= j <= k+1 <= ls\n            invariant i < j <= k < ls\n            invariant exists a, b, c :: 0 <= a < b < c < ls && res == sort_nums[a] + sort_nums[b] + sort_nums[c]\n            invariant forall a, b, c :: 0 <= a < b < c < ls && (a == i && b >= i+1 && b < k && c > b && c <= ls-1 && c >= j && c <= k || a < i) ==>\n                abs(target - res) <= abs(target - (sort_nums[a] + sort_nums[b] + sort_nums[c]))\n            decreases k - j\n        {\n            var temp := sort_nums[i] + sort_nums[j] + sort_nums[k];\n            if abs(target - temp) < abs(target - res) {\n                res := temp;\n            }\n            if temp < target {\n                j := j + 1;\n            } else {\n                k := k - 1;\n            }\n        }\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.77,
        "duration_formatted": "7.77s",
        "tokens": {
          "input": 410,
          "output": 789,
          "total": 1199
        },
        "cost_usd": 0.007132,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:29:42.267000"
      }
    },
    {
      "file_path": "python/035_Search_Insert_Position.py",
      "code": "class Solution:\n\n    def searchInsert(self, nums, target):\n        l, r = (int(0), len(nums) - 1)\n        while l < r:\n            mid = int((l + r) / 2)\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        if nums[l] < target:\n            return l + 1\n        return l\nif __name__ == '__main__':\n    s = Solution()\n    print(s.searchInsert([1, 3, 5, 6], 5))",
      "program_specification": "```dafny\nmethod SearchInsert(nums: seq<int>, target: int) returns (idx: int)\n    requires nums != []\n    ensures 0 <= idx <= |nums|\n    ensures forall i :: 0 <= i < idx ==> nums[i] < target\n    ensures idx < |nums| ==> nums[idx] >= target\n{\n    var l := 0;\n    var r := |nums| - 1;\n    while l < r\n        invariant 0 <= l <= r < |nums|\n        invariant forall i :: 0 <= i < l ==> nums[i] < target\n        invariant r < |nums| ==> forall i :: r+1 <= i < |nums| ==> nums[i] < target\n        invariant l <= r\n    {\n        var mid := (l + r) / 2;\n        if nums[mid] < target {\n            l := mid + 1;\n        } else {\n            r := mid;\n        }\n    }\n    if nums[l] < target {\n        idx := l + 1;\n    } else {\n        idx := l;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 3.273,
        "duration_formatted": "3.27s",
        "tokens": {
          "input": 398,
          "output": 230,
          "total": 628
        },
        "cost_usd": 0.002636,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:29:55.545571"
      }
    },
    {
      "file_path": "python/045_Jump_Game_II.py",
      "code": "class Solution:\n\n    def jump(self, nums):\n        if len(nums) <= 1:\n            return 0\n        end = 0 + nums[0]\n        start = 0\n        step = 1\n        maxDis = 0 + nums[0]\n        while end < len(nums) - 1:\n            for i in range(start + 1, end + 1):\n                maxDis = max(maxDis, nums[i] + i)\n            start = end\n            end = maxDis\n            step += 1\n        return step",
      "program_specification": "```dafny\nmethod Jump(nums: seq<int>) returns (step: int)\n    requires |nums| > 0\n    requires forall i :: 0 <= i < |nums| ==> nums[i] >= 0\n    ensures step >= 0\n    ensures (|nums| == 1 ==> step == 0)\n    ensures (|nums| > 1 ==> step > 0)\n    // Ensures: step is the minimal number of jumps to reach the last index\n    ensures forall path: seq<int> ::\n        path[0] == 0 &&\n        |path| == step + 1 &&\n        path[|path|-1] == |nums|-1 &&\n        (forall j :: 0 <= j < |path|-1 ==> 0 <= path[j] < |nums| && path[j+1] > path[j] && path[j+1] <= path[j] + nums[path[j]]) ==>\n            (forall other: seq<int> ::\n                other[0] == 0 &&\n                other[|other|-1] == |nums|-1 &&\n                (forall k :: 0 <= k < |other|-1 ==> 0 <= other[k] < |nums| && other[k+1] > other[k] && other[k+1] <= other[k] + nums[other[k]]) ==>\n                    |other| >= |path|)\n{\n    if |nums| <= 1 {\n        step := 0;\n        return;\n    }\n    var end := nums[0];\n    var start := 0;\n    step := 1;\n    var maxDis := nums[0];\n\n    while end < |nums| - 1\n        invariant 0 <= start <= end < |nums|\n        invariant step > 0\n        invariant maxDis >= end\n        invariant end < |nums|\n        invariant forall i :: 0 <= i <= start ==> i + nums[i] <= maxDis\n        invariant forall i :: 0 <= i <= end ==> i + nums[i] <= maxDis\n    {\n        var i := start + 1;\n        while i <= end\n            invariant start + 1 <= i <= end + 1\n            invariant maxDis >= end\n            invariant forall j :: start + 1 <= j < i ==> maxDis >= j + nums[j]\n        {\n            if maxDis < nums[i] + i {\n                maxDis := nums[i] + i;\n            }\n            i := i + 1;\n        }\n        start := end;\n        end := maxDis;\n        step := step + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 15.856,
        "duration_formatted": "15.86s",
        "tokens": {
          "input": 391,
          "output": 544,
          "total": 935
        },
        "cost_usd": 0.005134,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:30:21.405706"
      }
    },
    {
      "file_path": "bit_manipulation/count_1s_brian_kernighan_method.py",
      "code": "def get_1s_count(number: int) -> int:\n    if not isinstance(number, int) or number < 0:\n        raise ValueError('Input must be a non-negative integer')\n    count = 0\n    while number:\n        number &= number - 1\n        count += 1\n    return count\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod Get1sCount(number: int) returns (count: int)\n    requires number >= 0\n    ensures count == NumOnes(number)\n{\n    var n := number;\n    count := 0;\n    while n > 0\n        invariant 0 <= n <= number\n        invariant count >= 0\n        invariant number == n + SumOfClearedBits(number, count)\n        invariant count == NumOnes(number) - NumOnes(n)\n    {\n        n := n & (n - 1);\n        count := count + 1;\n    }\n}\n\nfunction NumOnes(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 0 else (if n % 2 == 1 then 1 else 0) + NumOnes(n / 2)\n}\n\nfunction SumOfClearedBits(orig: int, steps: int): int\n    requires orig >= 0 && steps >= 0\n    decreases steps\n{\n    if steps == 0 then 0\n    else\n        var prev := orig & (orig - 1);\n        (orig - prev) + SumOfClearedBits(prev, steps - 1)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 4.51,
        "duration_formatted": "4.51s",
        "tokens": {
          "input": 360,
          "output": 258,
          "total": 618
        },
        "cost_usd": 0.002784,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:30:35.920288"
      }
    },
    {
      "file_path": "bit_manipulation/highest_set_bit.py",
      "code": "def get_highest_set_bit_position(number: int) -> int:\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n    position = 0\n    while number:\n        position += 1\n        number >>= 1\n    return position\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod GetHighestSetBitPosition(number: int) returns (position: int)\n    requires number >= 0\n    ensures position >= 0\n    ensures (number == 0 ==> position == 0)\n    ensures (number > 0 ==> 1 << (position - 1) <= number < 1 << position)\n{\n    var n := number;\n    position := 0;\n    while n > 0\n        invariant 0 <= n <= number\n        invariant position >= 0\n        invariant number == 0 ==> position == 0\n        invariant number > 0 ==> (n == 0 ==> 1 << (position - 1) <= number < 1 << position)\n    {\n        position := position + 1;\n        n := n >> 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 4.367,
        "duration_formatted": "4.37s",
        "tokens": {
          "input": 355,
          "output": 172,
          "total": 527
        },
        "cost_usd": 0.002086,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:30:50.291143"
      }
    },
    {
      "file_path": "dynamic_programming/max_non_adjacent_sum.py",
      "code": "from __future__ import annotations\n\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (max_excluding + num, max(max_including, max_excluding))\n    return max(max_excluding, max_including)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod MaximumNonAdjacentSum(nums: seq<int>) returns (result: int)\n    requires true\n    ensures result == MaximumNonAdjacentSumSpec(nums)\n{\n    if |nums| == 0 {\n        return 0;\n    }\n\n    var max_including := nums[0];\n    var max_excluding := 0;\n    var i := 1;\n    while i < |nums|\n        invariant 1 <= i <= |nums|\n        invariant max_including == MaximumNonAdjacentSumSpecSlice(nums[..i], true)\n        invariant max_excluding == MaximumNonAdjacentSumSpecSlice(nums[..i], false)\n    {\n        var new_max_including := max_excluding + nums[i];\n        var new_max_excluding := if max_including > max_excluding then max_including else max_excluding;\n        max_including := new_max_including;\n        max_excluding := new_max_excluding;\n        i := i + 1;\n    }\n    result := if max_including > max_excluding then max_including else max_excluding;\n}\n\n// Specification: the maximum sum of non-adjacent elements in nums\nfunction MaximumNonAdjacentSumSpec(nums: seq<int>): int\n{\n    if |nums| == 0 then 0\n    else if |nums| == 1 then nums[0]\n    else\n        var pick := nums[|nums|-1] + MaximumNonAdjacentSumSpec(nums[..|nums|-2]);\n        var skip := MaximumNonAdjacentSumSpec(nums[..|nums|-1]);\n        if pick > skip then pick else skip\n}\n\n// Helper function: computes the maximum sum of non-adjacent elements in nums[..n],\n// where 'include_last' indicates whether the last element is included in the sum.\nfunction MaximumNonAdjacentSumSpecSlice(nums: seq<int>, include_last: bool): int\n{\n    if |nums| == 0 then 0\n    else if |nums| == 1 then if include_last then nums[0] else 0\n    else if include_last then\n        nums[|nums|-1] + MaximumNonAdjacentSumSpecSlice(nums[..|nums|-2], false)\n    else\n        var a := MaximumNonAdjacentSumSpecSlice(nums[..|nums|-1], true);\n        var b := MaximumNonAdjacentSumSpecSlice(nums[..|nums|-1], false);\n        if a > b then a else b\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.097,
        "duration_formatted": "7.10s",
        "tokens": {
          "input": 385,
          "output": 503,
          "total": 888
        },
        "cost_usd": 0.004794,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:31:07.390676"
      }
    },
    {
      "file_path": "dynamic_programming/min_distance_up_bottom.py",
      "code": "import functools\n\ndef min_distance_up_bottom(word1: str, word2: str) -> int:\n    len_word1 = len(word1)\n    len_word2 = len(word2)\n\n    @functools.cache\n    def min_distance(index1: int, index2: int) -> int:\n        if index1 >= len_word1:\n            return len_word2 - index2\n        if index2 >= len_word2:\n            return len_word1 - index1\n        diff = int(word1[index1] != word2[index2])\n        return min(1 + min_distance(index1 + 1, index2), 1 + min_distance(index1, index2 + 1), diff + min_distance(index1 + 1, index2 + 1))\n    return min_distance(0, 0)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod MinDistanceUpBottom(word1: seq<char>, word2: seq<char>) returns (result: int)\n    requires |word1| >= 0 && |word2| >= 0\n    ensures result >= 0\n    ensures result == MinEditDistance(word1, word2)\n{\n    var len_word1 := |word1|;\n    var len_word2 := |word2|;\n\n    // We use a 2D array for memoization\n    var memo := new int?[len_word1 + 1, len_word2 + 1];\n\n    method min_distance(index1: int, index2: int) returns (res: int)\n        requires 0 <= index1 <= len_word1\n        requires 0 <= index2 <= len_word2\n        ensures res == MinEditDistance(word1[index1..], word2[index2..])\n    {\n        if memo[index1, index2] != null {\n            res := memo[index1, index2].Value;\n            return;\n        }\n        if index1 >= len_word1 {\n            res := len_word2 - index2;\n        } else if index2 >= len_word2 {\n            res := len_word1 - index1;\n        } else {\n            var diff := if word1[index1] == word2[index2] then 0 else 1;\n            var delete := 1 + min_distance(index1 + 1, index2);\n            var insert := 1 + min_distance(index1, index2 + 1);\n            var replace := diff + min_distance(index1 + 1, index2 + 1);\n            res := if delete < insert then (if delete < replace then delete else replace) else (if insert < replace then insert else replace);\n        }\n        memo[index1, index2] := res;\n    }\n\n    result := min_distance(0, 0);\n}\n\n// Specification function for edit distance\nfunction MinEditDistance(s1: seq<char>, s2: seq<char>): int\n    decreases |s1| + |s2|\n{\n    if |s1| == 0 then |s2|\n    else if |s2| == 0 then |s1|\n    else\n        var diff := if s1[0] == s2[0] then 0 else 1;\n        var delete := 1 + MinEditDistance(s1[1..], s2);\n        var insert := 1 + MinEditDistance(s1, s2[1..]);\n        var replace := diff + MinEditDistance(s1[1..], s2[1..]);\n        if delete < insert then (if delete < replace then delete else replace) else (if insert < replace then insert else replace)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.245,
        "duration_formatted": "7.25s",
        "tokens": {
          "input": 463,
          "output": 573,
          "total": 1036
        },
        "cost_usd": 0.00551,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:31:24.640319"
      }
    },
    {
      "file_path": "electronics/resonant_frequency.py",
      "code": "from __future__ import annotations\nfrom math import pi, sqrt\n\ndef resonant_frequency(inductance: float, capacitance: float) -> tuple:\n    if inductance <= 0:\n        raise ValueError('Inductance cannot be 0 or negative')\n    elif capacitance <= 0:\n        raise ValueError('Capacitance cannot be 0 or negative')\n    else:\n        return ('Resonant frequency', float(1 / (2 * pi * sqrt(inductance * capacitance))))\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod ResonantFrequency(inductance: real, capacitance: real) returns (label: string, freq: real)\n    requires inductance > 0.0\n    requires capacitance > 0.0\n    ensures label == \"Resonant frequency\"\n    ensures freq == 1.0 / (2.0 * PI * Sqrt(inductance * capacitance))\n{\n    label := \"Resonant frequency\";\n    freq := 1.0 / (2.0 * PI * Sqrt(inductance * capacitance));\n}\n\n// Mathematical constant pi\nconst PI: real := 3.14159265358979323846;\n\n// Square root function for non-negative real numbers\nfunction method Sqrt(x: real): real\n    requires x >= 0.0\n    ensures Sqrt(x) >= 0.0\n    ensures Sqrt(x) * Sqrt(x) == x\n{\n    if x == 0.0 then 0.0 else\n    // Newton-Raphson iteration for square root (5 iterations)\n    var guess := x / 2.0;\n    var i := 0;\n    while i < 5\n        invariant 0 <= i <= 5\n        invariant guess > 0.0\n    {\n        guess := 0.5 * (guess + x / guess);\n        i := i + 1;\n    }\n    guess\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 4.41,
        "duration_formatted": "4.41s",
        "tokens": {
          "input": 398,
          "output": 299,
          "total": 697
        },
        "cost_usd": 0.003188,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:31:39.053888"
      }
    },
    {
      "file_path": "graphs/gale_shapley_bigraph.py",
      "code": "from __future__ import annotations\n\ndef stable_matching(donor_pref: list[list[int]], recipient_pref: list[list[int]]) -> list[int]:\n    assert len(donor_pref) == len(recipient_pref)\n    n = len(donor_pref)\n    unmatched_donors = list(range(n))\n    donor_record = [-1] * n\n    rec_record = [-1] * n\n    num_donations = [0] * n\n    while unmatched_donors:\n        donor = unmatched_donors[0]\n        donor_preference = donor_pref[donor]\n        recipient = donor_preference[num_donations[donor]]\n        num_donations[donor] += 1\n        rec_preference = recipient_pref[recipient]\n        prev_donor = rec_record[recipient]\n        if prev_donor != -1:\n            if rec_preference.index(prev_donor) > rec_preference.index(donor):\n                rec_record[recipient] = donor\n                donor_record[donor] = recipient\n                unmatched_donors.append(prev_donor)\n                unmatched_donors.remove(donor)\n        else:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.remove(donor)\n    return donor_record",
      "program_specification": "```dafny\nmethod StableMatching(donorPref: seq<seq<int>>, recipientPref: seq<seq<int>>) returns (donorRecord: seq<int>)\n    requires |donorPref| == |recipientPref|\n    requires forall i :: 0 <= i < |donorPref| ==> donorPref[i].Distinct() && donorPref[i].SortedBySet(0, |donorPref|)\n    requires forall i :: 0 <= i < |recipientPref| ==> recipientPref[i].Distinct() && recipientPref[i].SortedBySet(0, |recipientPref|)\n    ensures |donorRecord| == |donorPref|\n    ensures donorRecord.Permutation(Seq(0, |donorPref|, i => i)) // donorRecord is a permutation of recipients\n    ensures forall d, r :: 0 <= d < |donorPref| && 0 <= r < |recipientPref| && donorRecord[d] != r ==>\n        // No blocking pairs: if donor d prefers r to their match, then r prefers their match to d\n        donorPref[d].IndexOf(r) < donorPref[d].IndexOf(donorRecord[d]) ==>\n            recipientPref[r].IndexOf(RecipientMatch(recipientPref, donorRecord, r)) < recipientPref[r].IndexOf(d)\n{\n    var n := |donorPref|;\n    var unmatchedDonors := new List<int>();\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant unmatchedDonors == Seq(0, i, j => j)\n    {\n        unmatchedDonors.Add(i);\n        i := i + 1;\n    }\n    donorRecord := Seq(0, n, i => -1);\n    var recRecord := Seq(0, n, i => -1);\n    var numDonations := Seq(0, n, i => 0);\n\n    while unmatchedDonors.Count > 0\n        invariant 0 <= unmatchedDonors.Count <= n\n        invariant donorRecord.Length == n && recRecord.Length == n && numDonations.Length == n\n        invariant forall d :: 0 <= d < n ==> -1 <= donorRecord[d] < n\n        invariant forall r :: 0 <= r < n ==> -1 <= recRecord[r] < n\n        invariant forall d :: 0 <= d < n ==> 0 <= numDonations[d] <= n\n        invariant unmatchedDonors.Elements.Distinct()\n        decreases unmatchedDonors.Count\n    {\n        var donor := unmatchedDonors[0];\n        var donorPreference := donorPref[donor];\n        var recipient := donorPreference[numDonations[donor]];\n        numDonations := numDonations.Update(donor, numDonations[donor] + 1);\n        var recPreference := recipientPref[recipient];\n        var prevDonor := recRecord[recipient];\n        if prevDonor != -1 {\n            if recPreference.IndexOf(prevDonor) > recPreference.IndexOf(donor) {\n                recRecord := recRecord.Update(recipient, donor);\n                donorRecord := donorRecord.Update(donor, recipient);\n                unmatchedDonors.Add(prevDonor);\n                unmatchedDonors.Remove(donor);\n            }\n        } else {\n            recRecord := recRecord.Update(recipient, donor);\n            donorRecord := donorRecord.Update(donor, recipient);\n            unmatchedDonors.Remove(donor);\n        }\n    }\n}\n\nfunction RecipientMatch(recipientPref: seq<seq<int>>, donorRecord: seq<int>, r: int): int\n    requires 0 <= r < |recipientPref|\n    requires |donorRecord| == |recipientPref|\n    ensures 0 <= RecipientMatch(recipientPref, donorRecord, r) < |donorRecord|\n{\n    // Find the donor matched to recipient r\n    var d: int :| 0 <= d < |donorRecord| && donorRecord[d] == r;\n    d\n}\n\n// Helper function: checks if a sequence is a permutation of another\nfunction method seq<T>.Permutation(other: seq<T>): bool\n{\n    multiset(this) == multiset(other)\n}\n\n// Helper function: checks if a sequence contains all elements in [start, end)\nfunction method seq<int>.SortedBySet(start: int, end: int): bool\n{\n    multiset(this) == multiset(Seq(start, end, i => i))\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 21.779,
        "duration_formatted": "21.78s",
        "tokens": {
          "input": 541,
          "output": 919,
          "total": 1460
        },
        "cost_usd": 0.008434,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:32:10.836338"
      }
    },
    {
      "file_path": "greedy_methods/fractional_knapsack_2.py",
      "code": "from __future__ import annotations\n\ndef fractional_knapsack(value: list[int], weight: list[int], capacity: int) -> tuple[float, list[float]]:\n    index = list(range(len(value)))\n    ratio = [v / w for v, w in zip(value, weight)]\n    index.sort(key=lambda i: ratio[i], reverse=True)\n    max_value: float = 0\n    fractions: list[float] = [0] * len(value)\n    for i in index:\n        if weight[i] <= capacity:\n            fractions[i] = 1\n            max_value += value[i]\n            capacity -= weight[i]\n        else:\n            fractions[i] = capacity / weight[i]\n            max_value += value[i] * capacity / weight[i]\n            break\n    return (max_value, fractions)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod FractionalKnapsack(value: seq<int>, weight: seq<int>, capacity: int) returns (maxValue: real, fractions: seq<real>)\n    requires |value| == |weight|\n    requires forall w :: 0 <= w < |weight| ==> weight[w] > 0\n    requires capacity >= 0\n    ensures 0.0 <= maxValue\n    ensures |fractions| == |value|\n    ensures forall i :: 0 <= i < |fractions| ==> 0.0 <= fractions[i] <= 1.0\n    ensures sum i | 0 <= i < |value| :: fractions[i] * weight[i] <= capacity\n    ensures maxValue == sum i | 0 <= i < |value| :: fractions[i] * value[i]\n    ensures forall i :: 0 <= i < |value| && fractions[i] < 1.0 ==> \n                (sum j | 0 <= j < |value| :: fractions[j] * weight[j]) == capacity\n{\n    var n := |value|;\n    var index := new int[n];\n    var ratio := new real[n];\n    var i: int := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==> index[j] == j\n    {\n        index[i] := i;\n        ratio[i] := value[i] as real / weight[i] as real;\n        i := i + 1;\n    }\n\n    // Sort index by decreasing ratio\n    // Simple selection sort for formalization\n    var j: int := 0;\n    while j < n\n        invariant 0 <= j <= n\n        invariant forall a, b :: 0 <= a < j && j <= b < n ==> ratio[index[a]] >= ratio[index[b]]\n    {\n        var maxIdx := j;\n        var k: int := j + 1;\n        while k < n\n            invariant j + 1 <= k <= n\n            invariant j <= maxIdx < n\n            invariant forall m :: j + 1 <= m < k ==> ratio[index[maxIdx]] >= ratio[index[m]]\n        {\n            if ratio[index[k]] > ratio[index[maxIdx]] {\n                maxIdx := k;\n            }\n            k := k + 1;\n        }\n        // Swap index[j] and index[maxIdx]\n        var tmp := index[j];\n        index[j] := index[maxIdx];\n        index[maxIdx] := tmp;\n        j := j + 1;\n    }\n\n    maxValue := 0.0;\n    fractions := [];\n    i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |fractions| == n\n        invariant 0.0 <= maxValue\n        invariant forall k :: 0 <= k < i ==> 0.0 <= fractions[k] <= 1.0\n        invariant forall k :: i <= k < n ==> fractions[k] == 0.0\n        decreases n - i\n    {\n        fractions := if |fractions| == 0 then [0.0] * n else fractions;\n        var idx := index[i];\n        if weight[idx] <= capacity {\n            fractions[idx] := 1.0;\n            maxValue := maxValue + value[idx] as real;\n            capacity := capacity - weight[idx];\n        } else if capacity > 0 {\n            fractions[idx] := capacity as real / weight[idx] as real;\n            maxValue := maxValue + value[idx] as real * (capacity as real / weight[idx] as real);\n            capacity := 0;\n            // Set remaining fractions to 0\n            var m := i + 1;\n            while m < n\n                invariant i + 1 <= m <= n\n                invariant forall l :: m <= l < n ==> fractions[index[l]] == 0.0\n            {\n                fractions[index[m]] := 0.0;\n                m := m + 1;\n            }\n            break;\n        } else {\n            fractions[idx] := 0.0;\n        }\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 13.442,
        "duration_formatted": "13.44s",
        "tokens": {
          "input": 460,
          "output": 877,
          "total": 1337
        },
        "cost_usd": 0.007936,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:32:34.281095"
      }
    },
    {
      "file_path": "greedy_methods/optimal_merge_pattern.py",
      "code": "def optimal_merge_pattern(files: list) -> float:\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod OptimalMergePattern(files: seq<int>) returns (optimal_merge_cost: int)\n    requires |files| >= 1\n    requires forall f :: 0 <= f < |files| ==> files[f] >= 0\n    ensures optimal_merge_cost >= 0\n    ensures |files| == 1 ==> optimal_merge_cost == 0\n    // The cost is the sum of all merge operations performed according to the optimal merge pattern\n{\n    var workingFiles := files[..];\n    optimal_merge_cost := 0;\n\n    while |workingFiles| > 1\n        invariant |workingFiles| >= 1\n        invariant |workingFiles| <= |files|\n        invariant optimal_merge_cost >= 0\n        invariant multiset(workingFiles) + multiset([]) == multiset(files)\n        decreases |workingFiles|\n    {\n        // Find the two smallest files\n        var min1 := workingFiles[0];\n        var idx1 := 0;\n        var i := 1;\n        while i < |workingFiles|\n            invariant 0 <= idx1 < |workingFiles|\n            invariant 1 <= i <= |workingFiles|\n            invariant min1 == workingFiles[idx1]\n            invariant forall j :: 0 <= j < i ==> min1 <= workingFiles[j]\n            decreases |workingFiles| - i\n        {\n            if workingFiles[i] < min1 {\n                min1 := workingFiles[i];\n                idx1 := i;\n            }\n            i := i + 1;\n        }\n\n        // Remove the first minimum\n        var tempFiles1 := workingFiles[..idx1] + workingFiles[idx1+1..];\n\n        // Find the second minimum\n        var min2 := tempFiles1[0];\n        var idx2 := 0;\n        i := 1;\n        while i < |tempFiles1|\n            invariant 0 <= idx2 < |tempFiles1|\n            invariant 1 <= i <= |tempFiles1|\n            invariant min2 == tempFiles1[idx2]\n            invariant forall j :: 0 <= j < i ==> min2 <= tempFiles1[j]\n            decreases |tempFiles1| - i\n        {\n            if tempFiles1[i] < min2 {\n                min2 := tempFiles1[i];\n                idx2 := i;\n            }\n            i := i + 1;\n        }\n\n        // Remove the second minimum and append their sum\n        var merged := min1 + min2;\n        var newFiles := tempFiles1[..idx2] + tempFiles1[idx2+1..] + [merged];\n\n        workingFiles := newFiles;\n        optimal_merge_cost := optimal_merge_cost + merged;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 8.458,
        "duration_formatted": "8.46s",
        "tokens": {
          "input": 374,
          "output": 561,
          "total": 935
        },
        "cost_usd": 0.005236,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:32:52.743482"
      }
    },
    {
      "file_path": "knapsack/knapsack.py",
      "code": "from __future__ import annotations\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int) -> int:\n    if counter == 0 or capacity == 0:\n        return 0\n    if weights[counter - 1] > capacity:\n        return knapsack(capacity, weights, values, counter - 1)\n    else:\n        left_capacity = capacity - weights[counter - 1]\n        new_value_included = values[counter - 1] + knapsack(left_capacity, weights, values, counter - 1)\n        without_new_value = knapsack(capacity, weights, values, counter - 1)\n        return max(new_value_included, without_new_value)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod Knapsack(capacity: int, weights: seq<int>, values: seq<int>, counter: int) returns (result: int)\n    requires 0 <= counter <= |weights|\n    requires |weights| == |values|\n    requires capacity >= 0\n    requires forall w :: 0 <= w < |weights| ==> weights[w] >= 0\n    ensures result == KnapsackSpec(capacity, weights, values, counter)\n    ensures result >= 0\n{\n    if counter == 0 || capacity == 0 {\n        result := 0;\n    } else if weights[counter - 1] > capacity {\n        result := Knapsack(capacity, weights, values, counter - 1);\n    } else {\n        var left_capacity := capacity - weights[counter - 1];\n        var new_value_included := values[counter - 1] + Knapsack(left_capacity, weights, values, counter - 1);\n        var without_new_value := Knapsack(capacity, weights, values, counter - 1);\n        if new_value_included > without_new_value {\n            result := new_value_included;\n        } else {\n            result := without_new_value;\n        }\n    }\n}\n\n/// Specification function for the knapsack problem\nfunction KnapsackSpec(capacity: int, weights: seq<int>, values: seq<int>, counter: int): int\n    requires 0 <= counter <= |weights|\n    requires |weights| == |values|\n    requires capacity >= 0\n    requires forall w :: 0 <= w < |weights| ==> weights[w] >= 0\n{\n    if counter == 0 || capacity == 0 then\n        0\n    else if weights[counter - 1] > capacity then\n        KnapsackSpec(capacity, weights, values, counter - 1)\n    else\n        max(\n            values[counter - 1] + KnapsackSpec(capacity - weights[counter - 1], weights, values, counter - 1),\n            KnapsackSpec(capacity, weights, values, counter - 1)\n        )\n}\n\nmethod Main()\n{\n    // Example usage:\n    var weights := [2, 3, 4, 5];\n    var values := [3, 4, 5, 6];\n    var capacity := 5;\n    var counter := |weights|;\n    var result := Knapsack(capacity, weights, values, counter);\n    print \"Maximum value in knapsack: \";\n    print result;\n    print \"\\n\";\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 8.542,
        "duration_formatted": "8.54s",
        "tokens": {
          "input": 441,
          "output": 523,
          "total": 964
        },
        "cost_usd": 0.005066,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:33:11.289516"
      }
    },
    {
      "file_path": "maths/average_median.py",
      "code": "from __future__ import annotations\n\ndef median(nums: list) -> int | float:\n    sorted_list: list[int] = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2 if length % 2 == 0 else sorted_list[mid_index]\n\ndef main():\n    import doctest\n    doctest.testmod()\nif __name__ == '__main__':\n    main()",
      "program_specification": "```dafny\nmethod Median(nums: seq<int>) returns (result: real)\n    requires |nums| > 0\n    ensures\n        // The result is either the middle element (if odd length)\n        // or the average of the two middle elements (if even length)\n        (|nums| % 2 == 1 ==>\n            result == MedianElement(nums, |nums| / 2)\n        ) &&\n        (|nums| % 2 == 0 ==>\n            result == (MedianElement(nums, |nums| / 2) + MedianElement(nums, |nums| / 2 - 1)) / 2.0\n        )\n{\n    var sortedList := Sort(nums);\n    var length := |sortedList|;\n    var midIndex := length / 2;\n    if length % 2 == 0 {\n        result := (sortedList[midIndex] + sortedList[midIndex - 1]) / 2.0;\n    } else {\n        result := sortedList[midIndex] as real;\n    }\n}\n\n// Helper function: returns the k-th element of the sorted sequence\nfunction MedianElement(nums: seq<int>, k: int): int\n    requires 0 <= k < |nums|\n    requires |nums| > 0\n{\n    Sort(nums)[k]\n}\n\n// Helper function: returns a sorted version of the sequence\nfunction Sort(s: seq<int>): seq<int>\n    ensures |Sort(s)| == |s|\n    ensures multiset(Sort(s)) == multiset(s)\n    ensures forall i, j :: 0 <= i < j < |Sort(s)| ==> Sort(s)[i] <= Sort(s)[j]\n{\n    if |s| == 0 then s\n    else\n        var min := Minimum(s);\n        [min] + Sort(RemoveFirst(s, min))\n}\n\n// Helper function: returns the minimum element in a non-empty sequence\nfunction Minimum(s: seq<int>): int\n    requires |s| > 0\n    ensures forall x :: x in s ==> Minimum(s) <= x\n    ensures Minimum(s) in s\n{\n    if |s| == 1 then s[0]\n    else if s[0] <= Minimum(s[1..]) then s[0] else Minimum(s[1..])\n}\n\n// Helper function: removes the first occurrence of x from s\nfunction RemoveFirst(s: seq<int>, x: int): seq<int>\n    ensures |RemoveFirst(s, x)| + 1 == |s| || ! (x in s)\n    ensures multiset(RemoveFirst(s, x)) + multiset([x]) == multiset(s)\n{\n    if |s| == 0 then s\n    else if s[0] == x then s[1..]\n    else [s[0]] + RemoveFirst(s[1..], x)\n}\n\n// Example usage\nmethod Main()\n{\n    var nums := [3, 1, 4, 2, 5];\n    var m := Median(nums);\n    print \"Median of \", nums, \" is \", m, \"\\n\";\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 10.575,
        "duration_formatted": "10.58s",
        "tokens": {
          "input": 377,
          "output": 645,
          "total": 1022
        },
        "cost_usd": 0.005914,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:33:31.871106"
      }
    },
    {
      "file_path": "maths/check_polygon.py",
      "code": "from __future__ import annotations\n\ndef check_polygon(nums: list[float]) -> bool:\n    if len(nums) < 2:\n        raise ValueError('Monogons and Digons are not polygons in the Euclidean space')\n    if any((i <= 0 for i in nums)):\n        raise ValueError('All values must be greater than 0')\n    copy_nums = nums.copy()\n    copy_nums.sort()\n    return copy_nums[-1] < sum(copy_nums[:-1])\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nmethod CheckPolygon(nums: seq<real>) returns (isPolygon: bool)\n    requires |nums| >= 2\n    requires forall i :: 0 <= i < |nums| ==> nums[i] > 0.0\n    ensures isPolygon <==> (\n        var sorted := Sort(nums);\n        sorted[|sorted|-1] < Sum(sorted[..|sorted|-1])\n    )\n{\n    var n := |nums|;\n    // Make a copy and sort\n    var copyNums := nums[..];\n    copyNums := Sort(copyNums);\n\n    // Compute sum of all but the largest\n    var sumRest: real := 0.0;\n    var i: int := 0;\n    while i < n - 1\n        invariant 0 <= i <= n-1\n        invariant sumRest == Sum(copyNums[..i])\n    {\n        sumRest := sumRest + copyNums[i];\n        i := i + 1;\n    }\n\n    isPolygon := copyNums[n-1] < sumRest;\n}\n\n// Helper function: sum of a sequence\nfunction method Sum(s: seq<real>): real\n    decreases |s|\n{\n    if |s| == 0 then 0.0 else s[0] + Sum(s[1..])\n}\n\n// Helper function: sorts a sequence in non-decreasing order\nfunction method Sort(s: seq<real>): seq<real>\n    ensures |Sort(s)| == |s|\n    ensures multiset(Sort(s)) == multiset(s)\n    ensures forall i, j :: 0 <= i < j < |Sort(s)| ==> Sort(s)[i] <= Sort(s)[j]\n    decreases |s|\n{\n    if |s| == 0 then s\n    else\n        var m := MinIndex(s);\n        [s[m]] + Sort(s[..m] + s[m+1..])\n}\n\n// Helper function: index of minimum element in a sequence\nfunction method MinIndex(s: seq<real>): int\n    requires |s| > 0\n    ensures 0 <= MinIndex(s) < |s|\n    ensures forall i :: 0 <= i < |s| ==> s[MinIndex(s)] <= s[i]\n    decreases |s|\n{\n    if |s| == 1 then 0\n    else if s[0] <= s[1] then\n        if |s| == 2 then 0\n        else\n            var rec := MinIndex(s[0] + s[2..]);\n            if s[0] <= s[rec+1] then 0 else rec+1\n    else\n        if |s| == 2 then 1\n        else\n            var rec := MinIndex(s[1..]);\n            if s[rec+1] <= s[0] then rec+1 else 0\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 9.327,
        "duration_formatted": "9.33s",
        "tokens": {
          "input": 393,
          "output": 599,
          "total": 992
        },
        "cost_usd": 0.005578,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:33:51.207166"
      }
    },
    {
      "file_path": "maths/euler_method.py",
      "code": "from collections.abc import Callable\nimport numpy as np\n\ndef explicit_euler(ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float) -> np.ndarray:\n    n = int(np.ceil((x_end - x0) / step_size))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n    for k in range(n):\n        y[k + 1] = y[k] + step_size * ode_func(x, y[k])\n        x += step_size\n    return y\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\n// Dafny program: Explicit Euler method for solving ODEs\n\n// Define the type for the ODE function: takes (x: real, y: real) and returns real\ntype ODEFunc = function (x: real, y: real): real\n\nmethod ExplicitEuler(odeFunc: ODEFunc, y0: real, x0: real, stepSize: real, xEnd: real) returns (y: seq<real>)\n    requires stepSize > 0.0\n    requires xEnd >= x0\n    ensures |y| == if (xEnd - x0) % stepSize == 0.0 then ((xEnd - x0) / stepSize) as int + 1 else ((xEnd - x0) / stepSize).Ceiling as int + 1\n    ensures y[0] == y0\n    // For all k in 0..|y|-2, y[k+1] = y[k] + stepSize * odeFunc(x0 + k*stepSize, y[k])\n    ensures forall k :: 0 <= k < |y|-1 ==>\n        y[k+1] == y[k] + stepSize * odeFunc(x0 + k * stepSize, y[k])\n{\n    var nReal := (xEnd - x0) / stepSize;\n    var n: int := if nReal % 1.0 == 0.0 then nReal as int else nReal.Ceiling as int;\n    var res := new real[n+1];\n    res[0] := y0;\n    var x := x0;\n    var k: int := 0;\n    while k < n\n        invariant 0 <= k <= n\n        invariant res[0] == y0\n        invariant forall i :: 0 <= i < k ==> res[i+1] == res[i] + stepSize * odeFunc(x0 + i * stepSize, res[i])\n        invariant x == x0 + k * stepSize\n    {\n        res[k+1] := res[k] + stepSize * odeFunc(x, res[k]);\n        x := x + stepSize;\n        k := k + 1;\n    }\n    y := res[..];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 9.675,
        "duration_formatted": "9.67s",
        "tokens": {
          "input": 420,
          "output": 477,
          "total": 897
        },
        "cost_usd": 0.004656,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:34:10.885517"
      }
    },
    {
      "file_path": "maths/euler_modified.py",
      "code": "from collections.abc import Callable\nimport numpy as np\n\ndef euler_modified(ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float) -> np.ndarray:\n    n = int(np.ceil((x_end - x0) / step_size))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n    for k in range(n):\n        y_get = y[k] + step_size * ode_func(x, y[k])\n        y[k + 1] = y[k] + step_size / 2 * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))\n        x += step_size\n    return y\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\n// Dafny translation of the Python euler_modified method with formal specifications\n\n// ODEFunc is a function type that takes (x: real, y: real) and returns real\ntype ODEFunc = function (x: real, y: real): real\n\nmethod EulerModified(ode_func: ODEFunc, y0: real, x0: real, step_size: real, x_end: real) returns (y: seq<real>)\n    requires step_size > 0.0\n    requires x_end >= x0\n    ensures |y| == if (x_end - x0) % step_size == 0.0 then ((x_end - x0) / step_size) as int + 1 else ((x_end - x0) / step_size).Ceiling as int + 1\n    ensures y[0] == y0\n    // For all k in 0..|y|-2, y[k+1] is computed by the modified Euler method step\n    ensures forall k :: 0 <= k < |y| - 1 ==>\n        var xk := x0 + k * step_size;\n        var yk := y[k];\n        var y_predict := yk + step_size * ode_func(xk, yk);\n        y[k+1] == yk + step_size / 2.0 * (ode_func(xk, yk) + ode_func(xk + step_size, y_predict))\n{\n    var n_real := (x_end - x0) / step_size;\n    var n: int := if n_real % 1.0 == 0.0 then n_real as int else n_real.Ceiling as int;\n    var yArr := new real[n + 1];\n    yArr[0] := y0;\n    var x := x0;\n    var k: int := 0;\n    while k < n\n        invariant 0 <= k <= n\n        invariant x == x0 + k * step_size\n        invariant yArr[0] == y0\n        invariant forall i :: 0 <= i < k ==>\n            var xi := x0 + i * step_size;\n            var yi := yArr[i];\n            var y_predict := yi + step_size * ode_func(xi, yi);\n            yArr[i+1] == yi + step_size / 2.0 * (ode_func(xi, yi) + ode_func(xi + step_size, y_predict))\n    {\n        var y_predict := yArr[k] + step_size * ode_func(x, yArr[k]);\n        yArr[k + 1] := yArr[k] + step_size / 2.0 * (ode_func(x, yArr[k]) + ode_func(x + step_size, y_predict));\n        x := x + step_size;\n        k := k + 1;\n    }\n    y := yArr[..];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 10.547,
        "duration_formatted": "10.55s",
        "tokens": {
          "input": 453,
          "output": 616,
          "total": 1069
        },
        "cost_usd": 0.005834,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:34:31.438177"
      }
    },
    {
      "file_path": "maths/sin.py",
      "code": "from math import factorial, radians\n\ndef sin(angle_in_degrees: float, accuracy: int=18, rounded_values_count: int=10) -> float:\n    angle_in_degrees = angle_in_degrees - angle_in_degrees // 360.0 * 360.0\n    angle_in_radians = radians(angle_in_degrees)\n    result = angle_in_radians\n    a = 3\n    b = -1\n    for _ in range(accuracy):\n        result += b * angle_in_radians ** a / factorial(a)\n        b = -b\n        a += 2\n    return round(result, rounded_values_count)\nif __name__ == '__main__':\n    __import__('doctest').testmod()",
      "program_specification": "```dafny\nfunction method Factorial(n: nat): nat\n    requires n >= 0\n    decreases n\n{\n    if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nfunction method Radians(degrees: real): real\n{\n    degrees * 3.14159265358979323846264338327950288 / 180.0\n}\n\nmethod Sin(angle_in_degrees: real, accuracy: nat, rounded_values_count: nat) returns (result: real)\n    requires accuracy >= 0\n    requires rounded_values_count >= 0\n    ensures -1.0 <= result <= 1.0\n    // The result is an approximation of sin(angle_in_degrees in radians)\n{\n    var normalized_degrees := angle_in_degrees - (angle_in_degrees / 360.0).Floor() * 360.0;\n    var angle_in_radians := Radians(normalized_degrees);\n    var sum := angle_in_radians;\n    var a := 3;\n    var b := -1;\n    var i := 0;\n\n    while i < accuracy\n        invariant 0 <= i <= accuracy\n        invariant a == 3 + 2 * i\n        invariant b == if i % 2 == 0 then -1 else 1\n        invariant sum == angle_in_radians + SumTerms(angle_in_radians, i)\n        decreases accuracy - i\n    {\n        sum := sum + b * angle_in_radians ** a / Factorial(a as nat);\n        b := -b;\n        a := a + 2;\n        i := i + 1;\n    }\n\n    result := RoundTo(sum, rounded_values_count);\n}\n\n// Helper function to compute the sum of the Taylor series terms (excluding the first term)\nfunction method SumTerms(x: real, n: nat): real\n    decreases n\n{\n    if n == 0 then 0.0\n    else\n        var k := n - 1;\n        var a := 3 + 2 * k;\n        var b := if k % 2 == 0 then -1 else 1;\n        b * x ** a / Factorial(a as nat) + SumTerms(x, k)\n}\n\n// Helper function to round a real number to a given number of decimal places\nfunction method RoundTo(x: real, decimals: nat): real\n{\n    if decimals == 0 then x.Floor()\n    else\n        var factor := 10.0 ** decimals;\n        ((x * factor).Round()) / factor\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.796,
        "duration_formatted": "7.80s",
        "tokens": {
          "input": 427,
          "output": 537,
          "total": 964
        },
        "cost_usd": 0.00515,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:34:49.237237"
      }
    },
    {
      "file_path": "physics/archimedes_principle_of_buoyant_force.py",
      "code": "g = 9.80665\n\ndef archimedes_principle(fluid_density: float, volume: float, gravity: float=g) -> float:\n    if fluid_density <= 0:\n        raise ValueError('Impossible fluid density')\n    if volume <= 0:\n        raise ValueError('Impossible object volume')\n    if gravity < 0:\n        raise ValueError('Impossible gravity')\n    return fluid_density * gravity * volume\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\nconst g: real := 9.80665\n\nmethod ArchimedesPrinciple(fluid_density: real, volume: real, gravity: real := g) returns (buoyant_force: real)\n    requires fluid_density > 0.0\n    requires volume > 0.0\n    requires gravity >= 0.0\n    ensures buoyant_force == fluid_density * gravity * volume\n{\n    buoyant_force := fluid_density * gravity * volume;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 1.793,
        "duration_formatted": "1.79s",
        "tokens": {
          "input": 382,
          "output": 101,
          "total": 483
        },
        "cost_usd": 0.001572,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:35:01.035087"
      }
    },
    {
      "file_path": "scheduling/job_sequencing_with_deadline.py",
      "code": "def job_sequencing_with_deadlines(jobs: list) -> list:\n    jobs = sorted(jobs, key=lambda value: value[2], reverse=True)\n    max_deadline = max(jobs, key=lambda value: value[1])[1]\n    time_slots = [-1] * max_deadline\n    count = 0\n    max_profit = 0\n    for job in jobs:\n        for i in range(job[1] - 1, -1, -1):\n            if time_slots[i] == -1:\n                time_slots[i] = job[0]\n                count += 1\n                max_profit += job[2]\n                break\n    return [count, max_profit]\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
      "program_specification": "```dafny\n// Dafny program for Job Sequencing with Deadlines\n\n// A Job is a tuple (id, deadline, profit)\ndatatype Job = Job(id: int, deadline: int, profit: int)\n\nmethod JobSequencingWithDeadlines(jobs: seq<Job>) returns (result: seq<int>)\n    requires |jobs| > 0\n    requires forall j :: 0 <= j < |jobs| ==> jobs[j].deadline > 0 && jobs[j].profit >= 0\n    ensures |result| == 2\n    // result[0] is the number of jobs scheduled\n    // result[1] is the maximum profit achieved\n    ensures 0 <= result[0] <= |jobs|\n    ensures result[1] >= 0\n    ensures forall i :: 0 <= i < result[0] ==> result[1] >= jobs[i].profit\n{\n    // Sort jobs by profit descending\n    var sortedJobs := SortJobsByProfit(jobs);\n\n    // Find maximum deadline\n    var max_deadline := MaxDeadline(jobs);\n\n    // Initialize time slots to -1 (unassigned)\n    var time_slots := new int[max_deadline];\n    var i := 0;\n    while i < max_deadline\n        invariant 0 <= i <= max_deadline\n        invariant time_slots.Length == max_deadline\n        invariant forall k :: 0 <= k < i ==> time_slots[k] == -1\n    {\n        time_slots[i] := -1;\n        i := i + 1;\n    }\n\n    var count := 0;\n    var max_profit := 0;\n\n    var j := 0;\n    while j < |sortedJobs|\n        invariant 0 <= j <= |sortedJobs|\n        invariant 0 <= count <= j\n        invariant max_profit >= 0\n        invariant time_slots.Length == max_deadline\n        invariant forall k :: 0 <= k < max_deadline ==> time_slots[k] == -1 || (exists l :: 0 <= l < j && sortedJobs[l].id == time_slots[k])\n    {\n        var job := sortedJobs[j];\n        var slot := job.deadline - 1;\n        var scheduled := false;\n\n        var k := slot;\n        while k >= 0\n            invariant -1 <= k <= slot\n            invariant scheduled ==> exists m :: k < m <= slot && time_slots[m] == job.id\n            invariant !scheduled ==> forall m :: k < m <= slot ==> time_slots[m] != job.id\n        {\n            if time_slots[k] == -1 {\n                time_slots[k] := job.id;\n                count := count + 1;\n                max_profit := max_profit + job.profit;\n                scheduled := true;\n                break;\n            }\n            k := k - 1;\n        }\n        j := j + 1;\n    }\n    result := [count, max_profit];\n}\n\n// Helper: Sort jobs by profit descending\nfunction SortJobsByProfit(jobs: seq<Job>): seq<Job>\n    ensures |SortJobsByProfit(jobs)| == |jobs|\n    ensures multiset(SortJobsByProfit(jobs)) == multiset(jobs)\n    ensures forall i, j :: 0 <= i < j < |SortJobsByProfit(jobs)| ==> SortJobsByProfit(jobs)[i].profit >= SortJobsByProfit(jobs)[j].profit\n{\n    // Selection sort for specification purposes\n    if |jobs| == 0 then jobs\n    else\n        var maxIdx := 0;\n        var i := 1;\n        while i < |jobs|\n            invariant 1 <= i <= |jobs|\n            invariant 0 <= maxIdx < |jobs|\n            invariant forall k :: 0 <= k < i ==> jobs[maxIdx].profit >= jobs[k].profit\n        {\n            if jobs[i].profit > jobs[maxIdx].profit {\n                maxIdx := i;\n            }\n            i := i + 1;\n        }\n        [jobs[maxIdx]] + SortJobsByProfit(jobs[..maxIdx] + jobs[maxIdx+1..])\n}\n\n// Helper: Find maximum deadline\nfunction MaxDeadline(jobs: seq<Job>): int\n    requires |jobs| > 0\n    ensures MaxDeadline(jobs) == (if |jobs| == 0 then 0 else (max j :: 0 <= j < |jobs| :: jobs[j].deadline))\n{\n    if |jobs| == 0 then 0\n    else\n        var m := jobs[0].deadline;\n        var i := 1;\n        while i < |jobs|\n            invariant 1 <= i <= |jobs|\n            invariant m == (max j :: 0 <= j < i :: jobs[j].deadline)\n        {\n            if jobs[i].deadline > m {\n                m := jobs[i].deadline;\n            }\n            i := i + 1;\n        }\n        m\n}\n\n// Example usage\nmethod Main()\n{\n    var jobs := [Job(1, 2, 100), Job(2, 1, 19), Job(3, 2, 27), Job(4, 1, 25), Job(5, 3, 15)];\n    var res := JobSequencingWithDeadlines(jobs);\n    print res[0], \" \", res[1], \"\\n\"; // Expected: 3 142\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 20.12,
        "duration_formatted": "20.12s",
        "tokens": {
          "input": 440,
          "output": 1123,
          "total": 1563
        },
        "cost_usd": 0.009864,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:35:31.161841"
      }
    },
    {
      "file_path": "1-100q/03.py",
      "code": "class Solution(object):\n\n    def lengthOfLongestSubstring(self, s):\n        mapSet = {}\n        start, result = (0, 0)\n        for end in range(len(s)):\n            if s[end] in mapSet:\n                start = max(mapSet[s[end]], start)\n            result = max(result, end - start + 1)\n            mapSet[s[end]] = end + 1\n        return result",
      "program_specification": "```dafny\nmethod LengthOfLongestSubstring(s: seq<char>) returns (result: int)\n    requires true\n    ensures 0 <= result <= |s|\n    ensures forall i, j :: 0 <= i <= j < |s| && j - i + 1 > result ==> exists k, l :: i <= k < l <= j && s[k] == s[l]\n    ensures exists i, j :: 0 <= i <= j < |s| && j - i + 1 == result && (forall k, l :: i <= k < l <= j && i <= l < l <= j ==> k == l || s[k] != s[l])\n{\n    var mapSet := map[]; // map from char to int (index + 1)\n    var start := 0;\n    result := 0;\n    var end := 0;\n    while end < |s|\n        invariant 0 <= start <= end <= |s|\n        invariant 0 <= result <= end - start + 1\n        invariant forall c: char :: c in mapSet ==> 1 <= mapSet[c] <= end + 1\n        invariant forall c: char :: c in mapSet ==> (exists k :: 0 <= k < end && s[k] == c && mapSet[c] == k + 1)\n        invariant forall i, j :: 0 <= i <= j < end && j - i + 1 > result ==> exists k, l :: i <= k < l <= j && s[k] == s[l]\n        invariant exists i, j :: 0 <= i <= j < end && j - i + 1 == result && (forall k, l :: i <= k < l <= j && i <= l < l <= j ==> k == l || s[k] != s[l])\n    {\n        if s[end] in mapSet {\n            start := if mapSet[s[end]] > start then mapSet[s[end]] else start;\n        }\n        result := if result > end - start + 1 then result else end - start + 1;\n        mapSet := mapSet[s[end] := end + 1];\n        end := end + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 8.801,
        "duration_formatted": "8.80s",
        "tokens": {
          "input": 360,
          "output": 464,
          "total": 824
        },
        "cost_usd": 0.004432,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:35:49.967729"
      }
    },
    {
      "file_path": "1-100q/26.py",
      "code": "class Solution(object):\n\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        index_i = 0\n        for index_j in range(1, len(nums)):\n            if nums[index_i] != nums[index_j]:\n                index_i += 1\n                nums[index_i] = nums[index_j]\n        return index_i + 1",
      "program_specification": "```dafny\nmethod RemoveDuplicates(nums: array<int>) returns (newLength: int)\n    requires nums != null\n    modifies nums\n    ensures 0 <= newLength <= nums.Length\n    ensures forall i, j :: 0 <= i < j < newLength ==> nums[i] != nums[j]\n    ensures forall i :: 0 <= i < newLength ==> exists j :: 0 <= j < nums.Length && nums[i] == old(nums[j])\n    ensures forall i :: 0 <= i < newLength-1 ==> nums[i] < nums[i+1] // preserves sorted order if input is sorted\n{\n    if nums.Length == 0 {\n        newLength := 0;\n        return;\n    }\n    var index_i := 0;\n    var index_j := 1;\n    while index_j < nums.Length\n        invariant 1 <= index_j <= nums.Length\n        invariant 0 <= index_i < index_j\n        invariant forall k :: 0 <= k < index_i ==> nums[k] != nums[index_i]\n        invariant forall k :: 0 <= k <= index_i ==> exists m :: 0 <= m < index_j && nums[k] == old(nums[m])\n        invariant forall k :: 0 <= k < index_i ==> nums[k] < nums[k+1]\n    {\n        if nums[index_i] != nums[index_j] {\n            index_i := index_i + 1;\n            nums[index_i] := nums[index_j];\n        }\n        index_j := index_j + 1;\n    }\n    newLength := index_i + 1;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 7.298,
        "duration_formatted": "7.30s",
        "tokens": {
          "input": 350,
          "output": 331,
          "total": 681
        },
        "cost_usd": 0.003348,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:36:07.271876"
      }
    },
    {
      "file_path": "1-100q/32.py",
      "code": "class Solution(object):\n\n    def longestValidParentheses(self, s):\n        stack, result = ([-1], 0)\n        for index in range(len(s)):\n            if s[index] == '(':\n                stack.append(index)\n            else:\n                currIndex = stack.pop()\n                if currIndex == -1:\n                    stack.append(index)\n                else:\n                    result = max(result, index - currIndex + 1)\n        return result",
      "program_specification": "```dafny\nmethod LongestValidParentheses(s: seq<char>) returns (result: int)\n    requires forall c :: c in s ==> c == '(' || c == ')'\n    ensures 0 <= result <= |s|\n    ensures forall i, j :: 0 <= i <= j < |s| && IsValidParentheses(s[i..j+1]) ==> result >= j - i + 1\n    ensures exists i, j :: 0 <= i <= j < |s| && IsValidParentheses(s[i..j+1]) && result == j - i + 1 || result == 0\n{\n    var stack := new seq<int>(1);\n    stack[0] := -1;\n    var res := 0;\n    var idx := 0;\n    while idx < |s|\n        invariant 0 <= idx <= |s|\n        invariant stack != null && stack.Length > 0\n        invariant forall k :: 0 <= k < stack.Length ==> -1 <= stack[k] < idx\n        invariant res >= 0\n        invariant res <= idx\n        invariant forall i, j :: 0 <= i <= j < idx && IsValidParentheses(s[i..j+1]) ==> res >= j - i + 1\n    {\n        if s[idx] == '(' {\n            stack := stack + [idx];\n        } else {\n            if stack.Length > 0 {\n                var currIndex := stack[stack.Length - 1];\n                stack := stack[..stack.Length - 1];\n                if currIndex == -1 {\n                    stack := stack + [idx];\n                } else {\n                    res := if res > idx - currIndex + 1 then res else idx - currIndex + 1;\n                }\n            } else {\n                stack := stack + [idx];\n            }\n        }\n        idx := idx + 1;\n    }\n    result := res;\n}\n\nfunction IsValidParentheses(s: seq<char>): bool\n    decreases s\n{\n    if |s| == 0 then true\n    else if s[0] == ')' then false\n    else\n        var balance := 0;\n        forall i :: 0 <= i < |s| ==>\n            (if s[i] == '(' then balance := balance + 1 else balance := balance - 1; balance >= 0)\n        && balance == 0\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 26.594,
        "duration_formatted": "26.59s",
        "tokens": {
          "input": 364,
          "output": 499,
          "total": 863
        },
        "cost_usd": 0.00472,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:36:43.871641"
      }
    },
    {
      "file_path": "1-100q/40.py",
      "code": "class Solution(object):\n\n    def combinationSum2(self, candidates, target):\n        result = []\n        candidates.sort()\n\n        def recursive(candidates, target, currList, index):\n            if target < 0:\n                return\n            if target == 0:\n                result.append(currList)\n                return\n            previous = -1\n            for start in range(index, len(candidates)):\n                if previous != candidates[start]:\n                    recursive(candidates, target - candidates[start], currList + [candidates[start]], start + 1)\n                    previous = candidates[start]\n        recursive(candidates, target, [], 0)\n        return result",
      "program_specification": "```dafny\nmethod CombinationSum2(candidates: seq<int>, target: int) returns (result: seq<seq<int>>)\n    requires forall x :: 0 <= x < |candidates| ==> candidates[x] >= 0\n    ensures forall comb :: comb in result ==> \n                |comb| > 0 &&\n                (forall x :: 0 <= x < |comb| ==> comb[x] in candidates) &&\n                multiset(comb) <= multiset(candidates) &&\n                sum(comb) == target\n    ensures forall comb: seq<int> :: \n                |comb| > 0 &&\n                (forall x :: 0 <= x < |comb| ==> comb[x] in candidates) &&\n                multiset(comb) <= multiset(candidates) &&\n                sum(comb) == target ==>\n                    comb in result\n    ensures forall i, j :: 0 <= i < |result| && 0 <= j < |result| && i != j ==> result[i] != result[j]\n{\n    var sortedCandidates := SortSeq(candidates);\n    var res := new seq<seq<int>>[];\n    CombinationSum2Recursive(sortedCandidates, target, [], 0, res);\n    result := res[..];\n}\n\n// Helper method to sort a sequence (simple insertion sort for specification)\nfunction method SortSeq(s: seq<int>): seq<int>\n    ensures multiset(SortSeq(s)) == multiset(s)\n    ensures forall i, j :: 0 <= i < j < |SortSeq(s)| ==> SortSeq(s)[i] <= SortSeq(s)[j]\n{\n    if |s| == 0 then s\n    else\n        var min := s[0];\n        var minIndex := 0;\n        var i := 1;\n        while i < |s|\n            decreases |s| - i\n        {\n            if s[i] < min {\n                min := s[i];\n                minIndex := i;\n            }\n            i := i + 1;\n        }\n        [min] + SortSeq(s[..minIndex] + s[minIndex+1..])\n}\n\n// Helper function to compute the sum of a sequence\nfunction sum(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\n// Helper function to get the multiset of a sequence\nfunction multiset(s: seq<int>): multiset<int>\n{\n    if |s| == 0 then multiset{} else multiset{s[0]} + multiset(s[1..])\n}\n\n// Recursive helper\nmethod CombinationSum2Recursive(\n    candidates: seq<int>, \n    target: int, \n    currList: seq<int>, \n    index: int, \n    res: seq<seq<int>> \n    )\n    modifies res\n    requires forall x :: 0 <= x < |candidates| ==> candidates[x] >= 0\n    requires 0 <= index <= |candidates|\n    requires forall i, j :: 0 <= i < j < |candidates| ==> candidates[i] <= candidates[j]\n    requires multiset(currList) <= multiset(candidates[..index])\n    ensures forall comb :: comb in old(res) ==> comb in res\n    ensures forall comb :: comb in res && comb !in old(res) ==> \n                |comb| > 0 &&\n                (forall x :: 0 <= x < |comb| ==> comb[x] in candidates) &&\n                multiset(comb) <= multiset(candidates) &&\n                sum(comb) == target + sum(currList) - sum(currList)\n    ensures forall comb :: comb in res && comb !in old(res) ==> \n                multiset(comb) == multiset(currList) + multiset(candidates[..index])\n{\n    if target < 0 {\n        return;\n    }\n    if target == 0 {\n        // Only add if not already present (to avoid duplicates)\n        if forall existing :: existing in res ==> existing != currList {\n            res := res + [currList];\n        }\n        return;\n    }\n    var previous: int := -1;\n    var start: int := index;\n    while start < |candidates|\n        invariant 0 <= start <= |candidates|\n        invariant previous == -1 || previous < candidates[start]\n        invariant forall i :: index <= i < start ==> candidates[i] != previous\n        invariant forall comb :: comb in old(res) ==> comb in res\n        decreases |candidates| - start\n    {\n        if previous == -1 || previous != candidates[start] {\n            CombinationSum2Recursive(\n                candidates, \n                target - candidates[start], \n                currList + [candidates[start]], \n                start + 1, \n                res\n            );\n            previous := candidates[start];\n        }\n        start := start + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 13.627,
        "duration_formatted": "13.63s",
        "tokens": {
          "input": 403,
          "output": 1012,
          "total": 1415
        },
        "cost_usd": 0.008902,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:37:07.502997"
      }
    },
    {
      "file_path": "1-100q/05.py",
      "code": "class Solution(object):\n\n    def longestPalindrome(self, s):\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        maxLength, result = (1, '')\n        for index in range(len(s)):\n            dp[index][index] = 1\n            result = s[index]\n        length = 2\n        while length <= len(s):\n            index_i = 0\n            while index_i < len(s) - length + 1:\n                index_j = index_i + length - 1\n                if length == 2 and s[index_i] == s[index_j]:\n                    dp[index_i][index_j] = 1\n                    maxLength = max(maxLength, 2)\n                    result = s[index_i:index_j + 1]\n                elif s[index_i] == s[index_j] and dp[index_i + 1][index_j - 1]:\n                    dp[index_i][index_j] = 1\n                    if length > maxLength:\n                        maxLength = length\n                        result = s[index_i:index_j + 1]\n                index_i += 1\n            length += 1\n        return result\n\nclass Solution(object):\n\n    def longestPalindrome(self, s):\n\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and (s[left] == s[right]):\n                left -= 1\n                right += 1\n            return right - left - 1\n        start, end = (0, 0)\n        for index in range(len(s)):\n            even_len = expand(s, index, index + 1)\n            odd_len = expand(s, index, index)\n            length = max(even_len, odd_len)\n            if length > end - start:\n                start = index - (length - 1) / 2\n                end = index + length / 2\n        return s[start:end + 1]",
      "program_specification": "```dafny\nmodule LongestPalindrome {\n\n  // Helper function: checks if a substring is a palindrome\n  function IsPalindrome(s: seq<char>, i: int, j: int): bool\n    requires 0 <= i <= j < |s|\n    decreases j - i\n  {\n    if i >= j then true\n    else s[i] == s[j] && IsPalindrome(s, i + 1, j - 1)\n  }\n\n  // Returns the longest palindromic substring of s (Dynamic Programming approach)\n  method LongestPalindromeDP(s: seq<char>) returns (res: seq<char>)\n    requires |s| >= 0\n    ensures 0 <= |res| <= |s|\n    ensures exists i, j :: 0 <= i <= j < |s| && res == s[i..j+1] && IsPalindrome(s, i, j)\n    ensures forall i, j :: 0 <= i <= j < |s| && IsPalindrome(s, i, j) ==> |s[i..j+1]| <= |res|\n  {\n    var n := |s|;\n    if n == 0 {\n      res := [];\n      return;\n    }\n\n    var dp := new bool[n][n];\n    var maxLength := 1;\n    var start := 0;\n\n    // Each single character is a palindrome\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant forall k :: 0 <= k < i ==> dp[k][k] == true\n    {\n      dp[i][i] := true;\n      i := i + 1;\n    }\n\n    // Check for substring of length 2\n    i := 0;\n    while i < n - 1\n      invariant 0 <= i <= n - 1\n      invariant forall k :: 0 <= k < i ==> (if s[k] == s[k+1] then dp[k][k+1] == true else true)\n    {\n      if s[i] == s[i+1] {\n        dp[i][i+1] := true;\n        if maxLength < 2 {\n          start := i;\n          maxLength := 2;\n        }\n      }\n      i := i + 1;\n    }\n\n    // Check for lengths greater than 2\n    var length := 3;\n    while length <= n\n      invariant 3 <= length <= n + 1\n      invariant 1 <= maxLength <= length - 1\n      decreases n - length + 1\n    {\n      i := 0;\n      while i <= n - length\n        invariant 0 <= i <= n - length + 1\n      {\n        var j := i + length - 1;\n        if s[i] == s[j] && dp[i+1][j-1] {\n          dp[i][j] := true;\n          if length > maxLength {\n            start := i;\n            maxLength := length;\n          }\n        }\n        i := i + 1;\n      }\n      length := length + 1;\n    }\n\n    res := s[start .. start + maxLength];\n  }\n\n  // Returns the longest palindromic substring of s (Expand Around Center approach)\n  method LongestPalindromeExpand(s: seq<char>) returns (res: seq<char>)\n    requires |s| >= 0\n    ensures 0 <= |res| <= |s|\n    ensures exists i, j :: 0 <= i <= j < |s| && res == s[i..j+1] && IsPalindrome(s, i, j)\n    ensures forall i, j :: 0 <= i <= j < |s| && IsPalindrome(s, i, j) ==> |s[i..j+1]| <= |res|\n  {\n    var n := |s|;\n    if n == 0 {\n      res := [];\n      return;\n    }\n\n    var start := 0;\n    var end := 0;\n\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant 0 <= start <= end < n\n      invariant end - start + 1 <= i + 1\n    {\n      var len1 := ExpandAroundCenter(s, i, i);\n      var len2 := ExpandAroundCenter(s, i, i + 1);\n      var len := if len1 > len2 then len1 else len2;\n      if len > end - start + 1 {\n        start := i - (len - 1) / 2;\n        end := i + len / 2;\n      }\n      i := i + 1;\n    }\n    res := s[start .. end + 1];\n  }\n\n  // Helper method: expands around center and returns length of palindrome\n  method ExpandAroundCenter(s: seq<char>, left: int, right: int) returns (length: int)\n    requires 0 <= left <= right <= |s|\n    ensures 0 <= length <= |s|\n    ensures exists l, r :: 0 <= l <= left <= right - 1 <= r < |s| && l + r == left + right - 1 && IsPalindrome(s, l, r) && length == r - l + 1\n  {\n    var L := left;\n    var R := right;\n    while L >= 0 && R < |s| && s[L] == s[R]\n      invariant 0 <= L + 1 <= left + 1\n      invariant right - 1 <= R - 1 < |s|\n      invariant left - L == R - right\n    {\n      L := L - 1;\n      R := R + 1;\n    }\n    length := R - L - 1;\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 15.551,
        "duration_formatted": "15.55s",
        "tokens": {
          "input": 675,
          "output": 1215,
          "total": 1890
        },
        "cost_usd": 0.01107,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:37:33.059011"
      }
    },
    {
      "file_path": "1-100q/15.py",
      "code": "class Solution(object):\n\n    def threeSum(self, nums):\n        nums.sort()\n        if len(nums) >= 3 and nums[0] == nums[len(nums) - 1] and (nums[0] == 0):\n            return [[0, 0, 0]]\n        result = []\n        for index in range(len(nums) - 1):\n            left = index + 1\n            right = len(nums) - 1\n            while left < right:\n                currSum = nums[index] + nums[left] + nums[right]\n                if currSum == 0:\n                    result.append([nums[index], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                elif currSum < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return [list(t) for t in set((tuple(element) for element in result))]",
      "program_specification": "```dafny\nmodule ThreeSumModule {\n\n  method ThreeSum(nums: seq<int>) returns (res: seq<seq<int>>)\n    requires |nums| <= 1000 // reasonable bound for practical use\n    ensures forall t: seq<int> :: t in res ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n    ensures forall t: seq<int> :: t in res ==> forall i: int, j: int :: 0 <= i < 3 && 0 <= j < 3 && i != j ==> t[i] <= t[j] || t[j] <= t[i] // elements are ints, no order required\n    ensures forall i: int, j: int :: 0 <= i < |res| && 0 <= j < |res| && i != j ==> res[i] != res[j]\n    ensures forall t: seq<int> :: t in res ==> exists i: int, j: int, k: int :: 0 <= i < j < k < |nums| && t == [nums[i], nums[j], nums[k]]\n  {\n    var n := |nums|;\n    var sortedNums := nums[..];\n    // Sort the array\n    sortedNums := Sort(sortedNums);\n\n    if n >= 3 && sortedNums[0] == sortedNums[n-1] && sortedNums[0] == 0 {\n      res := [[0,0,0]];\n      return;\n    }\n\n    var resultSet := set seq<int>{};\n    var index: int := 0;\n    while index < n - 1\n      invariant 0 <= index <= n-1\n      invariant forall t: seq<int> :: t in resultSet ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n      invariant forall t: seq<int> :: t in resultSet ==> exists i: int, j: int, k: int :: 0 <= i < j < k < n && t == [sortedNums[i], sortedNums[j], sortedNums[k]]\n    {\n      var left := index + 1;\n      var right := n - 1;\n      while left < right\n        invariant index + 1 <= left <= right + 1 <= n\n        invariant forall t: seq<int> :: t in resultSet ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n        invariant forall t: seq<int> :: t in resultSet ==> exists i: int, j: int, k: int :: 0 <= i < j < k < n && t == [sortedNums[i], sortedNums[j], sortedNums[k]]\n      {\n        var currSum := sortedNums[index] + sortedNums[left] + sortedNums[right];\n        if currSum == 0 {\n          var triple := [sortedNums[index], sortedNums[left], sortedNums[right]];\n          resultSet := resultSet + {triple};\n          left := left + 1;\n          right := right - 1;\n        } else if currSum < 0 {\n          left := left + 1;\n        } else {\n          right := right - 1;\n        }\n      }\n      index := index + 1;\n    }\n    // Convert set to sequence\n    res := SetToSeq(resultSet);\n  }\n\n  // Helper: Sorts a sequence of ints in non-decreasing order\n  method Sort(s: seq<int>) returns (sorted: seq<int>)\n    ensures sorted == s[..] && (forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j])\n  {\n    var arr := s[..];\n    var n := |arr|;\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant arr[..] == Multiset(s)\n    {\n      var j := i + 1;\n      while j < n\n        invariant i+1 <= j <= n\n        invariant arr[..] == Multiset(s)\n      {\n        if arr[j] < arr[i] {\n          var tmp := arr[i];\n          arr[i] := arr[j];\n          arr[j] := tmp;\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    sorted := arr[..];\n  }\n\n  // Helper: Converts a set of sequences to a sequence (order not guaranteed)\n  function SetToSeq(s: set<seq<int>>): seq<seq<int>>\n    ensures forall t: seq<int> :: t in s <==> t in SetToSeq(s)\n    ensures |SetToSeq(s)| == |s|\n  {\n    if |s| == 0 then [] else\n      var e: seq<int> :| e in s;\n      [e] + SetToSeq(s - {e})\n  }\n\n  // Helper: Multiset for sorting invariant\n  function Multiset(s: seq<int>): seq<int>\n    ensures Multiset(s) == s\n  {\n    s\n  }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 18.279,
        "duration_formatted": "18.28s",
        "tokens": {
          "input": 462,
          "output": 1077,
          "total": 1539
        },
        "cost_usd": 0.00954,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:38:01.338758"
      }
    },
    {
      "file_path": "1-100q/16.py",
      "code": "class Solution(object):\n\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        result, min_diff = (0, float('inf'))\n        for index in range(len(nums) - 1):\n            left = index + 1\n            right = len(nums) - 1\n            while left < right:\n                currSum = nums[index] + nums[left] + nums[right]\n                diff = abs(target - currSum)\n                if diff == 0:\n                    return target\n                if diff < min_diff:\n                    min_diff = diff\n                    result = currSum\n                if currSum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return result",
      "program_specification": "```dafny\nmethod Abs(x: int) returns (res: int)\n    ensures res == if x >= 0 then x else -x\n{\n    if x >= 0 {\n        res := x;\n    } else {\n        res := -x;\n    }\n}\n\nmethod ThreeSumClosest(nums: array<int>, target: int) returns (result: int)\n    requires nums != null && nums.Length >= 3\n    ensures exists i, j, k :: 0 <= i < j < k < nums.Length && result == nums[i] + nums[j] + nums[k]\n    ensures forall i, j, k :: 0 <= i < j < k < nums.Length ==>\n        Abs(target - result) <= Abs(target - (nums[i] + nums[j] + nums[k]))\n{\n    // Make a copy to avoid mutating the input array\n    var arr := new int[nums.Length];\n    var i := 0;\n    while i < nums.Length\n        invariant 0 <= i <= nums.Length\n        invariant forall j :: 0 <= j < i ==> arr[j] == nums[j]\n    {\n        arr[i] := nums[i];\n        i := i + 1;\n    }\n\n    // Sort the array\n    Sort(arr);\n\n    var min_diff := int.Max;\n    var found := false;\n    var closest := 0;\n\n    var index := 0;\n    while index < arr.Length - 2\n        invariant 0 <= index <= arr.Length - 2\n        invariant !found ==> min_diff >= 0\n        invariant forall i', j', k' :: 0 <= i' < j' < k' < arr.Length && i' < index ==>\n            Abs(target - closest) <= Abs(target - (arr[i'] + arr[j'] + arr[k']))\n        decreases arr.Length - 2 - index\n    {\n        var left := index + 1;\n        var right := arr.Length - 1;\n        while left < right\n            invariant index + 1 <= left <= right <= arr.Length - 1\n            invariant !found ==> min_diff >= 0\n            invariant forall i', j', k' :: 0 <= i' < j' < k' < arr.Length &&\n                                   (i' < index ||\n                                    (i' == index && (j' < left || (j' == left && k' < right)))) ==>\n                Abs(target - closest) <= Abs(target - (arr[i'] + arr[j'] + arr[k']))\n            decreases right - left\n        {\n            var currSum := arr[index] + arr[left] + arr[right];\n            var diff := Abs(target - currSum);\n\n            if diff == 0 {\n                result := target;\n                return;\n            }\n            if diff < min_diff {\n                min_diff := diff;\n                closest := currSum;\n            }\n            if currSum < target {\n                left := left + 1;\n            } else {\n                right := right - 1;\n            }\n        }\n        index := index + 1;\n    }\n    result := closest;\n}\n\n// Simple insertion sort for arrays\nmethod Sort(a: array<int>)\n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var n := a.Length;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant forall k, l :: 0 <= k < l < i ==> a[k] <= a[l]\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        decreases n - i\n    {\n        var key := a[i];\n        var j := i - 1;\n        while j >= 0 && a[j] > key\n            invariant -1 <= j < i\n            invariant forall k :: j < k < i ==> a[k] > key\n            invariant multiset(a[..]) == multiset(old(a[..]))\n            decreases j + 1\n        {\n            a[j + 1] := a[j];\n            j := j - 1;\n        }\n        a[j + 1] := key;\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 12.534,
        "duration_formatted": "12.53s",
        "tokens": {
          "input": 421,
          "output": 899,
          "total": 1320
        },
        "cost_usd": 0.008034,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:38:23.875725"
      }
    },
    {
      "file_path": "1-100q/18.py",
      "code": "class Solution(object):\n\n    def fourSum(self, nums, target):\n        sumMapping = {}\n        for index_i in range(len(nums) - 1):\n            for index_j in range(index_i + 1, len(nums)):\n                currSum = nums[index_i] + nums[index_j]\n                if currSum in sumMapping:\n                    sumMapping[currSum].append((index_i, index_j))\n                else:\n                    sumMapping[currSum] = [(index_i, index_j)]\n        result = set()\n        for key, value in sumMapping.iteritems():\n            diff = target - key\n            if diff in sumMapping:\n                firstSet = value\n                secondSet = sumMapping[diff]\n                for i, j in firstSet:\n                    for k, l in secondSet:\n                        fourlet = [i, j, k, l]\n                        if len(set(fourlet)) != len(fourlet):\n                            continue\n                        fourlist = [nums[i], nums[j], nums[k], nums[l]]\n                        fourlist.sort()\n                        result.add(tuple(fourlist))\n        return list(result)",
      "program_specification": "```dafny\nimport Collections\n\nclass Solution {\n    method FourSum(nums: seq<int>, target: int) returns (result: seq<seq<int>>)\n        requires |nums| >= 0\n        ensures forall r :: r in result ==> |r| == 4\n        ensures forall r :: r in result ==> multiset(r) in multiset(nums)\n        ensures forall r :: r in result ==> sum(r) == target\n        ensures forall i, j :: 0 <= i < |result| && 0 <= j < |result| && i != j ==> result[i] != result[j]\n    {\n        var n := |nums|;\n        // sumMapping: map from sum of two elements to set of index pairs (i,j) with i < j\n        var sumMapping := map<int, set<(int,int)>>{};\n\n        // Build sumMapping\n        var index_i := 0;\n        while index_i < n - 1\n            invariant 0 <= index_i <= n-1\n            invariant forall s :: s in sumMapping ==> forall p :: p in sumMapping[s] ==> 0 <= p.0 < p.1 < n\n        {\n            var index_j := index_i + 1;\n            while index_j < n\n                invariant index_i + 1 <= index_j <= n\n                invariant forall s :: s in sumMapping ==> forall p :: p in sumMapping[s] ==> 0 <= p.0 < p.1 < n\n            {\n                var currSum := nums[index_i] + nums[index_j];\n                if currSum in sumMapping {\n                    sumMapping := sumMapping[currSum := sumMapping[currSum] + {(index_i, index_j)}];\n                } else {\n                    sumMapping := sumMapping[currSum := {(index_i, index_j)}];\n                }\n                index_j := index_j + 1;\n            }\n            index_i := index_i + 1;\n        }\n\n        var resultSet := set<seq<int>>{};\n\n        // For each key in sumMapping, look for complement to target\n        var keys := sumMapping.Keys;\n        var keyArr := keys.Elements;\n        var keyIdx := 0;\n        while keyIdx < |keyArr|\n            invariant 0 <= keyIdx <= |keyArr|\n            invariant forall r :: r in resultSet ==> |r| == 4 && sum(r) == target && multiset(r) in multiset(nums)\n        {\n            var key := keyArr[keyIdx];\n            var diff := target - key;\n            if diff in sumMapping {\n                var firstSet := sumMapping[key];\n                var secondSet := sumMapping[diff];\n                // For each pair in firstSet and secondSet\n                var firstArr := firstSet.Elements;\n                var secondArr := secondSet.Elements;\n                var i := 0;\n                while i < |firstArr|\n                    invariant 0 <= i <= |firstArr|\n                    invariant forall r :: r in resultSet ==> |r| == 4 && sum(r) == target && multiset(r) in multiset(nums)\n                {\n                    var j := 0;\n                    while j < |secondArr|\n                        invariant 0 <= j <= |secondArr|\n                        invariant forall r :: r in resultSet ==> |r| == 4 && sum(r) == target && multiset(r) in multiset(nums)\n                    {\n                        var (a, b) := firstArr[i];\n                        var (c, d) := secondArr[j];\n                        var indices := [a, b, c, d];\n                        if Distinct(indices) {\n                            var fourlist := [nums[a], nums[b], nums[c], nums[d]];\n                            fourlist := Sorted(fourlist);\n                            resultSet := resultSet + {fourlist};\n                        }\n                        j := j + 1;\n                    }\n                    i := i + 1;\n                }\n            }\n            keyIdx := keyIdx + 1;\n        }\n\n        // Convert set to sequence\n        result := resultSet.Elements;\n    }\n\n    // Helper: check if all elements in a sequence are distinct\n    function Distinct(s: seq<int>): bool\n        decreases s\n    {\n        |set x | x in s| == |s|\n    }\n\n    // Helper: sum of a sequence\n    function sum(s: seq<int>): int\n        decreases s\n    {\n        if |s| == 0 then 0 else s[0] + sum(s[1..])\n    }\n\n    // Helper: sorted copy of a sequence (ascending)\n    function Sorted(s: seq<int>): seq<int>\n        decreases s\n    {\n        if |s| == 0 then s\n        else\n            var m := min(s);\n            [m] + Sorted(RemoveFirst(s, m))\n    }\n\n    // Helper: remove first occurrence of v from s\n    function RemoveFirst(s: seq<int>, v: int): seq<int>\n        decreases s\n    {\n        if |s| == 0 then s\n        else if s[0] == v then s[1..]\n        else [s[0]] + RemoveFirst(s[1..], v)\n    }\n\n    // Helper: minimum of a non-empty sequence\n    function min(s: seq<int>): int\n        requires |s| > 0\n        decreases s\n    {\n        if |s| == 1 then s[0]\n        else if s[0] < min(s[1..]) then s[0] else min(s[1..])\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 16.726,
        "duration_formatted": "16.73s",
        "tokens": {
          "input": 499,
          "output": 1157,
          "total": 1656
        },
        "cost_usd": 0.010254,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:38:50.604344"
      }
    },
    {
      "file_path": "1-100q/23.py",
      "code": "class Solution(object):\n\n    def mergeKLists(self, lists):\n        from heapq import heappush, heappop\n        heap = []\n        head = point = ListNode(0)\n        for element in lists:\n            if element:\n                heapq.heappush(heap, (element.val, element))\n        while heap:\n            value, node = heapq.heappop(heap)\n            head.next = ListNode(value)\n            head = head.next\n            node = node.next\n            if node:\n                heapq.heappush(heap, (node.val, node))\n        return point.next\n\nclass Solution(object):\n\n    def mergeKLists(self, lists):\n\n        def merge2Lists(l1, l2):\n            head = point = ListNode(0)\n            while l1 and l2:\n                if l1.val <= l2.val:\n                    point.next = ListNode(l1.val)\n                    l1 = l1.next\n                else:\n                    point.next = ListNode(l2.val)\n                    l2 = l2.next\n                point = point.next\n            if l1:\n                point.next = l1\n            else:\n                point.next = l2\n            return head.next\n        if not lists:\n            return lists\n        interval = 1\n        while interval < len(lists):\n            for index in range(0, len(lists) - interval, interval * 2):\n                lists[index] = merge2Lists(lists[index], lists[index + interval])\n            interval *= 2\n        return lists[0]",
      "program_specification": "```dafny\n// Definition of singly-linked list node\nclass ListNode {\n    var val: int;\n    var next: ListNode?;\n\n    constructor(v: int, n: ListNode?)\n        ensures val == v && next == n\n    {\n        val := v;\n        next := n;\n    }\n}\n\n// Helper function: Converts a linked list to a sequence of integers\nfunction method ListToSeq(node: ListNode?): seq<int>\n{\n    if node == null then [] else [node.val] + ListToSeq(node.next)\n}\n\n// Helper function: Checks if a sequence is sorted non-decreasingly\nfunction method IsSorted(s: seq<int>): bool\n{\n    forall i :: 0 <= i < |s| - 1 ==> s[i] <= s[i+1]\n}\n\n// Helper function: Multiset of all elements in a sequence\nfunction method SeqToMultiset(s: seq<int>): multiset<int>\n{\n    if |s| == 0 then multiset{} else multiset{s[0]} + SeqToMultiset(s[1..])\n}\n\n// Merges two sorted linked lists into one sorted linked list\nmethod Merge2Lists(l1: ListNode?, l2: ListNode?) returns (merged: ListNode?)\n    requires IsSorted(ListToSeq(l1))\n    requires IsSorted(ListToSeq(l2))\n    ensures IsSorted(ListToSeq(merged))\n    ensures SeqToMultiset(ListToSeq(merged)) == SeqToMultiset(ListToSeq(l1)) + SeqToMultiset(ListToSeq(l2))\n{\n    var dummy := new ListNode(0, null);\n    var tail := dummy;\n    var a := l1;\n    var b := l2;\n\n    while a != null && b != null\n        invariant IsSorted(ListToSeq(dummy.next))\n        invariant SeqToMultiset(ListToSeq(dummy.next)) == SeqToMultiset(ListToSeq(l1)) + SeqToMultiset(ListToSeq(l2)) - SeqToMultiset(ListToSeq(a)) - SeqToMultiset(ListToSeq(b))\n        invariant tail != null\n        decreases |ListToSeq(a)| + |ListToSeq(b)|\n    {\n        if a.val <= b.val {\n            tail.next := new ListNode(a.val, null);\n            tail := tail.next;\n            a := a.next;\n        } else {\n            tail.next := new ListNode(b.val, null);\n            tail := tail.next;\n            b := b.next;\n        }\n    }\n    if a != null {\n        tail.next := a;\n    } else {\n        tail.next := b;\n    }\n    merged := dummy.next;\n}\n\n// Merges k sorted linked lists using pairwise merging (divide and conquer)\nmethod MergeKLists(lists: seq<ListNode?>) returns (merged: ListNode?)\n    requires forall l :: 0 <= l < |lists| ==> IsSorted(ListToSeq(lists[l]))\n    ensures IsSorted(ListToSeq(merged))\n    ensures SeqToMultiset(ListToSeq(merged)) == multiset m | 0 <= i < |lists| :: SeqToMultiset(ListToSeq(lists[i]))\n{\n    if |lists| == 0 {\n        merged := null;\n        return;\n    }\n    var interval := 1;\n    var arr := lists[..];\n    while interval < |arr|\n        invariant 1 <= interval <= |lists| || |lists| == 0\n        invariant |arr| == |lists|\n        invariant forall i :: 0 <= i < |arr| && arr[i] != null ==> IsSorted(ListToSeq(arr[i]))\n        invariant forall k :: 0 <= k < |lists| ==> SeqToMultiset(ListToSeq(arr[k])) == SeqToMultiset(ListToSeq(lists[k]))\n        decreases |lists| - interval\n    {\n        var i := 0;\n        while i < |arr| - interval\n            invariant 0 <= i <= |arr|\n            invariant forall j :: 0 <= j < i ==> arr[j] != null ==> IsSorted(ListToSeq(arr[j]))\n            decreases |arr| - i\n        {\n            arr[i] := Merge2Lists(arr[i], arr[i + interval]);\n            i := i + interval * 2;\n        }\n        interval := interval * 2;\n    }\n    merged := arr[0];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 14.785,
        "duration_formatted": "14.79s",
        "tokens": {
          "input": 592,
          "output": 903,
          "total": 1495
        },
        "cost_usd": 0.008408,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:39:15.394057"
      }
    },
    {
      "file_path": "1000-1100q/1043.py",
      "code": "class Solution(object):\n\n    def maxSumAfterPartitioning(self, A, K):\n        if not A:\n            return 0\n        N = len(A)\n        dp = [0] * (N + 1)\n        for index_i in range(N):\n            maxi = 0\n            for index_j in range(index_i, index_i - K, -1):\n                if index_j >= 0 and index_j < len(A):\n                    maxi = max(maxi, A[index_j])\n                    dp[index_i + 1] = max(dp[index_i + 1], maxi * (index_i - index_j + 1) + dp[index_j])\n        return dp[-1]",
      "program_specification": "```dafny\nmethod MaxSumAfterPartitioning(A: seq<int>, K: int) returns (result: int)\n    requires K > 0\n    requires |A| >= 0\n    ensures result >= 0\n    ensures |A| == 0 ==> result == 0\n    // For any partitioning of A into contiguous subarrays of length at most K,\n    // result is at least the sum of the maximal element of each subarray times its length\n    // (i.e., result >= the sum over each partition of max(subarray) * |subarray|)\n{\n    if |A| == 0 {\n        return 0;\n    }\n    var N := |A|;\n    var dp := new int[N + 1];\n    // dp[i] = the maximum sum for the prefix A[0..i-1]\n    dp[0] := 0;\n\n    var index_i: int := 0;\n    while index_i < N\n        invariant 0 <= index_i <= N\n        invariant dp[0] == 0\n        invariant forall j :: 0 <= j <= index_i ==> dp[j] >= 0\n        invariant forall j :: 0 <= j <= index_i ==> dp[j] <= dp[index_i]\n    {\n        var maxi := 0;\n        var index_j: int := index_i;\n        while index_j >= index_i - K + 1 && index_j >= 0\n            invariant index_i - K <= index_j <= index_i\n            invariant 0 <= index_j + 1 <= N\n            invariant 0 <= index_j <= index_i\n            invariant 0 <= maxi\n        {\n            if 0 <= index_j < N {\n                if A[index_j] > maxi {\n                    maxi := A[index_j];\n                }\n                var len := index_i - index_j + 1;\n                var candidate := dp[index_j] + maxi * len;\n                if candidate > dp[index_i + 1] {\n                    dp[index_i + 1] := candidate;\n                }\n            }\n            index_j := index_j - 1;\n        }\n        index_i := index_i + 1;\n    }\n    result := dp[N];\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 10.869,
        "duration_formatted": "10.87s",
        "tokens": {
          "input": 415,
          "output": 462,
          "total": 877
        },
        "cost_usd": 0.004526,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:39:36.267965"
      }
    },
    {
      "file_path": "1000-1100q/1087.py",
      "code": "class Solution(object):\n\n    def permute(self, S):\n        if not S:\n            return []\n        if '{' not in S:\n            return [S]\n        stack, stack2 = ([], [])\n        brace = 0\n        for char in S:\n            if char == '{':\n                brace = 1\n            elif char == '}':\n                if not stack:\n                    stack = stack2\n                else:\n                    new_stack = []\n                    for char in stack:\n                        for char2 in stack2:\n                            new_stack.append(char + char2)\n                    stack = new_stack\n                stack2 = []\n                brace = 2\n            elif char != ',':\n                if brace == 1:\n                    stack2.append(char)\n                elif brace == 2:\n                    stack = [c + char for c in stack]\n                    stack2 = []\n                else:\n                    stack.append(char)\n        stack.sort()\n        stack.sort(key=len)\n        return stack",
      "program_specification": "```dafny\nmethod Permute(S: string) returns (result: seq<string>)\n    requires true\n    ensures\n        // If S is empty, result is empty\n        S == \"\" ==> |result| == 0\n    ensures\n        // If S contains no '{', result is S itself\n        !('{ ' in S) ==> result == [S]\n    ensures\n        // All elements in result are of the same length as S with braces and commas removed\n        forall r :: r in result ==> |r| == |S| - CountBracesAndCommas(S)\n    ensures\n        // Result is sorted lexicographically and by length\n        forall i, j :: 0 <= i < j < |result| ==> (|result[i]| <= |result[j]| || (|result[i]| == |result[j]| && result[i] <= result[j]))\n{\n    if |S| == 0 {\n        result := [];\n        return;\n    }\n    if !Contains(S, '{') {\n        result := [S];\n        return;\n    }\n\n    var stack: seq<string> := [];\n    var stack2: seq<string> := [];\n    var brace: int := 0;\n    var i: int := 0;\n\n    while i < |S|\n        invariant 0 <= i <= |S|\n        invariant brace in [0, 1, 2]\n        invariant stack != null && stack2 != null\n        decreases |S| - i\n    {\n        var char := S[i..i+1];\n        if char == \"{\" {\n            brace := 1;\n        } else if char == \"}\" {\n            if |stack| == 0 {\n                stack := stack2;\n            } else {\n                var new_stack: seq<string> := [];\n                var k: int := 0;\n                while k < |stack|\n                    invariant 0 <= k <= |stack|\n                    invariant |new_stack| <= k * |stack2|\n                    decreases |stack| - k\n                {\n                    var l: int := 0;\n                    while l < |stack2|\n                        invariant 0 <= l <= |stack2|\n                        decreases |stack2| - l\n                    {\n                        new_stack := new_stack + [stack[k] + stack2[l]];\n                        l := l + 1;\n                    }\n                    k := k + 1;\n                }\n                stack := new_stack;\n            }\n            stack2 := [];\n            brace := 2;\n        } else if char != \",\" {\n            if brace == 1 {\n                stack2 := stack2 + [char];\n            } else if brace == 2 {\n                var m: int := 0;\n                var new_stack: seq<string> := [];\n                while m < |stack|\n                    invariant 0 <= m <= |stack|\n                    decreases |stack| - m\n                {\n                    new_stack := new_stack + [stack[m] + char];\n                    m := m + 1;\n                }\n                stack := new_stack;\n                stack2 := [];\n            } else {\n                stack := stack + [char];\n            }\n        }\n        i := i + 1;\n    }\n\n    // Sort stack lexicographically\n    stack := LexSort(stack);\n    // Sort stack by length\n    stack := LengthSort(stack);\n\n    result := stack;\n}\n\n// Helper function: check if a character is in a string\nfunction Contains(s: string, c: char): bool\n{\n    exists i :: 0 <= i < |s| && s[i] == c\n}\n\n// Helper function: count braces and commas in S\nfunction CountBracesAndCommas(s: string): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == '{' || s[0] == '}' || s[0] == ',' then 1 else 0) + CountBracesAndCommas(s[1..])\n}\n\n// Lexicographical sort (simple bubble sort for demonstration)\nfunction LexSort(a: seq<string>): seq<string>\n    decreases |a|\n{\n    if |a| <= 1 then a\n    else\n        var minIdx := 0;\n        var i := 1;\n        while i < |a|\n            invariant 1 <= i <= |a|\n            invariant 0 <= minIdx < |a|\n            decreases |a| - i\n        {\n            if a[i] < a[minIdx] {\n                minIdx := i;\n            }\n            i := i + 1;\n        }\n        [a[minIdx]] + LexSort(a[0..minIdx] + a[minIdx+1..])\n}\n\n// Length sort (stable, by increasing length)\nfunction LengthSort(a: seq<string>): seq<string>\n    decreases |a|\n{\n    if |a| <= 1 then a\n    else\n        var minIdx := 0;\n        var i := 1;\n        while i < |a|\n            invariant 1 <= i <= |a|\n            invariant 0 <= minIdx < |a|\n            decreases |a| - i\n        {\n            if |a[i]| < |a[minIdx]| {\n                minIdx := i;\n            }\n            i := i + 1;\n        }\n        [a[minIdx]] + LengthSort(a[0..minIdx] + a[minIdx+1..])\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 18.057,
        "duration_formatted": "18.06s",
        "tokens": {
          "input": 469,
          "output": 1118,
          "total": 1587
        },
        "cost_usd": 0.009882,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:40:04.328667"
      }
    },
    {
      "file_path": "1200-1300q/1277.py",
      "code": "class Solution(object):\n\n    def countSquares(self, matrix):\n        p_arr = [[0 for i in range(len(matrix[0]))] for j in range(len(matrix))]\n        result = 0\n        for index_i in range(1, len(matrix)):\n            for index_j in range(1, len(matrix[0])):\n                if matrix[index_i][index_j] == 1:\n                    matrix[index_i][index_j] = min(matrix[index_i - 1][index_j - 1], min(matrix[index_i - 1][index_j], matrix[index_i][index_j - 1])) + 1\n        return sum([sum(x) for x in matrix])",
      "program_specification": "```dafny\nmethod CountSquares(matrix: array2<int>) returns (result: int)\n    requires matrix != null\n    requires matrix.Length > 0\n    requires forall i :: 0 <= i < matrix.Length ==> matrix[i] != null && matrix[i].Length == matrix[0].Length\n    requires forall i, j :: 0 <= i < matrix.Length && 0 <= j < matrix[0].Length ==> matrix[i][j] == 0 || matrix[i][j] == 1\n    modifies matrix\n    ensures result == CountAllSquares(Old(matrix[..][..]), matrix.Length, matrix[0].Length)\n{\n    var n := matrix.Length;\n    var m := matrix[0].Length;\n\n    // The algorithm modifies the input matrix in-place.\n    // For each cell (i, j) with i > 0 and j > 0 and matrix[i][j] == 1,\n    // set matrix[i][j] = min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]) + 1\n\n    var i: int := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant forall ii, jj :: 1 <= ii < i && 1 <= jj < m ==>\n            matrix[ii][jj] >= 1 ==>\n                matrix[ii][jj] == 1 + Min3(matrix[ii-1][jj-1], matrix[ii-1][jj], matrix[ii][jj-1])\n        invariant forall ii, jj :: 0 <= ii < n && 0 <= jj < m && (ii < 1 || jj < 1) ==> matrix[ii][jj] == 0 || matrix[ii][jj] == 1\n    {\n        var j: int := 1;\n        while j < m\n            invariant 1 <= j <= m\n            invariant forall jj :: 1 <= jj < j ==>\n                matrix[i][jj] >= 1 ==>\n                    matrix[i][jj] == 1 + Min3(matrix[i-1][jj-1], matrix[i-1][jj], matrix[i][jj-1])\n            invariant forall jj :: 0 <= jj < m && (i < 1 || jj < 1) ==> matrix[i][jj] == 0 || matrix[i][jj] == 1\n        {\n            if matrix[i][j] == 1 {\n                matrix[i][j] := 1 + Min3(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]);\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n\n    // Now sum all values in matrix\n    var total: int := 0;\n    i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant total == SumMatrix(matrix, i, m)\n    {\n        var j: int := 0;\n        while j < m\n            invariant 0 <= j <= m\n            invariant total == SumMatrix(matrix, i, m) + SumRow(matrix[i], j)\n        {\n            total := total + matrix[i][j];\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    result := total;\n}\n\n// Helper function to compute the minimum of three integers\nfunction Min3(a: int, b: int, c: int): int\n    ensures Min3(a, b, c) == if a <= b && a <= c then a else if b <= a && b <= c then b else c\n{\n    if a <= b && a <= c then a\n    else if b <= a && b <= c then b\n    else c\n}\n\n// Helper function to sum all elements in matrix up to row i (exclusive)\nfunction SumMatrix(matrix: array2<int>, uptoRow: int, m: int): int\n    requires matrix != null && matrix.Length >= uptoRow\n    requires forall ii :: 0 <= ii < matrix.Length ==> matrix[ii] != null && matrix[ii].Length == m\n{\n    if uptoRow == 0 then 0\n    else SumMatrix(matrix, uptoRow - 1, m) + SumRow(matrix[uptoRow - 1], m)\n}\n\n// Helper function to sum all elements in a row up to column m (exclusive)\nfunction SumRow(row: array<int>, uptoCol: int): int\n    requires row != null && row.Length >= uptoCol\n{\n    if uptoCol == 0 then 0\n    else SumRow(row, uptoCol - 1) + row[uptoCol - 1]\n}\n\n// Specification function: computes the total number of square submatrices with all ones\nfunction CountAllSquares(orig: seq<seq<int>>, n: int, m: int): int\n    requires forall i :: 0 <= i < n ==> |orig[i]| == m\n    requires |orig| == n\n{\n    if n == 0 || m == 0 then 0\n    else\n        var dp := SquareDP(orig, n, m);\n        SumSeqSeq(dp)\n}\n\n// Helper function: builds the DP table as a sequence of sequences\nfunction SquareDP(orig: seq<seq<int>>, n: int, m: int): seq<seq<int>>\n    requires forall i :: 0 <= i < n ==> |orig[i]| == m\n    requires |orig| == n\n    decreases n\n{\n    if n == 0 then []\n    else\n        var prev := SquareDP(orig[..n-1], n-1, m);\n        var row := SquareDPRow(orig, prev, n-1, m);\n        prev + [row]\n}\n\n// Helper function: builds a DP row\nfunction SquareDPRow(orig: seq<seq<int>>, prev: seq<seq<int>>, i: int, m: int): seq<int>\n    requires |orig| > i\n    requires |orig[i]| == m\n    requires |prev| == i\n{\n    if m == 0 then []\n    else\n        var left := SquareDPRow(orig, prev, i, m-1);\n        var val :=\n            if orig[i][m-1] == 0 then 0\n            else if i == 0 || m-1 == 0 then orig[i][m-1]\n            else 1 + Min3(prev[i-1][m-2], prev[i-1][m-1], left[m-2]);\n        left + [val]\n}\n\n// Helper function: sum all elements in a sequence of sequences\nfunction SumSeqSeq(s: seq<seq<int>>): int\n{\n    if |s| == 0 then 0\n    else SumSeqSeq(s[..|s|-1]) + SumSeq(s[|s|-1])\n}\n\n// Helper function: sum all elements in a sequence\nfunction SumSeq(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else SumSeq(s[..|s|-1]) + s[|s|-1]\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 23.476,
        "duration_formatted": "23.48s",
        "tokens": {
          "input": 413,
          "output": 1499,
          "total": 1912
        },
        "cost_usd": 0.012818,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:40:37.807549"
      }
    },
    {
      "file_path": "1200-1300q/1291.py",
      "code": "class Solution(object):\n\n    def sequentialDigits(self, low, high):\n        result = []\n        start = int(str(low)[0])\n        for val in range(1, len(str(low))):\n            new_val = start % 10 + 1\n            start = start * 10 + new_val\n        if start > high:\n            return result\n        result.append(start)\n        while result[-1] <= high:\n            temp = str(result[-1])\n            next_elem = int(temp[-1]) + 1\n            if next_elem > 9:\n                next_greater = 0\n                for index in range(len(temp) + 1):\n                    next_greater = next_greater * 10 + (index + 1)\n            else:\n                next_greater = int(temp[1:]) * 10 + next_elem\n            if next_greater <= high:\n                result.append(next_greater)\n            else:\n                break\n        final_result = []\n        for val in result:\n            if '0' not in str(val) and val >= low:\n                final_result.append(val)\n        return final_result",
      "program_specification": "```dafny\nmethod SequentialDigits(low: int, high: int) returns (final_result: seq<int>)\n    requires 0 < low <= high\n    ensures forall x :: x in final_result ==> SequentialDigitsProperty(x, low, high)\n    ensures forall x :: SequentialDigitsProperty(x, low, high) ==> x in final_result\n    ensures StrictlyIncreasing(final_result)\n{\n    var result := new seq<int>[];\n    var start := FirstDigit(low);\n    var lowStr := IntToString(low);\n    var lenLow := |lowStr|;\n    // Build the initial sequential number with the same number of digits as low\n    var tempStart := start;\n    var i := 1;\n    while i < lenLow\n        invariant 1 <= i <= lenLow\n        invariant tempStart == BuildSequential(start, i)\n    {\n        var new_val := (tempStart % 10) + 1;\n        tempStart := tempStart * 10 + new_val;\n        i := i + 1;\n    }\n    start := tempStart;\n    if start > high {\n        final_result := [];\n        return;\n    }\n    result := result + [start];\n    // Generate next sequential digits numbers\n    while result[|result|-1] <= high\n        invariant |result| > 0\n        invariant forall j :: 0 <= j < |result| ==> IsSequential(result[j])\n        invariant StrictlyIncreasing(result)\n        decreases high - result[|result|-1]\n    {\n        var last := result[|result|-1];\n        var lastStr := IntToString(last);\n        var next_elem := StringToInt(Substring(lastStr, |lastStr|-1, |lastStr|)) + 1;\n        var next_greater: int;\n        if next_elem > 9 {\n            // Build the next sequential number with one more digit, starting from 1\n            next_greater := 0;\n            var idx := 0;\n            while idx < |lastStr| + 1\n                invariant 0 <= idx <= |lastStr| + 1\n                invariant next_greater == BuildSequential(1, idx)\n            {\n                next_greater := next_greater * 10 + (idx + 1);\n                idx := idx + 1;\n            }\n        } else {\n            // Shift left and append next_elem\n            var rest := Substring(lastStr, 1, |lastStr|);\n            next_greater := StringToInt(rest) * 10 + next_elem;\n        }\n        if next_greater <= high {\n            result := result + [next_greater];\n        } else {\n            break;\n        }\n    }\n    // Filter out numbers with '0' and less than low\n    var temp_result := new seq<int>[];\n    var k := 0;\n    while k < |result|\n        invariant 0 <= k <= |result|\n        invariant forall j :: 0 <= j < |temp_result| ==> '0' !in IntToString(temp_result[j]) && temp_result[j] >= low\n        invariant |temp_result| <= |result|\n    {\n        var val := result[k];\n        if '0' !in IntToString(val) && val >= low {\n            temp_result := temp_result + [val];\n        }\n        k := k + 1;\n    }\n    final_result := temp_result;\n}\n\n// Helper: Returns the first digit of a positive integer\nfunction FirstDigit(n: int): int\n    requires n > 0\n    ensures 1 <= FirstDigit(n) <= 9\n{\n    if n < 10 then n else FirstDigit(n / 10)\n}\n\n// Helper: Builds a sequential number starting from 'start', with 'len' digits\nfunction BuildSequential(start: int, len: int): int\n    requires 1 <= start <= 9\n    requires 0 <= len\n    decreases len\n{\n    if len == 0 then start\n    else BuildSequential(start, len - 1) * 10 + ((BuildSequential(start, len - 1) % 10) + 1)\n}\n\n// Helper: Checks if a number is a sequential digits number (no '0', digits increase by 1)\nfunction IsSequential(n: int): bool\n    requires n > 0\n{\n    var s := IntToString(n);\n    (forall i :: 0 <= i < |s|-1 ==> s[i+1] == (s[i] as int + 1) as char) &&\n    (forall i :: 0 <= i < |s| ==> s[i] != '0')\n}\n\n// Helper: Returns true if the sequence is strictly increasing\nfunction StrictlyIncreasing(a: seq<int>): bool\n{\n    forall i :: 0 <= i < |a|-1 ==> a[i] < a[i+1]\n}\n\n// Helper: Converts int to string (Dafny built-in)\nfunction IntToString(n: int): string\n    requires n >= 0\n{\n    n as string\n}\n\n// Helper: Converts string to int (Dafny built-in)\nfunction StringToInt(s: string): int\n    requires s != \"\"\n    requires forall c :: 0 <= c < |s| ==> '0' <= s[c] <= '9'\n{\n    if |s| == 1 then s[0] as int - '0' as int\n    else StringToInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\n// Helper: Returns substring s[from..to)\nfunction Substring(s: string, from: int, to: int): string\n    requires 0 <= from <= to <= |s|\n{\n    s[from..to]\n}\n\n// Helper: Checks if character c is in string s\nfunction method 'in'(c: char, s: string): bool\n{\n    exists i :: 0 <= i < |s| && s[i] == c\n}\n\n// Property: x is a sequential digits number in [low, high]\npredicate SequentialDigitsProperty(x: int, low: int, high: int)\n{\n    low <= x <= high &&\n    IsSequential(x)\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 18.763,
        "duration_formatted": "18.76s",
        "tokens": {
          "input": 506,
          "output": 1297,
          "total": 1803
        },
        "cost_usd": 0.011388,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:41:06.577715"
      }
    },
    {
      "file_path": "Python/3sum-closest.py",
      "code": "class Solution(object):\n\n    def threeSumClosest(self, nums, target):\n        result, min_diff = (0, float('inf'))\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                continue\n            left, right = (0, i - 1)\n            while left < right:\n                total = nums[left] + nums[right] + nums[i]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    return target\n                if abs(total - target) < min_diff:\n                    min_diff = abs(total - target)\n                    result = total\n        return result",
      "program_specification": "```dafny\nmethod ThreeSumClosest(nums: array<int>, target: int) returns (result: int)\n    requires nums != null && nums.Length >= 3\n    ensures exists i, j, k :: 0 <= i < j < k < nums.Length && result == nums[i] + nums[j] + nums[k]\n    ensures forall i, j, k :: 0 <= i < j < k < nums.Length ==>\n        abs(nums[i] + nums[j] + nums[k] - target) >= abs(result - target)\n{\n    var n := nums.Length;\n    // Make a copy to avoid mutating the input array\n    var arr := new int[n];\n    var idx := 0;\n    while idx < n\n        invariant 0 <= idx <= n\n        invariant forall j :: 0 <= j < idx ==> arr[j] == nums[j]\n    {\n        arr[idx] := nums[idx];\n        idx := idx + 1;\n    }\n\n    // Sort arr in non-decreasing order\n    Sort(arr);\n\n    var min_diff := int.Max;\n    result := 0;\n\n    var i := n - 1;\n    while i >= 2\n        invariant 2 <= n\n        invariant 2 <= i + 1 <= n\n        invariant forall ii :: i < ii < n ==> \n            forall l, r :: 0 <= l < r < ii ==>\n                abs(arr[l] + arr[r] + arr[ii] - target) >= min_diff\n        decreases i\n    {\n        if i + 1 < n && arr[i] == arr[i + 1] {\n            i := i - 1;\n            continue;\n        }\n        var left := 0;\n        var right := i - 1;\n        while left < right\n            invariant 0 <= left <= right <= i - 1 < n\n            invariant forall l, r :: 0 <= l < r < i ==>\n                (l < left || r > right) ==> abs(arr[l] + arr[r] + arr[i] - target) >= min_diff\n            decreases right - left\n        {\n            var total := arr[left] + arr[right] + arr[i];\n            if total < target {\n                left := left + 1;\n            } else if total > target {\n                right := right - 1;\n            } else {\n                result := target;\n                return;\n            }\n            if abs(total - target) < min_diff {\n                min_diff := abs(total - target);\n                result := total;\n            }\n        }\n        i := i - 1;\n    }\n}\n\n// Helper: absolute value\nfunction abs(x: int): int\n{\n    if x < 0 then -x else x\n}\n\n// Helper: in-place sort (Selection Sort for simplicity)\nmethod Sort(a: array<int>)\n    requires a != null\n    modifies a\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n{\n    var n := a.Length;\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall k, l :: 0 <= k < l < i ==> a[k] <= a[l]\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        decreases n - i\n    {\n        var minIdx := i;\n        var j := i + 1;\n        while j < n\n            invariant i + 1 <= j <= n\n            invariant i <= minIdx < n\n            invariant forall k :: i <= k < j ==> a[minIdx] <= a[k]\n            decreases n - j\n        {\n            if a[j] < a[minIdx] {\n                minIdx := j;\n            }\n            j := j + 1;\n        }\n        if minIdx != i {\n            var tmp := a[i];\n            a[i] := a[minIdx];\n            a[minIdx] := tmp;\n        }\n        i := i + 1;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 11.797,
        "duration_formatted": "11.80s",
        "tokens": {
          "input": 436,
          "output": 856,
          "total": 1292
        },
        "cost_usd": 0.00772,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:41:28.378383"
      }
    },
    {
      "file_path": "Python/abbreviating-the-product-of-a-range.py",
      "code": "import math\n\nclass Solution(object):\n\n    def abbreviateProduct(self, left, right):\n        PREFIX_LEN = SUFFIX_LEN = 5\n        MOD = 10 ** (PREFIX_LEN + SUFFIX_LEN)\n        curr, zeros = (1, 0)\n        abbr = False\n        for i in xrange(left, right + 1):\n            curr *= i\n            while not curr % 10:\n                curr //= 10\n                zeros += 1\n            q, curr = divmod(curr, MOD)\n            if q:\n                abbr = True\n        if not abbr:\n            return '%se%s' % (curr, zeros)\n        decimal = reduce(lambda x, y: (x + y) % 1, (math.log10(i) for i in xrange(left, right + 1)))\n        prefix = str(int(10 ** (decimal + (PREFIX_LEN - 1))))\n        suffix = str(curr % 10 ** SUFFIX_LEN).zfill(SUFFIX_LEN)\n        return '%s...%se%s' % (prefix, suffix, zeros)",
      "program_specification": "```dafny\nimport opened Math\n\nclass Solution {\n    const PREFIX_LEN: int := 5;\n    const SUFFIX_LEN: int := 5;\n    const MOD: int := 10000000000; // 10^(PREFIX_LEN + SUFFIX_LEN)\n\n    method AbbreviateProduct(left: int, right: int) returns (result: string)\n        requires left >= 1 && right >= left\n        ensures result != \"\"\n        // The result is a string representation of the product of all integers from left to right, \n        // either in full (if not abbreviated), or in abbreviated form with prefix, suffix, and exponent.\n    {\n        var curr: int := 1;\n        var zeros: int := 0;\n        var abbr: bool := false;\n\n        var i: int := left;\n        while i <= right\n            invariant left <= i <= right + 1\n            invariant curr > 0\n            invariant zeros >= 0\n        {\n            curr := curr * i;\n\n            // Remove trailing zeros from curr and count them\n            while curr % 10 == 0 && curr != 0\n                invariant curr >= 0\n                invariant zeros >= 0\n            {\n                curr := curr / 10;\n                zeros := zeros + 1;\n            }\n\n            // Abbreviate curr if it grows too large\n            var q: int := curr / MOD;\n            curr := curr % MOD;\n            if q > 0 {\n                abbr := true;\n            }\n\n            i := i + 1;\n        }\n\n        if !abbr {\n            // No abbreviation needed, return full product with exponent\n            result := curr.ToString() + \"e\" + zeros.ToString();\n            return;\n        }\n\n        // Compute decimal part for prefix using logs\n        var decimal: real := 0.0;\n        i := left;\n        while i <= right\n            invariant left <= i <= right + 1\n            invariant decimal >= 0.0\n        {\n            decimal := (decimal + Log10(i as real)) % 1.0;\n            i := i + 1;\n        }\n\n        // Compute prefix\n        var prefix_real: real := Pow(10.0, decimal + (PREFIX_LEN - 1) as real);\n        var prefix_int: int := prefix_real.Floor as int;\n        var prefix: string := prefix_int.ToString();\n\n        // Compute suffix\n        var ten_pow_suffix: int := 1;\n        var j: int := 0;\n        while j < SUFFIX_LEN\n            invariant 0 <= j <= SUFFIX_LEN\n            invariant ten_pow_suffix == Pow(10, j)\n        {\n            ten_pow_suffix := ten_pow_suffix * 10;\n            j := j + 1;\n        }\n        var suffix_int: int := curr % ten_pow_suffix;\n        var suffix: string := PadZeros(suffix_int, SUFFIX_LEN);\n\n        result := prefix + \"...\" + suffix + \"e\" + zeros.ToString();\n    }\n\n    // Helper method to pad integer with leading zeros to a given length\n    method PadZeros(n: int, length: int) returns (s: string)\n        requires n >= 0 && length >= 0\n        ensures |s| == length\n        ensures forall i :: 0 <= i < length - n.ToString().Length ==> s[i] == '0'\n        ensures s[length - n.ToString().Length..] == n.ToString()\n    {\n        var s0 := n.ToString();\n        var pad := length - |s0|;\n        s := \"\";\n        var i := 0;\n        while i < pad\n            invariant 0 <= i <= pad\n            invariant |s| == i\n        {\n            s := s + \"0\";\n            i := i + 1;\n        }\n        s := s + s0;\n    }\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 13.341,
        "duration_formatted": "13.34s",
        "tokens": {
          "input": 500,
          "output": 810,
          "total": 1310
        },
        "cost_usd": 0.00748,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:41:51.721684"
      }
    },
    {
      "file_path": "Python/add-binary.py",
      "code": "class Solution(object):\n\n    def addBinary(self, a, b):\n        result, carry, val = ('', 0, 0)\n        for i in xrange(max(len(a), len(b))):\n            val = carry\n            if i < len(a):\n                val += int(a[-(i + 1)])\n            if i < len(b):\n                val += int(b[-(i + 1)])\n            carry, val = divmod(val, 2)\n            result += str(val)\n        if carry:\n            result += str(carry)\n        return result[::-1]\nfrom itertools import izip_longest\n\nclass Solution2(object):\n\n    def addBinary(self, a, b):\n        result = ''\n        carry = 0\n        for x, y in izip_longest(reversed(a), reversed(b), fillvalue='0'):\n            carry, remainder = divmod(int(x) + int(y) + carry, 2)\n            result += str(remainder)\n        if carry:\n            result += str(carry)\n        return result[::-1]",
      "program_specification": "```dafny\nmodule BinaryAddition {\n\n  // Helper function: Converts a binary string to its integer value\n  function method BinStrToInt(s: seq<char>): int\n    requires forall c :: c in s ==> c == '0' || c == '1'\n    ensures BinStrToInt(s) >= 0\n    ensures s == [] ==> BinStrToInt(s) == 0\n    decreases s\n  {\n    if |s| == 0 then 0\n    else 2 * BinStrToInt(s[..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0)\n  }\n\n  // Helper function: Converts an integer to its binary string representation (no leading zeros, except for \"0\")\n  function method IntToBinStr(n: int): seq<char>\n    requires n >= 0\n    ensures forall c :: c in IntToBinStr(n) ==> c == '0' || c == '1'\n    ensures BinStrToInt(IntToBinStr(n)) == n\n    ensures IntToBinStr(0) == ['0']\n    decreases n\n  {\n    if n == 0 then ['0']\n    else\n      var s := IntToBinStr(n / 2);\n      if n / 2 == 0 then [if n % 2 == 1 then '1' else '0']\n      else s + [if n % 2 == 1 then '1' else '0']\n  }\n\n  // Helper function: Removes leading zeros from a binary string, except for \"0\"\n  function method StripLeadingZeros(s: seq<char>): seq<char>\n    requires forall c :: c in s ==> c == '0' || c == '1'\n    ensures |StripLeadingZeros(s)| > 0\n    ensures BinStrToInt(StripLeadingZeros(s)) == BinStrToInt(s)\n    decreases s\n  {\n    if |s| == 0 then ['0']\n    else if s[0] == '0' && |s| > 1 then StripLeadingZeros(s[1..])\n    else s\n  }\n\n  // Helper function: Reverses a sequence\n  function method Reverse(s: seq<char>): seq<char>\n    ensures |Reverse(s)| == |s|\n    ensures forall i :: 0 <= i < |s| ==> Reverse(s)[i] == s[|s|-1-i]\n    decreases s\n  {\n    if |s| == 0 then []\n    else [s[|s|-1]] + Reverse(s[..|s|-1])\n  }\n\n  // Main method: Adds two binary strings and returns their sum as a binary string\n  method AddBinary(a: seq<char>, b: seq<char>) returns (result: seq<char>)\n    requires forall c :: c in a ==> c == '0' || c == '1'\n    requires forall c :: c in b ==> c == '0' || c == '1'\n    ensures forall c :: c in result ==> c == '0' || c == '1'\n    ensures BinStrToInt(result) == BinStrToInt(a) + BinStrToInt(b)\n    ensures |result| >= 1\n    ensures result == StripLeadingZeros(result)\n  {\n    var n := if |a| > |b| then |a| else |b|;\n    var carry := 0;\n    var res: seq<char> := [];\n    var i := 0;\n\n    while i < n\n      invariant 0 <= i <= n\n      invariant carry >= 0 && carry <= 1\n      invariant |res| == i\n      invariant forall c :: c in res ==> c == '0' || c == '1'\n      invariant BinStrToInt(Reverse(res)) + carry * (1 << i) == BinStrToInt(a[^i..]) + BinStrToInt(b[^i..])\n    {\n      var val := carry;\n      if i < |a| {\n        if a[|a|-1-i] == '1' {\n          val := val + 1;\n        }\n      }\n      if i < |b| {\n        if b[|b|-1-i] == '1' {\n          val := val + 1;\n        }\n      }\n      carry := val / 2;\n      var digit := if val % 2 == 1 then '1' else '0';\n      res := res + [digit];\n      i := i + 1;\n    }\n    if carry != 0 {\n      res := res + ['1'];\n    }\n    // Reverse and strip leading zeros\n    result := StripLeadingZeros(Reverse(res));\n  }\n\n  // Alternative method: Adds two binary strings using \"zip longest\" style\n  method AddBinaryZipLongest(a: seq<char>, b: seq<char>) returns (result: seq<char>)\n    requires forall c :: c in a ==> c == '0' || c == '1'\n    requires forall c :: c in b ==> c == '0' || c == '1'\n    ensures forall c :: c in result ==> c == '0' || c == '1'\n    ensures BinStrToInt(result) == BinStrToInt(a) + BinStrToInt(b)\n    ensures |result| >= 1\n    ensures result == StripLeadingZeros(result)\n  {\n    var n := if |a| > |b| then |a| else |b|;\n    var carry := 0;\n    var res: seq<char> := [];\n    var i := 0;\n\n    while i < n\n      invariant 0 <= i <= n\n      invariant carry >= 0 && carry <= 1\n      invariant |res| == i\n      invariant forall c :: c in res ==> c == '0' || c == '1'\n      invariant BinStrToInt(Reverse(res)) + carry * (1 << i) == BinStrToInt(a[^i..]) + BinStrToInt(b[^i..])\n    {\n      var x := if i < |a| then a[|a|-1-i] else '0';\n      var y := if i < |b| then b[|b|-1-i] else '0';\n      var sum := (if x == '1' then 1 else 0) + (if y == '1' then 1 else 0) + carry;\n      carry := sum / 2;\n      var remainder := if sum % 2 == 1 then '1' else '0';\n      res := res + [remainder];\n      i := i + 1;\n    }\n    if carry != 0 {\n      res := res + ['1'];\n    }\n    result := StripLeadingZeros(Reverse(res));\n  }\n\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 17.785,
        "duration_formatted": "17.78s",
        "tokens": {
          "input": 492,
          "output": 1429,
          "total": 1921
        },
        "cost_usd": 0.012416,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:42:19.508651"
      }
    },
    {
      "file_path": "Python/add-edges-to-make-degrees-of-all-nodes-even.py",
      "code": "class Solution(object):\n\n    def isPossible(self, n, edges):\n        adj = [set() for _ in xrange(n)]\n        for u, v in edges:\n            adj[u - 1].add(v - 1)\n            adj[v - 1].add(u - 1)\n        odds = [u for u in xrange(n) if len(adj[u]) % 2]\n        if len(odds) == 0:\n            return True\n        if len(odds) == 2:\n            return any((odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n)))\n        if len(odds) == 4:\n            return odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]] or (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]])\n        return False",
      "program_specification": "```dafny\nmethod IsPossible(n: int, edges: seq<seq<int>>) returns (result: bool)\n    requires n >= 0\n    requires forall e :: e in edges ==> |e| == 2 && 1 <= e[0] <= n && 1 <= e[1] <= n && e[0] != e[1]\n    ensures result == \n        // There exists a way to add at most two edges to make all degrees even\n        (exists adj0: seq<set<int>> ::\n            |adj0| == n &&\n            // Build initial adjacency sets\n            (forall i :: 0 <= i < n ==>\n                adj0[i] == set j | 0 <= j < n && (exists e :: e in edges && ((e[0] - 1 == i && e[1] - 1 == j) || (e[1] - 1 == i && e[0] - 1 == j)))\n            ) &&\n            // Compute odds\n            var odds := [i | i := 0 .. n-1, |adj0[i]| % 2 == 1];\n            if |odds| == 0 then true\n            else if |odds| == 2 then\n                exists u: int, v: int :: u in 0..n-1 && v in 0..n-1 && u != v && odds[0] != u && odds[1] != v && !(u in adj0[odds[0]]) && !(v in adj0[odds[1]])\n            else if |odds| == 4 then\n                ( !(odds[1] in adj0[odds[0]]) && !(odds[3] in adj0[odds[2]]) ) ||\n                ( !(odds[2] in adj0[odds[0]]) && !(odds[3] in adj0[odds[1]]) ) ||\n                ( !(odds[3] in adj0[odds[0]]) && !(odds[2] in adj0[odds[1]]) )\n            else false\n        )\n{\n    // Build adjacency sets: adj[i] is the set of neighbors of node i (0-based)\n    var adj := new seq<set<int>>(n, set []);\n    var i: int := 0;\n    while i < |edges|\n        invariant 0 <= i <= |edges|\n        invariant |adj| == n\n        invariant forall j :: 0 <= j < n ==> adj[j] <= set k | 0 <= k < n\n    {\n        var u := edges[i][0] - 1;\n        var v := edges[i][1] - 1;\n        adj[u] := adj[u] + {v};\n        adj[v] := adj[v] + {u};\n        i := i + 1;\n    }\n\n    // Compute odds: nodes with odd degree\n    var odds := [];\n    var j: int := 0;\n    while j < n\n        invariant 0 <= j <= n\n        invariant odds == [k | k := 0 .. j-1, |adj[k]| % 2 == 1]\n    {\n        if |adj[j]| % 2 == 1 {\n            odds := odds + [j];\n        }\n        j := j + 1;\n    }\n\n    if |odds| == 0 {\n        result := true;\n        return;\n    }\n    if |odds| == 2 {\n        // Try to find a node u such that both odds[0] and odds[1] are not connected to u\n        var found := false;\n        var u: int := 0;\n        while u < n\n            invariant 0 <= u <= n\n            invariant !found ==> forall k :: 0 <= k < u ==> (odds[0] in adj[k] || odds[1] in adj[k])\n        {\n            if !(odds[0] in adj[u]) && !(odds[1] in adj[u]) && u != odds[0] && u != odds[1] {\n                found := true;\n                break;\n            }\n            u := u + 1;\n        }\n        result := found;\n        return;\n    }\n    if |odds| == 4 {\n        // Try all three possible pairings\n        var cond1 := !(odds[1] in adj[odds[0]]) && !(odds[3] in adj[odds[2]]);\n        var cond2 := !(odds[2] in adj[odds[0]]) && !(odds[3] in adj[odds[1]]);\n        var cond3 := !(odds[3] in adj[odds[0]]) && !(odds[2] in adj[odds[1]]);\n        result := cond1 || cond2 || cond3;\n        return;\n    }\n    result := false;\n}\n```",
      "spec_type": "transformed",
      "transformation_type": "remove_docstrings",
      "usage_stats": {
        "duration_seconds": 19.032,
        "duration_formatted": "19.03s",
        "tokens": {
          "input": 513,
          "output": 1051,
          "total": 1564
        },
        "cost_usd": 0.009434,
        "model": "gpt-4.1",
        "timestamp": "2025-08-15T11:42:48.546761"
      }
    }
  ]
}