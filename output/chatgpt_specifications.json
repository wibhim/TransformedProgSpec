[
  {
    "file_path": "1091.py",
    "transformed_code": "class Solution(object):\n\n    def shortestPathBinaryMatrix(self, grid):\n        if not grid:\n            return -1\n        rows, cols = (len(grid), len(grid[0]))\n        if grid[0][0] or grid[rows - 1][cols - 1]:\n            return -1\n        queue = [[0, 0, 1]]\n        for row, col, dist in queue:\n            if row == rows - 1 and col == cols - 1:\n                return dist\n            for di, dj in [(-1, -1), (0, -1), (-1, 1), (-1, 0), (1, 0), (1, -1), (0, 1), (1, 1)]:\n                n_row, n_col = (row + di, col + dj)\n                if 0 <= n_row < rows and 0 <= n_col < cols and (not grid[n_row][n_col]):\n                    grid[n_row][n_col] = 1\n                    queue.append([n_row, n_col, dist + 1])\n        return -1",
    "program_specification": "```dafny\n// Dafny Specification and Program for shortestPathBinaryMatrix\n\nmethod ShortestPathBinaryMatrix(grid: array2<bool>) returns (res: int)\n    requires grid != null && grid.Length > 0 && grid[0].Length > 0\n    modifies grid\n    ensures\n        // If there is a path from (0,0) to (rows-1,cols-1), res is the length of the shortest such path (in steps)\n        // Otherwise, res == -1\n        (exists path: seq<(int,int)> ::\n            path[0] == (0,0) &&\n            path[|path|-1] == (grid.Length-1, grid[0].Length-1) &&\n            (forall i :: 0 <= i < |path| ==> 0 <= path[i].0 < grid.Length && 0 <= path[i].1 < grid[0].Length) &&\n            (forall i :: 0 <= i < |path| ==> !old(grid)[path[i].0, path[i].1]) &&\n            (forall i :: 0 <= i < |path|-1 ==>\n                ((abs(path[i+1].0 - path[i].0) <= 1) && (abs(path[i+1].1 - path[i].1) <= 1) && (path[i+1] != path[i]))\n            ) &&\n            |path| == res\n        ) || res == -1\n{\n    var rows := grid.Length;\n    var cols := grid[0].Length;\n\n    if grid[0,0] || grid[rows-1,cols-1] {\n        res := -1;\n        return;\n    }\n\n    var queue := new seq<(int,int,int)>();\n    var front := 0;\n    queue := queue + [(0,0,1)];\n    grid[0,0] := true;\n\n    while front < |queue|\n        invariant 0 <= front <= |queue|\n        invariant forall i :: 0 <= i < |queue| ==> 0 <= queue[i].0 < rows && 0 <= queue[i].1 < cols\n        invariant forall i :: 0 <= i < |queue| ==> 1 <= queue[i].2 <= rows*cols\n        decreases |queue| - front\n    {\n        var row := queue[front].0;\n        var col := queue[front].1;\n        var dist := queue[front].2;\n        if row == rows-1 && col == cols-1 {\n            res := dist;\n            return;\n        }\n        var dirs := [(-1,-1), (0,-1), (-1,1), (-1,0), (1,0), (1,-1), (0,1), (1,1)];\n        foreach d in dirs {\n            var n_row := row + d.0;\n            var n_col := col + d.1;\n            if 0 <= n_row < rows && 0 <= n_col < cols && !grid[n_row, n_col] {\n                grid[n_row, n_col] := true;\n                queue := queue + [(n_row, n_col, dist+1)];\n            }\n        }\n        front := front + 1;\n    }\n    res := -1;\n}\n```"
  },
  {
    "file_path": "1-100q/03.py",
    "transformed_code": "class Solution(object):\n\n    def lengthOfLongestSubstring(self, s):\n        mapSet = {}\n        start, result = (0, 0)\n        for end in range(len(s)):\n            if s[end] in mapSet:\n                start = max(mapSet[s[end]], start)\n            result = max(result, end - start + 1)\n            mapSet[s[end]] = end + 1\n        return result",
    "program_specification": "```dafny\nmethod LengthOfLongestSubstring(s: seq<char>) returns (result: int)\n    requires true\n    ensures 0 <= result <= |s|\n    ensures forall i, j :: 0 <= i <= j < |s| && (j - i + 1) > result ==>\n        exists k, l :: i <= k < l <= j && s[k] == s[l]\n    ensures exists i, j :: 0 <= i <= j < |s| && (j - i + 1) == result &&\n        (forall k, l :: i <= k < l <= j ==> k == l || s[k] != s[l])\n{\n    var mapSet := map[]; // map from char to int\n    var start := 0;\n    result := 0;\n    var end := 0;\n    while end < |s|\n        invariant 0 <= start <= end <= |s|\n        invariant 0 <= result <= end - start + 1\n        invariant forall c: char :: c in mapSet ==> 1 <= mapSet[c] <= end + 1\n        invariant forall c: char :: c in mapSet ==> exists k :: 0 <= k < end && s[k] == c && mapSet[c] == k + 1\n        invariant forall i, j :: 0 <= i <= j < end && (j - i + 1) > result ==>\n            exists k, l :: i <= k < l <= j && s[k] == s[l]\n        invariant exists i, j :: 0 <= i <= j < end && (j - i + 1) == result &&\n            (forall k, l :: i <= k < l <= j ==> k == l || s[k] != s[l])\n    {\n        if s[end] in mapSet {\n            start := if mapSet[s[end]] > start then mapSet[s[end]] else start;\n        }\n        result := if result > end - start + 1 then result else end - start + 1;\n        mapSet := mapSet[s[end] := end + 1];\n        end := end + 1;\n    }\n}\n```"
  },
  {
    "file_path": "1-100q/05.py",
    "transformed_code": "class Solution(object):\n\n    def longestPalindrome(self, s):\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        maxLength, result = (1, '')\n        for index in range(len(s)):\n            dp[index][index] = 1\n            result = s[index]\n        length = 2\n        while length <= len(s):\n            index_i = 0\n            while index_i < len(s) - length + 1:\n                index_j = index_i + length - 1\n                if length == 2 and s[index_i] == s[index_j]:\n                    dp[index_i][index_j] = 1\n                    maxLength = max(maxLength, 2)\n                    result = s[index_i:index_j + 1]\n                index_i += 1\n            length += 1\n        return result\n\nclass Solution(object):\n\n    def longestPalindrome(self, s):\n\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and (s[left] == s[right]):\n                left -= 1\n                right += 1\n            return right - left - 1\n        start, end = (0, 0)\n        for index in range(len(s)):\n            even_len = expand(s, index, index + 1)\n            odd_len = expand(s, index, index)\n            length = max(even_len, odd_len)\n            if length > end - start:\n                start = index - (length - 1) / 2\n                end = index + length / 2\n        return s[start:end + 1]",
    "program_specification": "```dafny\n// Dafny Specification and Program for Longest Palindromic Substring\n\nmethod IsPalindrome(s: seq<char>, i: int, j: int) returns (b: bool)\n    ensures b <==> (forall k :: 0 <= k < (j - i + 1) ==> s[i + k] == s[j - k])\n{\n    var l := i;\n    var r := j;\n    while l < r\n        invariant i <= l <= r <= j\n        invariant forall k :: i <= k < l ==> s[k] == s[j - (k - i)]\n        invariant forall k :: r < k <= j ==> s[k] == s[j - (k - i)]\n    {\n        if s[l] != s[r] {\n            return false;\n        }\n        l := l + 1;\n        r := r - 1;\n    }\n    return true;\n}\n\n// Returns the longest palindromic substring of s\nmethod LongestPalindrome(s: seq<char>) returns (res: seq<char>)\n    requires |s| >= 0\n    ensures (exists i, j :: 0 <= i <= j < |s| && res == s[i..j+1] && IsPalindrome(s, i, j))\n    ensures forall i, j :: 0 <= i <= j < |s| && IsPalindrome(s, i, j) ==> |s[i..j+1]| <= |res|\n{\n    var n := |s|;\n    if n == 0 {\n        return [];\n    }\n    var start := 0;\n    var maxLen := 1;\n\n    // Helper function to expand around center\n    function method Expand(s: seq<char>, left: int, right: int): int\n        requires 0 <= left < n\n        requires 0 <= right < n\n        ensures Expand(s, left, right) == (var l := left; var r := right; while l >= 0 && r < n && s[l] == s[r] { l := l - 1; r := r + 1; }; r - l - 1)\n    {\n        var l := left;\n        var r := right;\n        while l >= 0 && r < n && s[l] == s[r] {\n            l := l - 1;\n            r := r + 1;\n        }\n        r - l - 1\n    }\n\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant 1 <= maxLen <= n\n        invariant 0 <= start < n\n        invariant start + maxLen <= n\n        invariant IsPalindrome(s, start, start + maxLen - 1)\n        invariant forall k :: 0 <= k < i ==> forall l, r :: 0 <= l <= r < n && IsPalindrome(s, l, r) && r - l + 1 > maxLen ==> false\n    {\n        var len1 := Expand(s, i, i);\n        var len2 := if i + 1 < n then Expand(s, i, i + 1) else 0;\n        var len := if len1 > len2 then len1 else len2;\n        if len > maxLen {\n            start := i - (len - 1) / 2;\n            maxLen := len;\n        }\n        i := i + 1;\n    }\n    res := s[start..start+maxLen];\n}\n\n// Example usage\nmethod Main()\n{\n    var s := \"babad\";\n    var res := LongestPalindrome(s);\n    print res, \"\\n\";\n}\n```\n"
  },
  {
    "file_path": "1-100q/06.py",
    "transformed_code": "class Solution(object):\n\n    def convert(self, s, numRows):\n        if numRows == 1:\n            return s\n        result = ['' for _ in range(numRows)]\n        row, down = (0, 1)\n        for char in s:\n            result[row] += char\n            if row == numRows - 1:\n                down = 0\n            if row == 0:\n                down = 1\n            if down:\n                row += 1\n        final_string = ''\n        for value in result:\n            final_string += value\n        return final_string\nprint(Solution().convert('PAYPALISHIRING', 3))",
    "program_specification": "```dafny\n// Dafny Specification and Program for Zigzag Conversion\n\nmethod Convert(s: seq<char>, numRows: int) returns (res: seq<char>)\n    requires numRows >= 1\n    ensures numRows == 1 ==> res == s\n    ensures |res| == |s|\n    ensures multiset(res) == multiset(s)\n    // The output is the zigzag conversion of s with numRows rows\n{\n    if numRows == 1 {\n        return s;\n    }\n\n    var result := new seq<char>[numRows];\n    var i := 0;\n    while i < numRows\n        invariant 0 <= i <= numRows\n        invariant |result| == numRows\n        invariant forall j :: 0 <= j < i ==> result[j] == []\n    {\n        result[i] := [];\n        i := i + 1;\n    }\n\n    var row := 0;\n    var down := true;\n    var idx := 0;\n    while idx < |s|\n        invariant 0 <= row < numRows\n        invariant 0 <= idx <= |s|\n        invariant |result| == numRows\n        invariant forall j :: 0 <= j < numRows ==> result[j].Length <= idx\n        invariant multiset(SeqConcat(result)) == multiset(s[..idx])\n    {\n        result[row] := result[row] + [s[idx]];\n        if row == numRows - 1 {\n            down := false;\n        }\n        if row == 0 {\n            down := true;\n        }\n        if down {\n            row := row + 1;\n        } else {\n            row := row - 1;\n        }\n        idx := idx + 1;\n    }\n\n    // Concatenate all rows\n    var final_string := [];\n    var j := 0;\n    while j < numRows\n        invariant 0 <= j <= numRows\n        invariant |final_string| == sum k | 0 <= k < j :: |result[k]|\n        invariant multiset(final_string) == multiset(SeqConcat(result[..j]))\n    {\n        final_string := final_string + result[j];\n        j := j + 1;\n    }\n    res := final_string;\n}\n\n// Helper function to concatenate a sequence of sequences\nfunction method SeqConcat(ss: seq<seq<char>>): seq<char>\n    decreases |ss|\n{\n    if |ss| == 0 then [] else ss[0] + SeqConcat(ss[1..])\n}\n```"
  }
]