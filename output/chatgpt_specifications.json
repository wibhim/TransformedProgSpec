[
  {
    "file_path": "1091.py",
    "transformed_code": "class Solution(object):\n\n    def shortestPathBinaryMatrix(self, grid):\n        if not grid:\n            return -1\n        rows, cols = (len(grid), len(grid[0]))\n        if grid[0][0] or grid[rows - 1][cols - 1]:\n            return -1\n        queue = [[0, 0, 1]]\n        for row, col, dist in queue:\n            if row == rows - 1 and col == cols - 1:\n                return dist\n            for di, dj in [(-1, -1), (0, -1), (-1, 1), (-1, 0), (1, 0), (1, -1), (0, 1), (1, 1)]:\n                n_row, n_col = (row + di, col + dj)\n                if 0 <= n_row < rows and 0 <= n_col < cols and (not grid[n_row][n_col]):\n                    grid[n_row][n_col] = 1\n                    queue.append([n_row, n_col, dist + 1])\n        return -1",
    "program_specification": "```dafny\n// Dafny Specification and Program for shortestPathBinaryMatrix\n\nmethod ShortestPathBinaryMatrix(grid: seq<seq<int>>) returns (res: int)\n    requires |grid| > 0 && |grid[0]| > 0\n    requires forall row :: 0 <= row < |grid| ==> |grid[row]| == |grid[0]|\n    requires forall row :: 0 <= row < |grid| ==> forall col :: 0 <= col < |grid[0]| ==> grid[row][col] in {0, 1}\n    ensures res == -1 || (1 <= res <= |grid| * |grid[0]|)\n    ensures res == -1 ==> (grid[0][0] == 1 || grid[|grid|-1][|grid[0]|-1] == 1 || !ExistsPath(grid))\n    ensures res != -1 ==> ExistsPathOfLength(grid, res)\n{\n    var rows := |grid|;\n    var cols := |grid[0]|;\n\n    if grid[0][0] == 1 || grid[rows-1][cols-1] == 1 {\n        return -1;\n    }\n\n    var visited := new bool[rows, cols];\n    visited[0,0] := true;\n\n    var queue := new seq<(int, int, int)>[0];\n    queue := queue + [(0, 0, 1)];\n\n    var head := 0;\n    while head < |queue|\n        invariant 0 <= head <= |queue|\n        invariant forall i :: 0 <= i < head ==> visited[queue[i].0, queue[i].1]\n        decreases |queue| - head\n    {\n        var row, col, dist := queue[head];\n        head := head + 1;\n\n        if row == rows - 1 && col == cols - 1 {\n            return dist;\n        }\n\n        var directions := [(-1, -1), (0, -1), (-1, 1), (-1, 0), (1, 0), (1, -1), (0, 1), (1, 1)];\n        var d := 0;\n        while d < |directions|\n            invariant 0 <= d <= |directions|\n            decreases |directions| - d\n        {\n            var di := directions[d].0;\n            var dj := directions[d].1;\n            var n_row := row + di;\n            var n_col := col + dj;\n            if 0 <= n_row < rows && 0 <= n_col < cols && grid[n_row][n_col] == 0 && !visited[n_row, n_col] {\n                visited[n_row, n_col] := true;\n                queue := queue + [(n_row, n_col, dist + 1)];\n            }\n            d := d + 1;\n        }\n    }\n    return -1;\n}\n\n// Helper predicate: Is there a path from (0,0) to (rows-1,cols-1) using only 0s?\npredicate ExistsPath(grid: seq<seq<int>>)\n    reads grid\n{\n    exists path: seq<(int, int)> ::\n        |path| >= 1 &&\n        path[0] == (0, 0) &&\n        path[|path|-1] == (|grid|-1, |grid[0]|-1) &&\n        forall i :: 0 <= i < |path| ==>\n            0 <= path[i].0 < |grid| &&\n            0 <= path[i].1 < |grid[0]| &&\n            grid[path[i].0][path[i].1] == 0 &&\n            (i == 0 || IsNeighbor(path[i-1], path[i]))\n}\n\n// Helper predicate: Is there a path of length k from (0,0) to (rows-1,cols-1)?\npredicate ExistsPathOfLength(grid: seq<seq<int>>, k: int)\n    reads grid\n{\n    exists path: seq<(int, int)> ::\n        |path| == k &&\n        path[0] == (0, 0) &&\n        path[|path|-1] == (|grid|-1, |grid[0]|-1) &&\n        forall i :: 0 <= i < |path| ==>\n            0 <= path[i].0 < |grid| &&\n            0 <= path[i].1 < |grid[0]| &&\n            grid[path[i].0][path[i].1] == 0 &&\n            (i == 0 || IsNeighbor(path[i-1], path[i])) &&\n        forall i, j :: 0 <= i < j < |path| ==> path[i] != path[j]\n}\n\n// Helper predicate: Are two cells neighbors (including diagonals)?\npredicate IsNeighbor(a: (int, int), b: (int, int))\n{\n    var dr := a.0 - b.0;\n    var dc := a.1 - b.1;\n    (dr * dr + dc * dc) >= 1 && (dr * dr + dc * dc) <= 2\n}\n```"
  },
  {
    "file_path": "1-100q/03.py",
    "transformed_code": "class Solution(object):\n\n    def lengthOfLongestSubstring(self, s):\n        mapSet = {}\n        start, result = (0, 0)\n        for end in range(len(s)):\n            if s[end] in mapSet:\n                start = max(mapSet[s[end]], start)\n            result = max(result, end - start + 1)\n            mapSet[s[end]] = end + 1\n        return result",
    "program_specification": "```dafny\nmethod lengthOfLongestSubstring(s: seq<char>) returns (result: int)\n    requires true\n    ensures 0 <= result <= |s|\n    ensures forall i, j :: 0 <= i <= j < |s| && (j - i + 1) > result ==>\n        exists k, l :: i <= k < l <= j && s[k] == s[l]\n    ensures exists i, j :: 0 <= i <= j < |s| && (j - i + 1) == result &&\n        (forall k, l :: i <= k < l <= j ==> k == l || s[k] != s[l])\n{\n    var mapSet := map[]; // map from char to int (index+1)\n    var start := 0;\n    result := 0;\n    var end := 0;\n    while end < |s|\n        invariant 0 <= start <= end <= |s|\n        invariant 0 <= result <= end - start + 1\n        invariant forall i, j :: 0 <= i <= j < end ==>\n            (forall k, l :: i <= k < l <= j ==> k == l || s[k] != s[l]) ==> (j - i + 1) <= result\n        invariant forall c :: c in mapSet ==> mapSet[c] > start\n        decreases |s| - end\n    {\n        if s[end] in mapSet {\n            start := if mapSet[s[end]] > start then mapSet[s[end]] else start;\n        }\n        result := if result > end - start + 1 then result else end - start + 1;\n        mapSet := mapSet[s[end] := end + 1];\n        end := end + 1;\n    }\n}\n```"
  },
  {
    "file_path": "1-100q/05.py",
    "transformed_code": "class Solution(object):\n\n    def longestPalindrome(self, s):\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        maxLength, result = (1, '')\n        for index in range(len(s)):\n            dp[index][index] = 1\n            result = s[index]\n        length = 2\n        while length <= len(s):\n            index_i = 0\n            while index_i < len(s) - length + 1:\n                index_j = index_i + length - 1\n                if length == 2 and s[index_i] == s[index_j]:\n                    dp[index_i][index_j] = 1\n                    maxLength = max(maxLength, 2)\n                    result = s[index_i:index_j + 1]\n                index_i += 1\n            length += 1\n        return result\n\nclass Solution(object):\n\n    def longestPalindrome(self, s):\n\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and (s[left] == s[right]):\n                left -= 1\n                right += 1\n            return right - left - 1\n        start, end = (0, 0)\n        for index in range(len(s)):\n            even_len = expand(s, index, index + 1)\n            odd_len = expand(s, index, index)\n            length = max(even_len, odd_len)\n            if length > end - start:\n                start = index - (length - 1) / 2\n                end = index + length / 2\n        return s[start:end + 1]",
    "program_specification": "```dafny\n// Dafny Specification and Program for Longest Palindromic Substring\n\n// Helper predicate to check if a substring is a palindrome\npredicate IsPalindrome(s: seq<char>, i: int, j: int)\n  requires 0 <= i <= j < |s|\n{\n  forall k :: 0 <= k <= (j - i) / 2 ==> s[i + k] == s[j - k]\n}\n\n// Function to find the longest palindromic substring\nmethod LongestPalindrome(s: seq<char>) returns (res: seq<char>)\n  requires |s| >= 0\n  ensures 0 <= |res| <= |s|\n  ensures exists i, j :: 0 <= i <= j < |s| && res == s[i..j+1] && IsPalindrome(s, i, j)\n  ensures forall i', j' :: 0 <= i' <= j' < |s| && IsPalindrome(s, i', j') ==> |s[i'..j'+1]| <= |res|\n{\n  var n := |s|;\n  if n == 0 {\n    res := [];\n    return;\n  }\n\n  var start := 0;\n  var end := 0;\n\n  // Helper function to expand around center and return palindrome length\n  function method Expand(s: seq<char>, left: int, right: int): int\n    requires 0 <= left < n\n    requires 0 <= right < n\n    ensures Expand(s, left, right) >= 0\n    ensures Expand(s, left, right) <= n\n  {\n    var l := left;\n    var r := right;\n    while l >= 0 && r < n && s[l] == s[r]\n      decreases l\n    {\n      l := l - 1;\n      r := r + 1;\n    }\n    r - l - 1\n  }\n\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= start <= end < n\n    decreases n - i\n  {\n    var len1 := Expand(s, i, i);         // Odd length palindrome\n    var len2 := if i + 1 < n then Expand(s, i, i + 1) else 0; // Even length palindrome\n    var len := if len1 > len2 then len1 else len2;\n    if len > end - start + 1 {\n      start := i - (len - 1) / 2;\n      end := i + len / 2;\n    }\n    i := i + 1;\n  }\n  res := s[start..end+1];\n}\n\n// Example usage\nmethod Main() {\n  var s := ['b','a','b','a','d'];\n  var result := LongestPalindrome(s);\n  print result, \"\\n\"; // Should print ['b','a','b','a','b'] or ['a','b','a']\n}\n```\n"
  },
  {
    "file_path": "1-100q/06.py",
    "transformed_code": "class Solution(object):\n\n    def convert(self, s, numRows):\n        if numRows == 1:\n            return s\n        result = ['' for _ in range(numRows)]\n        row, down = (0, 1)\n        for char in s:\n            result[row] += char\n            if row == numRows - 1:\n                down = 0\n            if row == 0:\n                down = 1\n            if down:\n                row += 1\n        final_string = ''\n        for value in result:\n            final_string += value\n        return final_string\nprint(Solution().convert('PAYPALISHIRING', 3))",
    "program_specification": "```dafny\n// Dafny Specification and Program for the given Python code\n\nmethod Convert(s: seq<char>, numRows: int) returns (res: seq<char>)\n    requires numRows >= 1\n    ensures numRows == 1 ==> res == s\n    ensures |res| == |s|\n    ensures multiset(res) == multiset(s)\n    // The output is the \"zigzag\" conversion of s with numRows rows, concatenated row-wise\n{\n    if numRows == 1 {\n        return s;\n    }\n\n    var result := new seq<char>[numRows];\n    var i := 0;\n    while i < numRows\n        invariant 0 <= i <= numRows\n        invariant |result| == numRows\n        invariant forall j :: 0 <= j < i ==> result[j] == []\n    {\n        result[i] := [];\n        i := i + 1;\n    }\n\n    var row := 0;\n    var down := true;\n    var idx := 0;\n    while idx < |s|\n        invariant 0 <= row < numRows\n        invariant 0 <= idx <= |s|\n        invariant |result| == numRows\n        invariant forall j :: 0 <= j < numRows ==> result[j] == \n            (if j == row then old(result[j]) + [s[idx-1]] else old(result[j]))\n        decreases |s| - idx\n    {\n        result[row] := result[row] + [s[idx]];\n        if row == numRows - 1 {\n            down := false;\n        }\n        if row == 0 {\n            down := true;\n        }\n        if down {\n            row := row + 1;\n        } else {\n            row := row - 1;\n        }\n        idx := idx + 1;\n    }\n\n    var final_string := [];\n    var j := 0;\n    while j < numRows\n        invariant 0 <= j <= numRows\n        invariant |final_string| == sum k: int {:trigger 0 <= k < j} :: 0 <= k < j ==> |result[k]|\n    {\n        final_string := final_string + result[j];\n        j := j + 1;\n    }\n    res := final_string;\n}\n```"
  },
  {
    "file_path": "1-100q/11.py",
    "transformed_code": "class Solution(object):\n\n    def maxArea(self, height):\n        left, right, maxArea = (0, len(height) - 1, 0)\n        while left < right:\n            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n        return maxArea",
    "program_specification": "```dafny\nmethod maxArea(height: array<int>) returns (maxArea: int)\n    requires height != null && height.Length >= 2\n    ensures 0 <= maxArea\n    ensures forall i, j :: 0 <= i < j < height.Length ==>\n        maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n    ensures exists i, j :: 0 <= i < j < height.Length &&\n        maxArea == (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n{\n    var left := 0;\n    var right := height.Length - 1;\n    maxArea := 0;\n    while left < right\n        invariant 0 <= left <= right < height.Length\n        invariant 0 <= maxArea\n        invariant forall i, j :: 0 <= i < j < height.Length && (i < left || j > right) ==>\n            maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n    {\n        var area := if height[left] < height[right] then height[left] else height[right];\n        area := area * (right - left);\n        if area > maxArea {\n            maxArea := area;\n        }\n        if height[left] < height[right] {\n            left := left + 1;\n        } else {\n            right := right - 1;\n        }\n    }\n}\n```"
  },
  {
    "file_path": "1-100q/14.py",
    "transformed_code": "class Solution(object):\n\n    def longestCommonPrefix(self, strs):\n\n        def prefix(strs, index):\n            check_prefix = strs[0][:index]\n            for index in range(1, len(strs)):\n                if not strs[index].startswith(check_prefix):\n                    return False\n            return True\n        if not strs:\n            return ''\n        minLength = float('inf')\n        for string in strs:\n            minLength = min(minLength, len(string))\n        low, high = (0, minLength)\n        while low <= high:\n            mid = (low + high) / 2\n            if prefix(strs, mid):\n                low = mid + 1\n        return strs[0][:(low + high) / 2]",
    "program_specification": "```dafny\n// Dafny Specification and Program for Longest Common Prefix\n\nmethod LongestCommonPrefix(strs: seq<seq<char>>) returns (prefix: seq<char>)\n    requires forall s :: s in strs ==> |s| >= 0\n    ensures\n        // The result is a prefix of every string in strs\n        forall s :: s in strs ==> prefix == s[..|prefix|]\n    ensures\n        // The result is the longest such prefix\n        forall p: seq<char> :: \n            (forall s :: s in strs ==> p == s[..|p|]) ==> |p| <= |prefix|\n{\n    if |strs| == 0 {\n        prefix := [];\n        return;\n    }\n\n    var minLength := |strs[0]|;\n    var i := 1;\n    while i < |strs|\n        invariant 1 <= |strs|\n        invariant 0 <= i <= |strs|\n        invariant minLength == (if i == 0 then |strs[0]| else SeqMin(Seq([|strs[j]| | j := 0 .. i-1])))\n    {\n        if |strs[i]| < minLength {\n            minLength := |strs[i]|;\n        }\n        i := i + 1;\n    }\n\n    var low := 0;\n    var high := minLength;\n    while low <= high\n        invariant 0 <= low <= minLength + 1\n        invariant 0 <= high <= minLength\n        invariant low >= 0\n        invariant high >= 0\n        decreases high - low + 1\n    {\n        var mid := (low + high) / 2;\n        if PrefixCheck(strs, mid) {\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n        }\n    }\n    prefix := strs[0][..((low + high) / 2)];\n}\n\n// Helper function: checks if all strings in strs have the same prefix of length 'index'\nfunction method PrefixCheck(strs: seq<seq<char>>, index: int): bool\n    requires |strs| > 0\n    requires 0 <= index <= |strs[0]|\n    ensures PrefixCheck(strs, index) <==>\n        (forall i :: 0 <= i < |strs| ==> strs[i][..index] == strs[0][..index])\n{\n    forall i :: 0 <= i < |strs| ==> strs[i][..index] == strs[0][..index]\n}\n\n// Helper function: minimum of a sequence of integers\nfunction SeqMin(s: seq<int>): int\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> SeqMin(s) <= s[i]\n{\n    if |s| == 1 then s[0] else if s[0] < SeqMin(s[1..]) then s[0] else SeqMin(s[1..])\n}\n```"
  },
  {
    "file_path": "1-100q/15.py",
    "transformed_code": "class Solution(object):\n\n    def threeSum(self, nums):\n        nums.sort()\n        if len(nums) >= 3 and nums[0] == nums[len(nums) - 1] and (nums[0] == 0):\n            return [[0, 0, 0]]\n        result = []\n        for index in range(len(nums) - 1):\n            left = index + 1\n            right = len(nums) - 1\n            while left < right:\n                currSum = nums[index] + nums[left] + nums[right]\n                if currSum == 0:\n                    result.append([nums[index], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n        return [list(t) for t in set((tuple(element) for element in result))]",
    "program_specification": "```dafny\n// Dafny Specification and Program for threeSum\n\nmethod threeSum(nums: seq<int>) returns (res: seq<seq<int>>)\n    requires true\n    ensures\n        // Each element in res is a triple\n        forall t :: t in res ==> |t| == 3\n    ensures\n        // Each triple sums to zero\n        forall t :: t in res ==> t[0] + t[1] + t[2] == 0\n    ensures\n        // All triples are unique\n        forall i, j :: 0 <= i < |res| && 0 <= j < |res| && i != j ==> res[i] != res[j]\n    ensures\n        // All triples are from nums\n        forall t :: t in res ==> (exists i, j, k :: 0 <= i < |nums| && 0 <= j < |nums| && 0 <= k < |nums| && i != j && j != k && i != k && multiset{t[0], t[1], t[2]} == multiset{nums[i], nums[j], nums[k]})\n    ensures\n        // Special case: if nums has at least three zeros and all elements are zero, return [[0,0,0]]\n        (|nums| >= 3 && (forall i :: 0 <= i < |nums| ==> nums[i] == 0)) ==> (res == [[0,0,0]])\n{\n    var n := |nums|;\n    var sortedNums := nums[..];\n    // Simple selection sort for Dafny (since sort() is not built-in)\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant sortedNums[..i] == sortedNums[..i].Sorted()\n    {\n        var minIdx := i;\n        var j := i + 1;\n        while j < n\n            invariant i + 1 <= j <= n\n            invariant minIdx >= i && minIdx < n\n        {\n            if sortedNums[j] < sortedNums[minIdx] {\n                minIdx := j;\n            }\n            j := j + 1;\n        }\n        // Swap\n        var tmp := sortedNums[i];\n        sortedNums[i] := sortedNums[minIdx];\n        sortedNums[minIdx] := tmp;\n        i := i + 1;\n    }\n\n    if n >= 3 && sortedNums[0] == sortedNums[n-1] && sortedNums[0] == 0 {\n        res := [[0,0,0]];\n        return;\n    }\n\n    var result := [];\n    var index := 0;\n    while index < n - 1\n        invariant 0 <= index <= n - 1\n        invariant forall t :: t in result ==> |t| == 3 && t[0] + t[1] + t[2] == 0\n    {\n        var left := index + 1;\n        var right := n - 1;\n        while left < right\n            invariant index + 1 <= left <= right <= n - 1\n        {\n            var currSum := sortedNums[index] + sortedNums[left] + sortedNums[right];\n            if currSum == 0 {\n                result := result + [[sortedNums[index], sortedNums[left], sortedNums[right]]];\n                left := left + 1;\n                right := right - 1;\n            } else {\n                // In the Python code, nothing is done for currSum != 0\n                // So we do nothing here\n                left := left + 1;\n            }\n        }\n        index := index + 1;\n    }\n\n    // Remove duplicates\n    var uniqueResult := [];\n    var i := 0;\n    while i < |result|\n        invariant 0 <= i <= |result|\n        invariant forall j :: 0 <= j < |uniqueResult| ==> forall k :: 0 <= k < j ==> uniqueResult[j] != uniqueResult[k]\n        invariant forall t :: t in uniqueResult ==> t in result\n    {\n        var found := false;\n        var j := 0;\n        while j < |uniqueResult|\n            invariant 0 <= j <= |uniqueResult|\n            invariant !found ==> forall k :: 0 <= k < j ==> uniqueResult[k] != result[i]\n        {\n            if uniqueResult[j] == result[i] {\n                found := true;\n            }\n            j := j + 1;\n        }\n        if !found {\n            uniqueResult := uniqueResult + [result[i]];\n        }\n        i := i + 1;\n    }\n    res := uniqueResult;\n}\n```"
  },
  {
    "file_path": "1-100q/16.py",
    "transformed_code": "class Solution(object):\n\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        result, min_diff = (0, float('inf'))\n        for index in range(len(nums) - 1):\n            left = index + 1\n            right = len(nums) - 1\n            while left < right:\n                currSum = nums[index] + nums[left] + nums[right]\n                diff = abs(target - currSum)\n                if diff == 0:\n                    return target\n                if diff < min_diff:\n                    min_diff = diff\n                    result = currSum\n                if currSum < target:\n                    left += 1\n        return result",
    "program_specification": "```dafny\nmethod ThreeSumClosest(nums: seq<int>, target: int) returns (result: int)\n    requires |nums| >= 3\n    ensures exists i, j, k :: 0 <= i < j < k < |nums| && result == nums[i] + nums[j] + nums[k]\n    ensures forall i, j, k :: 0 <= i < j < k < |nums| ==>\n        abs(target - result) <= abs(target - (nums[i] + nums[j] + nums[k]))\n{\n    var n := |nums|;\n    var sortedNums := nums[..];\n    // Sort the array\n    sortedNums := Sort(sortedNums);\n\n    var min_diff := int.Max;\n    var closest := 0;\n\n    var index := 0;\n    while index < n - 2\n        invariant 0 <= index <= n - 2\n        invariant forall i, j, k :: 0 <= i < j < k < index + 1 ==>\n            abs(target - closest) <= abs(target - (sortedNums[i] + sortedNums[j] + sortedNums[k]))\n        decreases n - 2 - index\n    {\n        var left := index + 1;\n        var right := n - 1;\n        while left < right\n            invariant index + 1 <= left <= right <= n\n            invariant forall i, j, k :: 0 <= i < j < k < index + 1 ||\n                (i == index && j == left && k == right) ==>\n                abs(target - closest) <= abs(target - (sortedNums[i] + sortedNums[j] + sortedNums[k]))\n            decreases right - left\n        {\n            var currSum := sortedNums[index] + sortedNums[left] + sortedNums[right];\n            var diff := if target - currSum >= 0 then target - currSum else currSum - target;\n            if diff == 0 {\n                return target;\n            }\n            if diff < min_diff {\n                min_diff := diff;\n                closest := currSum;\n            }\n            if currSum < target {\n                left := left + 1;\n            } else {\n                right := right - 1;\n            }\n        }\n        index := index + 1;\n    }\n    result := closest;\n}\n\n// Helper function: simple insertion sort for sequences\nfunction method Sort(a: seq<int>): seq<int>\n    ensures multiset(Sort(a)) == multiset(a)\n    ensures forall i, j :: 0 <= i < j < |Sort(a)| ==> Sort(a)[i] <= Sort(a)[j]\n{\n    if |a| <= 1 then a\n    else\n        var pivot := a[0];\n        var left := Sort([x | x <- a[1..], x < pivot]);\n        var right := Sort([x | x <- a[1..], x >= pivot]);\n        left + [pivot] + right\n}\n```"
  },
  {
    "file_path": "1-100q/17.py",
    "transformed_code": "class Solution(object):\n\n    def letterCombinations(self, digits):\n        phoneMap = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        number = str(digits)\n        if number == '':\n            return []\n        result = ['']\n        for char in number:\n            values = phoneMap[char]\n            new_result = []\n            for prefix in result:\n                currElement = prefix\n                for value in values:\n                    new_result.append(currElement + value)\n            result = new_result\n        return result\nprint(Solution().letterCombinations('23'))",
    "program_specification": "```dafny\n// Dafny Specification and Program for letterCombinations\n\n// Helper function to model the phone map\nfunction method PhoneMap(c: char): seq<char>\n  requires '2' <= c <= '9'\n  decreases c\n{\n  if c == '2' then ['a','b','c']\n  else if c == '3' then ['d','e','f']\n  else if c == '4' then ['g','h','i']\n  else if c == '5' then ['j','k','l']\n  else if c == '6' then ['m','n','o']\n  else if c == '7' then ['p','q','r','s']\n  else if c == '8' then ['t','u','v']\n  else ['w','x','y','z']\n}\n\n// Specification for letterCombinations\n// Given a string of digits, returns all possible letter combinations\n// that the number could represent based on the phone mapping.\nmethod letterCombinations(digits: seq<char>) returns (result: seq<seq<char>>)\n  requires forall d :: d in digits ==> '2' <= d <= '9'\n  ensures (|digits| == 0) ==> |result| == 0\n  ensures (|digits| > 0) ==> \n    |result| == ProductLengths(digits)\n  ensures forall s :: s in result ==> |s| == |digits|\n  ensures forall s :: s in result ==> \n    forall i :: 0 <= i < |digits| ==> s[i] in PhoneMap(digits[i])\n{\n  if |digits| == 0 {\n    result := [];\n    return;\n  }\n  var res: seq<seq<char>> := [ [] ];\n  var i := 0;\n  while i < |digits|\n    invariant 0 <= i <= |digits|\n    invariant forall s :: s in res ==> |s| == i\n    invariant forall s :: s in res ==> \n      forall j :: 0 <= j < i ==> s[j] in PhoneMap(digits[j])\n    decreases |digits| - i\n  {\n    var new_res: seq<seq<char>> := [];\n    var letters := PhoneMap(digits[i]);\n    var j := 0;\n    while j < |res|\n      invariant 0 <= j <= |res|\n      invariant forall k :: 0 <= k < j ==> \n        forall s :: s in [res[k]] ==> |s| == i &&\n          forall m :: 0 <= m < i ==> s[m] in PhoneMap(digits[m])\n      decreases |res| - j\n    {\n      var prefix := res[j];\n      var l := 0;\n      while l < |letters|\n        invariant 0 <= l <= |letters|\n        decreases |letters| - l\n      {\n        new_res := new_res + [prefix + [letters[l]]];\n        l := l + 1;\n      }\n      j := j + 1;\n    }\n    res := new_res;\n    i := i + 1;\n  }\n  result := res;\n}\n\n// Helper function to compute the product of the lengths of the mapped letters\nfunction ProductLengths(digits: seq<char>): nat\n{\n  if |digits| == 0 then 0\n  else if |digits| == 1 then |PhoneMap(digits[0])|\n  else |PhoneMap(digits[0])| * ProductLengths(digits[1..])\n}\n```"
  }
]