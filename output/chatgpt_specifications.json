[
  {
    "file_path": "1091.py",
    "transformed_code": "class Solution(object):\n\n    def shortestPathBinaryMatrix(self, grid):\n        if not grid:\n            return -1\n        rows, cols = (len(grid), len(grid[0]))\n        if grid[0][0] or grid[rows - 1][cols - 1]:\n            return -1\n        queue = [[0, 0, 1]]\n        for row, col, dist in queue:\n            if row == rows - 1 and col == cols - 1:\n                return dist\n            for di, dj in [(-1, -1), (0, -1), (-1, 1), (-1, 0), (1, 0), (1, -1), (0, 1), (1, 1)]:\n                n_row, n_col = (row + di, col + dj)\n                if 0 <= n_row < rows and 0 <= n_col < cols and (not grid[n_row][n_col]):\n                    grid[n_row][n_col] = 1\n                    queue.append([n_row, n_col, dist + 1])\n        return -1",
    "program_specification": "```dafny\n// Dafny Specification and Program for shortestPathBinaryMatrix\n\nmethod ShortestPathBinaryMatrix(grid: array2<bool>) returns (dist: int)\n    requires grid != null && grid.Length > 0 && grid[0].Length > 0\n    ensures dist == -1 || (dist > 0 && dist <= grid.Length * grid[0].Length)\n    ensures dist == -1 ==> !exists path :: IsValidPath(grid, path)\n    ensures dist > 0 ==> exists path :: IsValidPath(grid, path) && |path| == dist\n{\n    var rows := grid.Length;\n    var cols := grid[0].Length;\n\n    if grid[0][0] || grid[rows - 1][cols - 1] {\n        return -1;\n    }\n\n    var visited := new bool[rows, cols];\n    visited[0, 0] := true;\n\n    var queue := new seq<(int, int, int)>;\n    queue := queue + [(0, 0, 1)];\n\n    var head := 0;\n    while head < |queue|\n        invariant 0 <= head <= |queue|\n        invariant forall i :: 0 <= i < head ==> visited[queue[i].0, queue[i].1]\n        invariant forall i :: head <= i < |queue| ==> !visited[queue[i].0, queue[i].1]\n    {\n        var (row, col, d) := queue[head];\n        head := head + 1;\n\n        if row == rows - 1 && col == cols - 1 {\n            return d;\n        }\n\n        var dirs := [(-1, -1), (0, -1), (-1, 1), (-1, 0), (1, 0), (1, -1), (0, 1), (1, 1)];\n        var k := 0;\n        while k < |dirs|\n            invariant 0 <= k <= |dirs|\n        {\n            var di := dirs[k].0;\n            var dj := dirs[k].1;\n            var n_row := row + di;\n            var n_col := col + dj;\n            if 0 <= n_row < rows && 0 <= n_col < cols && !grid[n_row][n_col] && !visited[n_row, n_col] {\n                visited[n_row, n_col] := true;\n                queue := queue + [(n_row, n_col, d + 1)];\n            }\n            k := k + 1;\n        }\n    }\n    return -1;\n}\n\n// Helper predicate to define a valid path from (0,0) to (rows-1,cols-1)\npredicate IsValidPath(grid: array2<bool>, path: seq<(int, int)>)\n    requires grid != null && grid.Length > 0 && grid[0].Length > 0\n{\n    |path| > 0 &&\n    path[0] == (0, 0) &&\n    path[|path|-1] == (grid.Length-1, grid[0].Length-1) &&\n    forall i :: 0 <= i < |path| ==> 0 <= path[i].0 < grid.Length && 0 <= path[i].1 < grid[0].Length && !grid[path[i].0][path[i].1] &&\n    forall i :: 0 <= i < |path|-1 ==> IsNeighbor(path[i], path[i+1])\n}\n\n// Helper predicate to define 8-directional adjacency\npredicate IsNeighbor(a: (int, int), b: (int, int))\n{\n    var dr := if a.0 > b.0 then a.0 - b.0 else b.0 - a.0;\n    var dc := if a.1 > b.1 then a.1 - b.1 else b.1 - a.1;\n    dr <= 1 && dc <= 1 && (dr != 0 || dc != 0)\n}\n```"
  },
  {
    "file_path": "1-100q/03.py",
    "transformed_code": "class Solution(object):\n\n    def lengthOfLongestSubstring(self, s):\n        mapSet = {}\n        start, result = (0, 0)\n        for end in range(len(s)):\n            if s[end] in mapSet:\n                start = max(mapSet[s[end]], start)\n            result = max(result, end - start + 1)\n            mapSet[s[end]] = end + 1\n        return result",
    "program_specification": "```dafny\nmethod LengthOfLongestSubstring(s: seq<char>) returns (result: int)\n    requires true\n    ensures 0 <= result <= |s|\n    ensures forall i, j :: 0 <= i <= j < |s| && j - i + 1 > result ==>\n        exists k, l :: i <= k < l <= j && s[k] == s[l]\n    ensures exists i, j :: 0 <= i <= j < |s| && result == j - i + 1 &&\n        (forall k, l :: i <= k < l <= j ==> s[k] != s[l])\n{\n    var mapSet := map[]; // map from char to int (last seen index + 1)\n    var start := 0;\n    result := 0;\n    var end := 0;\n    while end < |s|\n        invariant 0 <= start <= end <= |s|\n        invariant 0 <= result <= end - start + 1\n        invariant forall c: char :: c in mapSet ==> 1 <= mapSet[c] <= end + 1\n        invariant forall c: char :: c in mapSet ==>\n            exists idx :: start <= idx < end && s[idx] == c && mapSet[c] == idx + 1\n        invariant forall i, j :: 0 <= i <= j < end && j - i + 1 > result ==>\n            exists k, l :: i <= k < l <= j && s[k] == s[l]\n        invariant exists i, j :: 0 <= i <= j < end && result == j - i + 1 &&\n            (forall k, l :: i <= k < l <= j ==> s[k] != s[l])\n    {\n        if s[end] in mapSet {\n            start := if mapSet[s[end]] > start then mapSet[s[end]] else start;\n        }\n        result := if result > end - start + 1 then result else end - start + 1;\n        mapSet := mapSet[s[end] := end + 1];\n        end := end + 1;\n    }\n}\n```"
  },
  {
    "file_path": "1-100q/05.py",
    "transformed_code": "class Solution(object):\n\n    def longestPalindrome(self, s):\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        maxLength, result = (1, '')\n        for index in range(len(s)):\n            dp[index][index] = 1\n            result = s[index]\n        length = 2\n        while length <= len(s):\n            index_i = 0\n            while index_i < len(s) - length + 1:\n                index_j = index_i + length - 1\n                if length == 2 and s[index_i] == s[index_j]:\n                    dp[index_i][index_j] = 1\n                    maxLength = max(maxLength, 2)\n                    result = s[index_i:index_j + 1]\n                index_i += 1\n            length += 1\n        return result\n\nclass Solution(object):\n\n    def longestPalindrome(self, s):\n\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and (s[left] == s[right]):\n                left -= 1\n                right += 1\n            return right - left - 1\n        start, end = (0, 0)\n        for index in range(len(s)):\n            even_len = expand(s, index, index + 1)\n            odd_len = expand(s, index, index)\n            length = max(even_len, odd_len)\n            if length > end - start:\n                start = index - (length - 1) / 2\n                end = index + length / 2\n        return s[start:end + 1]",
    "program_specification": "```dafny\n// Dafny Specification and Program for Longest Palindromic Substring\n\nmethod IsPalindrome(s: seq<char>, i: int, j: int) returns (b: bool)\n    ensures b <==> (forall k :: 0 <= k < (j - i + 1) ==> s[i + k] == s[j - k])\n{\n    var res := true;\n    var left := i;\n    var right := j;\n    while left < right\n        invariant i <= left <= right + 1 <= j + 1 <= |s| + 1\n        invariant res ==> (forall k :: i <= k < left ==> s[k] == s[j - (k - i)])\n        decreases right - left\n    {\n        if s[left] != s[right] {\n            res := false;\n            break;\n        }\n        left := left + 1;\n        right := right - 1;\n    }\n    b := res;\n}\n\n// Main method: Returns the longest palindromic substring of s\nmethod LongestPalindrome(s: seq<char>) returns (res: seq<char>)\n    requires |s| >= 0\n    ensures (exists i, j :: 0 <= i <= j < |s| && res == s[i..j+1] && IsPalindrome(s, i, j))\n    ensures (forall i, j :: 0 <= i <= j < |s| && IsPalindrome(s, i, j) ==> |res| >= j - i + 1)\n{\n    if |s| == 0 {\n        res := [];\n        return;\n    }\n    var maxLen := 1;\n    var start := 0;\n\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant 1 <= maxLen <= |s|\n        invariant 0 <= start < |s|\n        invariant (forall k :: 0 <= k < i ==> (forall l :: 1 <= l <= maxLen ==> (exists a :: 0 <= a <= k && a + l - 1 < |s| && IsPalindrome(s, a, a + l - 1))))\n        decreases |s| - i\n    {\n        // Odd length palindrome\n        var l := i;\n        var r := i;\n        while l >= 0 && r < |s| && s[l] == s[r]\n            invariant 0 <= l + 1 <= i + 1\n            invariant i <= r < |s|\n            decreases l + 1\n        {\n            if r - l + 1 > maxLen {\n                start := l;\n                maxLen := r - l + 1;\n            }\n            l := l - 1;\n            r := r + 1;\n        }\n        // Even length palindrome\n        l := i;\n        r := i + 1;\n        while l >= 0 && r < |s| && s[l] == s[r]\n            invariant 0 <= l + 1 <= i + 1\n            invariant i + 1 <= r < |s| + 1\n            decreases l + 1\n        {\n            if r - l + 1 > maxLen {\n                start := l;\n                maxLen := r - l + 1;\n            }\n            l := l - 1;\n            r := r + 1;\n        }\n        i := i + 1;\n    }\n    res := s[start..start+maxLen];\n}\n```"
  },
  {
    "file_path": "1-100q/06.py",
    "transformed_code": "class Solution(object):\n\n    def convert(self, s, numRows):\n        if numRows == 1:\n            return s\n        result = ['' for _ in range(numRows)]\n        row, down = (0, 1)\n        for char in s:\n            result[row] += char\n            if row == numRows - 1:\n                down = 0\n            if row == 0:\n                down = 1\n            if down:\n                row += 1\n        final_string = ''\n        for value in result:\n            final_string += value\n        return final_string\nprint(Solution().convert('PAYPALISHIRING', 3))",
    "program_specification": "```dafny\n// Dafny Specification and Program for the Zigzag Conversion\n\nmethod Convert(s: seq<char>, numRows: int) returns (finalString: seq<char>)\n    requires numRows >= 1\n    ensures numRows == 1 ==> finalString == s\n    ensures |finalString| == |s|\n    ensures multiset(finalString) == multiset(s)\n{\n    if numRows == 1 {\n        return s;\n    }\n\n    var result := new seq<char>[numRows];\n    var i := 0;\n    while i < numRows\n        invariant 0 <= i <= numRows\n        invariant |result| == numRows\n        invariant forall j :: 0 <= j < i ==> result[j] == []\n    {\n        result[i] := [];\n        i := i + 1;\n    }\n\n    var row := 0;\n    var down := true;\n    var idx := 0;\n    while idx < |s|\n        invariant 0 <= row < numRows\n        invariant 0 <= idx <= |s|\n        invariant |result| == numRows\n        invariant multiset(ConcatAll(result)) == multiset(s[..idx])\n        invariant forall j :: 0 <= j < numRows ==> |result[j]| <= idx\n    {\n        result[row] := result[row] + [s[idx]];\n        if row == numRows - 1 {\n            down := false;\n        }\n        if row == 0 {\n            down := true;\n        }\n        if down {\n            row := row + 1;\n        } else {\n            row := row - 1;\n        }\n        idx := idx + 1;\n    }\n\n    finalString := ConcatAll(result);\n}\n\n// Helper function to concatenate all sequences in a sequence of sequences\nfunction method ConcatAll(seqs: seq<seq<char>>): seq<char>\n    decreases |seqs|\n{\n    if |seqs| == 0 then [] else seqs[0] + ConcatAll(seqs[1..])\n}\n```"
  },
  {
    "file_path": "1-100q/11.py",
    "transformed_code": "class Solution(object):\n\n    def maxArea(self, height):\n        left, right, maxArea = (0, len(height) - 1, 0)\n        while left < right:\n            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n        return maxArea",
    "program_specification": "```dafny\nmethod maxArea(height: array<int>) returns (maxArea: int)\n    requires height != null && height.Length >= 2\n    ensures 0 <= maxArea\n    ensures forall i, j :: 0 <= i < j < height.Length ==>\n        maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n    ensures exists i, j :: 0 <= i < j < height.Length &&\n        maxArea == (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n{\n    var left := 0;\n    var right := height.Length - 1;\n    maxArea := 0;\n\n    while left < right\n        invariant 0 <= left <= right < height.Length\n        invariant 0 <= maxArea\n        invariant forall i, j :: 0 <= i < j < height.Length && (i < left || j > right) ==>\n            maxArea >= (if height[i] < height[j] then height[i] else height[j]) * (j - i)\n    {\n        var h := if height[left] < height[right] then height[left] else height[right];\n        var area := h * (right - left);\n        if area > maxArea {\n            maxArea := area;\n        }\n        if height[left] < height[right] {\n            left := left + 1;\n        } else {\n            right := right - 1;\n        }\n    }\n}\n```"
  },
  {
    "file_path": "1-100q/14.py",
    "transformed_code": "class Solution(object):\n\n    def longestCommonPrefix(self, strs):\n\n        def prefix(strs, index):\n            check_prefix = strs[0][:index]\n            for index in range(1, len(strs)):\n                if not strs[index].startswith(check_prefix):\n                    return False\n            return True\n        if not strs:\n            return ''\n        minLength = float('inf')\n        for string in strs:\n            minLength = min(minLength, len(string))\n        low, high = (0, minLength)\n        while low <= high:\n            mid = (low + high) / 2\n            if prefix(strs, mid):\n                low = mid + 1\n        return strs[0][:(low + high) / 2]",
    "program_specification": "```dafny\n// Dafny Specification and Program for Longest Common Prefix\n\nmethod LongestCommonPrefix(strs: seq<seq<char>>) returns (prefix: seq<char>)\n    requires forall s :: s in strs ==> |s| >= 0\n    ensures\n        // The result is a prefix of every string in strs\n        forall s :: s in strs ==> prefix == s[..|prefix|]\n    ensures\n        // The result is the longest such prefix\n        forall p: seq<char> :: (forall s :: s in strs ==> p == s[..|p|]) ==> |p| <= |prefix|\n{\n    if |strs| == 0 {\n        prefix := [];\n        return;\n    }\n\n    var minLength := |strs[0]|;\n    var i := 1;\n    while i < |strs|\n        invariant 1 <= |strs| ==> 0 <= i <= |strs|\n        invariant minLength == (if i == 0 then |strs[0]| else SeqMin(Seq([|strs[j]| | j := 0 .. i-1])))\n    {\n        if |strs[i]| < minLength {\n            minLength := |strs[i]|;\n        }\n        i := i + 1;\n    }\n\n    var low := 0;\n    var high := minLength;\n    while low <= high\n        invariant 0 <= low <= minLength+1\n        invariant 0 <= high <= minLength\n        invariant low >= 0 && high >= 0\n        decreases high - low + 1\n    {\n        var mid := (low + high) / 2;\n        if PrefixCheck(strs, mid) {\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n        }\n    }\n    prefix := strs[0][..((low + high) / 2)];\n}\n\n// Helper function: check if all strings in strs have the same prefix of length 'index'\nfunction PrefixCheck(strs: seq<seq<char>>, index: int): bool\n    requires |strs| > 0 && 0 <= index <= |strs[0]|\n    requires forall s :: s in strs ==> |s| >= index\n{\n    var check_prefix := strs[0][..index];\n    forall i :: 0 <= i < |strs| ==> strs[i][..index] == check_prefix\n}\n\n// Helper function: minimum of a sequence of integers\nfunction SeqMin(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0] else if s[0] < SeqMin(s[1..]) then s[0] else SeqMin(s[1..])\n}\n```"
  },
  {
    "file_path": "1-100q/15.py",
    "transformed_code": "class Solution(object):\n\n    def threeSum(self, nums):\n        nums.sort()\n        if len(nums) >= 3 and nums[0] == nums[len(nums) - 1] and (nums[0] == 0):\n            return [[0, 0, 0]]\n        result = []\n        for index in range(len(nums) - 1):\n            left = index + 1\n            right = len(nums) - 1\n            while left < right:\n                currSum = nums[index] + nums[left] + nums[right]\n                if currSum == 0:\n                    result.append([nums[index], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n        return [list(t) for t in set((tuple(element) for element in result))]",
    "program_specification": "```dafny\n// Dafny Specification and Program for the given Python code\n\nmethod ThreeSum(nums: seq<int>) returns (res: seq<seq<int>>)\n    requires true\n    ensures\n        // Each element in res is a triple of indices in nums whose sum is 0\n        forall t :: 0 <= t < |res| ==>\n            |res[t]| == 3 &&\n            res[t][0] + res[t][1] + res[t][2] == 0\n    ensures\n        // All triples in res are unique (no duplicates)\n        forall i, j :: 0 <= i < j < |res| ==> res[i] != res[j]\n    ensures\n        // All returned triples are present in nums\n        forall t :: 0 <= t < |res| ==>\n            exists i, j, k :: \n                0 <= i < j < k < |nums| &&\n                multiset{nums[i], nums[j], nums[k]} == multiset{res[t][0], res[t][1], res[t][2]}\n{\n    var n := |nums|;\n    var arr := nums[..];\n    // Sort the array\n    var sortedNums := arr[..];\n    sortedNums := Sort(sortedNums);\n\n    if n >= 3 && sortedNums[0] == sortedNums[n - 1] && sortedNums[0] == 0 {\n        res := [ [0, 0, 0] ];\n        return;\n    }\n\n    var resultSet := set seq<int>{};\n    var resultList := new seq<seq<int>>[0];\n\n    var index := 0;\n    while index < n - 1\n        invariant 0 <= index <= n - 1\n        invariant forall t :: 0 <= t < |resultList| ==> |resultList[t]| == 3 && resultList[t][0] + resultList[t][1] + resultList[t][2] == 0\n        invariant forall i, j :: 0 <= i < j < |resultList| ==> resultList[i] != resultList[j]\n    {\n        var left := index + 1;\n        var right := n - 1;\n        while left < right\n            invariant index + 1 <= left <= right <= n - 1\n            invariant forall t :: 0 <= t < |resultList| ==> |resultList[t]| == 3 && resultList[t][0] + resultList[t][1] + resultList[t][2] == 0\n            invariant forall i, j :: 0 <= i < j < |resultList| ==> resultList[i] != resultList[j]\n        {\n            var currSum := sortedNums[index] + sortedNums[left] + sortedNums[right];\n            if currSum == 0 {\n                var triple := [sortedNums[index], sortedNums[left], sortedNums[right]];\n                if !(triple in resultSet) {\n                    resultSet := resultSet + {triple};\n                    resultList := resultList + [triple];\n                }\n                left := left + 1;\n                right := right - 1;\n            } else {\n                // In the original code, only the case currSum == 0 is handled\n                // To match the Python code, we do not move left or right otherwise\n                // So we break the loop\n                break;\n            }\n        }\n        index := index + 1;\n    }\n    res := resultList;\n}\n\n// Helper method to sort a sequence (returns a new sorted sequence)\nfunction method Sort(s: seq<int>): seq<int>\n    ensures multiset(s) == multiset(Sort(s))\n    ensures forall i, j :: 0 <= i < j < |Sort(s)| ==> Sort(s)[i] <= Sort(s)[j]\n{\n    if |s| <= 1 then s\n    else\n        var pivot := s[0];\n        var less := [x | x in s[1..], x < pivot];\n        var equal := [x | x in s, x == pivot];\n        var greater := [x | x in s[1..], x > pivot];\n        Sort(less) + equal + Sort(greater)\n}\n```"
  },
  {
    "file_path": "1-100q/16.py",
    "transformed_code": "class Solution(object):\n\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        result, min_diff = (0, float('inf'))\n        for index in range(len(nums) - 1):\n            left = index + 1\n            right = len(nums) - 1\n            while left < right:\n                currSum = nums[index] + nums[left] + nums[right]\n                diff = abs(target - currSum)\n                if diff == 0:\n                    return target\n                if diff < min_diff:\n                    min_diff = diff\n                    result = currSum\n                if currSum < target:\n                    left += 1\n        return result",
    "program_specification": "```dafny\n// Dafny Specification and Program for threeSumClosest\n\nmethod threeSumClosest(nums: seq<int>, target: int) returns (result: int)\n    requires |nums| >= 3\n    ensures exists i, j, k :: 0 <= i < j < k < |nums| && result == nums[i] + nums[j] + nums[k]\n    ensures forall i, j, k :: 0 <= i < j < k < |nums| ==>\n        abs(target - result) <= abs(target - (nums[i] + nums[j] + nums[k]))\n{\n    var a := nums[..];\n    a := Sort(a);\n\n    var min_diff := int.Max;\n    var found := false;\n    var best := 0;\n\n    var n := |a|;\n\n    var i := 0;\n    while i < n - 2\n        invariant 0 <= i <= n - 2\n        invariant found ==> exists ii, jj, kk :: 0 <= ii < jj < kk < n && best == a[ii] + a[jj] + a[kk]\n        invariant forall ii, jj, kk :: 0 <= ii < jj < kk < n && ii < i ==> abs(target - best) <= abs(target - (a[ii] + a[jj] + a[kk]))\n    {\n        var left := i + 1;\n        var right := n - 1;\n        while left < right\n            invariant i + 1 <= left <= right + 1 <= n\n            invariant found ==> exists ii, jj, kk :: 0 <= ii < jj < kk < n && best == a[ii] + a[jj] + a[kk]\n            invariant forall ii, jj, kk :: 0 <= ii < jj < kk < n && (ii < i || (ii == i && (jj < left || kk > right))) ==> abs(target - best) <= abs(target - (a[ii] + a[jj] + a[kk]))\n        {\n            var currSum := a[i] + a[left] + a[right];\n            var diff := if target - currSum >= 0 then target - currSum else currSum - target;\n            if diff == 0 {\n                result := target;\n                return;\n            }\n            if diff < min_diff {\n                min_diff := diff;\n                best := currSum;\n                found := true;\n            }\n            if currSum < target {\n                left := left + 1;\n            } else {\n                right := right - 1;\n            }\n        }\n        i := i + 1;\n    }\n    result := best;\n}\n\n// Helper: Stable sort for sequences\nfunction method Sort(s: seq<int>): seq<int>\n    ensures multiset(Sort(s)) == multiset(s)\n    ensures forall i, j :: 0 <= i < j < |Sort(s)| ==> Sort(s)[i] <= Sort(s)[j]\n{\n    if |s| <= 1 then s\n    else\n        var pivot := s[0];\n        Sort([x | x <- s[1..], x < pivot]) +\n        [pivot] +\n        Sort([x | x <- s[1..], x >= pivot])\n}\n\n// Helper: Absolute value\nfunction method abs(x: int): int\n    ensures abs(x) >= 0\n    ensures abs(x) == x || abs(x) == -x\n{\n    if x >= 0 then x else -x\n}\n```"
  },
  {
    "file_path": "1-100q/17.py",
    "transformed_code": "class Solution(object):\n\n    def letterCombinations(self, digits):\n        phoneMap = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        number = str(digits)\n        if number == '':\n            return []\n        result = ['']\n        for char in number:\n            values = phoneMap[char]\n            new_result = []\n            for prefix in result:\n                currElement = prefix\n                for value in values:\n                    new_result.append(currElement + value)\n            result = new_result\n        return result\nprint(Solution().letterCombinations('23'))",
    "program_specification": "```dafny\n// Dafny Specification and Program for letterCombinations\n\n// Helper function: Map from digit character to string of letters\nfunction method PhoneMap(d: char): seq<char>\n    requires d in {'2','3','4','5','6','7','8','9'}\n    decreases d\n{\n    if d == '2' then ['a','b','c']\n    else if d == '3' then ['d','e','f']\n    else if d == '4' then ['g','h','i']\n    else if d == '5' then ['j','k','l']\n    else if d == '6' then ['m','n','o']\n    else if d == '7' then ['p','q','r','s']\n    else if d == '8' then ['t','u','v']\n    else ['w','x','y','z']\n}\n\n// Specification: For a given sequence of digits (as chars), return all possible letter combinations\n// Precondition: All characters in digits are in {'2','3','4','5','6','7','8','9'}\n// Postcondition: The result contains all possible combinations (as strings) where each character\n//                is chosen from the corresponding digit's mapping in PhoneMap.\n\nmethod letterCombinations(digits: seq<char>) returns (result: seq<seq<char>>)\n    requires forall d :: d in digits ==> d in {'2','3','4','5','6','7','8','9'}\n    ensures (|digits| == 0 ==> |result| == 0)\n    ensures (|digits| > 0 ==> |result| == ProductLen(digits))\n    ensures forall s :: s in result ==> |s| == |digits| &&\n        forall i :: 0 <= i < |digits| ==> s[i] in PhoneMap(digits[i])\n{\n    if |digits| == 0 {\n        result := [];\n        return;\n    }\n    var res: seq<seq<char>> := [ [] ];\n    var i := 0;\n    while i < |digits|\n        invariant 0 <= i <= |digits|\n        invariant forall s :: s in res ==> |s| == i\n        invariant forall s :: s in res ==> forall j :: 0 <= j < i ==> s[j] in PhoneMap(digits[j])\n        decreases |digits| - i\n    {\n        var letters := PhoneMap(digits[i]);\n        var newRes: seq<seq<char>> := [];\n        var j := 0;\n        while j < |res|\n            invariant 0 <= j <= |res|\n            decreases |res| - j\n        {\n            var prefix := res[j];\n            var k := 0;\n            while k < |letters|\n                invariant 0 <= k <= |letters|\n                decreases |letters| - k\n            {\n                newRes := newRes + [prefix + [letters[k]]];\n                k := k + 1;\n            }\n            j := j + 1;\n        }\n        res := newRes;\n        i := i + 1;\n    }\n    result := res;\n}\n\n// Helper function to compute the expected number of combinations\nfunction ProductLen(digits: seq<char>): nat\n    decreases digits\n{\n    if |digits| == 0 then 0\n    else if |digits| == 1 then |PhoneMap(digits[0])|\n    else |PhoneMap(digits[0])| * ProductLen(digits[1..])\n}\n```"
  }
]