{
  "results": [
    {
      "source_file": "program_001.py",
      "specification_index": 1,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CheckAlphanumericString(s):\n    \"\"\"\n    Checks if the input sequence contains at least one alphanumeric character.\n    If so, returns \"Accept\", otherwise returns \"Discard\".\n    :param s: sequence of characters (string or list of single-character strings)\n    :return: \"Accept\" or \"Discard\"\n    \"\"\"\n    if not isinstance(s, (str, list, tuple)):\n        raise TypeError(\"Input must be a sequence of characters\")\n\n    for c in s:\n        if not isinstance(c, str) or len(c) != 1:\n            raise ValueError(\"All elements must be single characters\")\n        if c.isalnum():\n            return \"Accept\"\n    return \"Discard\""
    },
    {
      "source_file": "program_007.py",
      "specification_index": 7,
      "transformation": "remove_parentheses",
      "regenerated_code": "def MultipleSplitText(text: str) -> list:\n    if not isinstance(text, str):\n        raise TypeError(\"text must be a string\")\n    # Since Dafny's comment hints at no regex split and conservative return,\n    # we return the whole text as a single part, or empty list for empty input.\n    if text == \"\":\n        return []\n    return [text]"
    },
    {
      "source_file": "program_021.py",
      "specification_index": 21,
      "transformation": "remove_parentheses",
      "regenerated_code": "def TnApa(a: int, n: int, d: int) -> int:\n    return a + (n - 1) * d"
    },
    {
      "source_file": "program_023.py",
      "specification_index": 23,
      "transformation": "remove_parentheses",
      "regenerated_code": "def EvenOrOddN(N: list):\n    if len(N) == 0:\n        raise ValueError(\"Precondition violated: |N| > 0\")\n    last = N[-1]\n    if last in ['0', '2', '4', '6', '8', 'A', 'C', 'E']:\n        return \"Even\"\n    else:\n        return \"Odd\""
    },
    {
      "source_file": "program_026.py",
      "specification_index": 26,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef ExtractLst(lst: List[List[int]]) -> List[int]:\n    if any(len(item) == 0 for item in lst):\n        raise ValueError(\"All inner lists must be non-empty\")\n    return [item[0] for item in lst]"
    },
    {
      "source_file": "program_029.py",
      "specification_index": 29,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def MaxOfTwo(x: int, y: int) -> int:\n    if x > y:\n        return x\n    else:\n        return y"
    },
    {
      "source_file": "program_031.py",
      "specification_index": 31,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef MulListNums(nums1: List[int], nums2: List[int]) -> List[int]:\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Precondition violated: nums1 and nums2 must have the same length.\")\n    return [a * b for a, b in zip(nums1, nums2)]"
    },
    {
      "source_file": "program_034.py",
      "specification_index": 34,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import Sequence\n\ndef SwapCounts(s: Sequence[str]) -> int:\n    count_left = 0\n    count_right = 0\n    swap = 0\n    imbalance = 0\n    i = 0\n    while i < len(s):\n        if s[i] == 'L':\n            count_left += 1\n            if imbalance > 0:\n                swap += imbalance\n                imbalance -= 1\n        elif s[i] == 'R':\n            count_right += 1\n            imbalance += 1\n        i += 1\n    if swap < 0:\n        swap = 0\n    return swap"
    },
    {
      "source_file": "program_052.py",
      "specification_index": 52,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ConnectionRequiresHttpTunnel(proxyUrlIsNull: bool, proxyUrlScheme: str, proxyConfigIsNull: bool, useForwardingForHttps: bool, destinationScheme: str) -> bool:\n    if proxyConfigIsNull or proxyUrlIsNull:\n        return False\n    if proxyUrlScheme.lower() != \"http\":\n        return False\n    if destinationScheme.lower() == \"https\":\n        return not useForwardingForHttps\n    return False"
    },
    {
      "source_file": "program_056.py",
      "specification_index": 56,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef DivList(nums1: List[int], nums2: List[int]) -> List[float]:\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Input lists must have the same length.\")\n    if any(n == 0 for n in nums2):\n        raise ZeroDivisionError(\"Division by zero encountered in nums2.\")\n    return [a / b for a, b in zip(nums1, nums2)]"
    },
    {
      "source_file": "program_061.py",
      "specification_index": 61,
      "transformation": "json_combined_remove_indent_15_20250909_074202",
      "regenerated_code": "def CheckIsosceles(x: int, y: int, z: int) -> bool:\n    return x != y and y != z and z != x"
    },
    {
      "source_file": "program_063.py",
      "specification_index": 63,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef RotateLeft(list1: List[int], m: int, n: int) -> List[int]:\n    if not (0 <= m <= n <= len(list1)):\n        raise ValueError(\"Precondition violated: 0 <= m <= n <= len(list1)\")\n    return list1[m:n]"
    },
    {
      "source_file": "program_065.py",
      "specification_index": 65,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CountUnsetBits(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"Precondition violated: n >= 1\")\n    cnt = 0\n    i = 1\n    while i <= n:\n        if (n & i) == 0:\n            cnt += 1\n        i <<= 1\n    return cnt"
    },
    {
      "source_file": "program_069.py",
      "specification_index": 69,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def ValidityTriangle(a: int, b: int, c: int) -> bool:\n    return a + b + c == 180"
    },
    {
      "source_file": "program_076.py",
      "specification_index": 76,
      "transformation": "remove_parentheses",
      "regenerated_code": "def GetItemTup1(tup1: list[int], index: int) -> int:\n    if not (0 <= index < len(tup1)):\n        raise IndexError(\"index out of bounds\")\n    return tup1[index]"
    },
    {
      "source_file": "program_079.py",
      "specification_index": 79,
      "transformation": "remove_parentheses",
      "regenerated_code": "def PressureUnits():\n    # List of supported pressure units\n    # Standard units: pascal, bar, atm, torr, psi\n    return {\"Pa\", \"bar\", \"atm\", \"Torr\", \"psi\"}\n\ndef _pressure_unit_to_pa_factor(unit):\n    # Returns the factor to convert from the given unit to pascal (Pa)\n    factors = {\n        \"Pa\": 1.0,\n        \"bar\": 1e5,\n        \"atm\": 101325.0,\n        \"Torr\": 133.322368,\n        \"psi\": 6894.757293168,\n    }\n    return factors[unit]\n\ndef PressureConversion(value, fromType, toType):\n    if fromType not in PressureUnits():\n        raise ValueError(f\"fromType '{fromType}' not in supported PressureUnits\")\n    if toType not in PressureUnits():\n        raise ValueError(f\"toType '{toType}' not in supported PressureUnits\")\n    # Convert value to pascals\n    value_in_pa = float(value) * _pressure_unit_to_pa_factor(fromType)\n    # Convert from pascals to target unit\n    result = value_in_pa / _pressure_unit_to_pa_factor(toType)\n    return result"
    },
    {
      "source_file": "program_080.py",
      "specification_index": 80,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def Maximum(a: int, b: int) -> int:\n    if a >= b:\n        return a\n    else:\n        return b"
    },
    {
      "source_file": "program_090.py",
      "specification_index": 90,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def RectangleArea(l: int, b: int) -> int:\n    return l * b"
    },
    {
      "source_file": "program_091.py",
      "specification_index": 91,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ClosestNumN(N: int) -> int:\n    return N - 1"
    },
    {
      "source_file": "program_095.py",
      "specification_index": 95,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def StringLength(str1):\n    if not isinstance(str1, (list, tuple, str)):\n        raise TypeError(\"str1 must be a sequence of characters\")\n    count = 0\n    i = 0\n    n = len(str1)\n    while i < n:\n        count += 1\n        i += 1\n    return count"
    },
    {
      "source_file": "program_098.py",
      "specification_index": 98,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import Union\n\nclass Tree:\n    pass\n\nclass Leaf(Tree):\n    def __eq__(self, other):\n        return isinstance(other, Leaf)\n\nclass Node(Tree):\n    def __init__(self, left: Tree, right: Tree):\n        self.left = left\n        self.right = right\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, Node)\n            and self.left == other.left\n            and self.right == other.right\n        )\n\ndef MaxHeightNode(t: Tree) -> int:\n    if isinstance(t, Leaf):\n        return 0\n    elif isinstance(t, Node):\n        left_h = MaxHeightNode(t.left)\n        right_h = MaxHeightNode(t.right)\n        return 1 + max(left_h, right_h)\n    else:\n        raise TypeError(\"t must be a Tree (Leaf or Node)\")"
    },
    {
      "source_file": "program_103.py",
      "specification_index": 103,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ClosestX(x: int) -> int:\n    if x < 0:\n        raise ValueError(\"Precondition violated: x >= 0\")\n    ans = 0\n    while ans * 10 + 9 <= x:\n        ans = ans * 10 + 9\n    return ans"
    },
    {
      "source_file": "program_106.py",
      "specification_index": 106,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import Set, Tuple\n\ndef ExtractSymmetricTestList(test_list: Set[Tuple[int, int]]) -> Set[Tuple[int, int]]:\n    res = set()\n    for ab in test_list:\n        a, b = ab\n        if a < b:\n            res.add((a, b))\n    return res"
    },
    {
      "source_file": "program_109.py",
      "specification_index": 109,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef SubtractElements(testTup1: List[int], testTup2: List[int]) -> List[int]:\n    if len(testTup1) != len(testTup2):\n        raise ValueError(\"Input sequences must have the same length\")\n    res = [a - b for a, b in zip(testTup1, testTup2)]\n    return res"
    },
    {
      "source_file": "program_114.py",
      "specification_index": 114,
      "transformation": "remove_parentheses",
      "regenerated_code": "def DoesContain(a: int, b: int, c: int) -> bool:\n    if a == b:\n        return True\n    if c == 0:\n        return False\n    diff = b - a\n    return diff > 0 and diff % c == 0"
    },
    {
      "source_file": "program_115.py",
      "specification_index": 115,
      "transformation": "remove_parentheses",
      "regenerated_code": "def NewmanPrimeN(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Precondition violated: n >= 0\")\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return NewmanPrimeN(n - 1) + NewmanPrimeN(n - 2)"
    },
    {
      "source_file": "program_119.py",
      "specification_index": 119,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ReverseFloyd(n: int) -> str:\n    if n < 0:\n        raise ValueError(\"Precondition failed: n >= 0\")\n    lines = []\n    for i in range(n):\n        spaces = ' ' * i\n        stars = '* ' * (n - i)\n        lines.append(f\"{spaces}{stars.rstrip()}\")\n    return '\\n'.join(lines)"
    },
    {
      "source_file": "program_121.py",
      "specification_index": 121,
      "transformation": "remove_parentheses",
      "regenerated_code": "def DegreeFromRadian(radian: float) -> float:\n    return radian * 180.0 / 3.141592653589793"
    },
    {
      "source_file": "program_122.py",
      "specification_index": 122,
      "transformation": "remove_parentheses",
      "regenerated_code": "def PytestWarnsWarning(warning: int) -> int:\n    # In this placeholder implementation, we assume that 'warning' is an int,\n    # and 'cm' is also an int, as per the Dafny specification's use of int as a placeholder.\n    # No preconditions are specified, so we simply return the input as output.\n    return warning"
    },
    {
      "source_file": "program_123.py",
      "specification_index": 123,
      "transformation": "remove_parentheses",
      "regenerated_code": "def FromCtypesUnion():\n    \"\"\"\n    Constructs a numpy dtype from a ctypes Union with two fields: 'a' (int32) and 'b' (float32),\n    matching the typical use case for such a function.\n    \"\"\"\n    import numpy as np\n    return np.dtype([('a', np.int32), ('b', np.float32)])"
    },
    {
      "source_file": "program_124.py",
      "specification_index": 124,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef CheckKInSeq(test_tup: List[int], K: int) -> bool:\n    \"\"\"\n    Returns True iff there exists an index i such that 0 <= i < len(test_tup) and test_tup[i] == K.\n    \"\"\"\n    i = 0\n    while i < len(test_tup):\n        if test_tup[i] == K:\n            return True\n        i += 1\n    return False"
    },
    {
      "source_file": "program_136.py",
      "specification_index": 136,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CheckMonthNumMonthName1(monthname1: str) -> bool:\n    return monthname1 == \"February\""
    },
    {
      "source_file": "program_137.py",
      "specification_index": 137,
      "transformation": "remove_parentheses",
      "regenerated_code": "def MergeDictionaries(dict1: dict[int, int], dict2: dict[int, int], dict3: dict[int, int]) -> dict[int, int]:\n    if dict1 is None or dict2 is None or dict3 is None:\n        raise ValueError(\"Input dictionaries must not be None\")\n    merged = {}\n    for d in (dict1, dict2, dict3):\n        merged.update(d)\n    return merged"
    },
    {
      "source_file": "program_138.py",
      "specification_index": 138,
      "transformation": "remove_parentheses",
      "regenerated_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef ShowPhaseResponse(filterType: object, samplerate: int):\n    if samplerate <= 0:\n        raise ValueError(\"samplerate must be > 0\")\n\n    # Placeholder: example phase response plot for demonstration\n    # In a real implementation, filterType would determine the filter coefficients\n    # Here, we just show a generic phase response for a simple lowpass FIR filter\n\n    # Example: create a simple lowpass FIR filter\n    from scipy.signal import firwin, freqz\n\n    numtaps = 31\n    cutoff = 0.2  # normalized cutoff frequency (relative to Nyquist)\n    if hasattr(filterType, 'cutoff'):\n        cutoff = filterType.cutoff\n    taps = firwin(numtaps, cutoff)\n\n    w, h = freqz(taps, worN=8000, fs=samplerate)\n    phase = np.unwrap(np.angle(h))\n\n    plt.figure()\n    plt.plot(w, phase)\n    plt.title(\"Phase Response\")\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.ylabel(\"Phase (radians)\")\n    plt.grid(True)\n    plt.show()"
    },
    {
      "source_file": "program_143.py",
      "specification_index": 143,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef RearExtractTestList(test_list: List[List[int]]) -> List[int]:\n    if not all(len(lis) > 0 for lis in test_list):\n        raise ValueError(\"All inner lists must have length > 0\")\n    return [lis[-1] for lis in test_list]"
    },
    {
      "source_file": "program_149.py",
      "specification_index": 149,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RemoveZeroIp(ip: str) -> str:\n    if not isinstance(ip, str):\n        raise TypeError(\"ip must be a string\")\n    # The Dafny spec is a placeholder that returns ip as is.\n    return ip"
    },
    {
      "source_file": "program_150.py",
      "specification_index": 150,
      "transformation": "remove_parentheses",
      "regenerated_code": "def BinomialCoeff(n: int, k: int) -> int:\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    # Use symmetry to minimize computation\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result"
    },
    {
      "source_file": "program_152.py",
      "specification_index": 152,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "from typing import List\n\ndef CheckElement(testTup: List[int], checkList: List[int]) -> bool:\n    for i in range(len(checkList)):\n        if checkList[i] in testTup:\n            return True\n    return False"
    },
    {
      "source_file": "program_159.py",
      "specification_index": 159,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef DivisionElementsTestTup(testTup1: List[int], testTup2: List[int]) -> List[int]:\n    if len(testTup1) != len(testTup2):\n        raise ValueError(\"Input sequences must have the same length\")\n    if any(x == 0 for x in testTup2):\n        raise ZeroDivisionError(\"Division by zero in testTup2\")\n    return [a // b for a, b in zip(testTup1, testTup2)]"
    },
    {
      "source_file": "program_160.py",
      "specification_index": 160,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef DiffConsecutive(nums: List[int]) -> List[int]:\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list of integers\")\n    if any(not isinstance(x, int) for x in nums):\n        raise TypeError(\"All elements of nums must be integers\")\n    n = len(nums)\n    if n == 0 or n == 1:\n        return []\n    return [nums[i+1] - nums[i] for i in range(n - 1)]"
    },
    {
      "source_file": "program_166.py",
      "specification_index": 166,
      "transformation": "remove_parentheses",
      "regenerated_code": "def IsSuccessCode(code: int) -> bool:\n    return 200 <= code <= 299"
    },
    {
      "source_file": "program_170.py",
      "specification_index": 170,
      "transformation": "remove_parentheses",
      "regenerated_code": "def AsciiValue(k: str) -> int:\n    if not isinstance(k, str) or len(k) != 1:\n        raise ValueError(\"Input must be a single character.\")\n    return ord(k)"
    },
    {
      "source_file": "program_173.py",
      "specification_index": 173,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef SubListNums(nums1: List[int], nums2: List[int]) -> List[int]:\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Precondition violated: nums1 and nums2 must have the same length\")\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] if nums1[i] < nums2[i] else nums2[i])\n    return result"
    },
    {
      "source_file": "program_175.py",
      "specification_index": 175,
      "transformation": "remove_parentheses",
      "regenerated_code": "def DecimalToOctaldeciNum(deciNum: int) -> int:\n    if deciNum < 0:\n        raise ValueError(\"deciNum must be non-negative\")\n    if deciNum == 0:\n        return 0\n    digits = []\n    n = deciNum\n    while n > 0:\n        digits.append(str(n % 8))\n        n //= 8\n    octal_str = ''.join(reversed(digits))\n    octalNum = int(octal_str)\n    return octalNum"
    },
    {
      "source_file": "program_179.py",
      "specification_index": 179,
      "transformation": "remove_parentheses",
      "regenerated_code": "def BigDiffnums(maxnums: int, minnums: int) -> int:\n    return maxnums - minnums"
    },
    {
      "source_file": "program_182.py",
      "specification_index": 182,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ListTuplelistx(tuplelistx):\n    if not isinstance(tuplelistx, (list, tuple)):\n        raise TypeError(\"tuplelistx must be a sequence of integers\")\n    # Optionally, check all elements are int\n    if not all(isinstance(x, int) for x in tuplelistx):\n        raise TypeError(\"All elements of tuplelistx must be integers\")\n    return list(tuplelistx)"
    },
    {
      "source_file": "program_184.py",
      "specification_index": 184,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def EvenNum(x: int) -> bool:\n    return x % 2 == 0"
    },
    {
      "source_file": "program_185.py",
      "specification_index": 185,
      "transformation": "remove_parentheses",
      "regenerated_code": "def SumNaturalN(n: int) -> int:\n    return n * n + 1"
    },
    {
      "source_file": "program_190.py",
      "specification_index": 190,
      "transformation": "remove_parentheses",
      "regenerated_code": "def FindDivisor(x: int, y: int) -> int:\n    if x == y:\n        return y\n    else:\n        return 2"
    },
    {
      "source_file": "program_195.py",
      "specification_index": 195,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RectanglePerimeter(l: int, b: int) -> int:\n    return 2 * l + b"
    },
    {
      "source_file": "program_201.py",
      "specification_index": 201,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef ListifyListList1(listmap: List[List[int]], list1: List[int]) -> List[List[int]]:\n    return listmap + [list1]"
    },
    {
      "source_file": "program_209.py",
      "specification_index": 209,
      "transformation": "remove_parentheses",
      "regenerated_code": "def MatchNumString(s: str) -> bool:\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    if len(s) > 0 and s[0] == '5':\n        return True\n    else:\n        return False"
    },
    {
      "source_file": "program_222.py",
      "specification_index": 222,
      "transformation": "remove_parentheses",
      "regenerated_code": "def MakeFlipCh(ch: str) -> str:\n    if not (ch == '0' or ch == '1'):\n        raise ValueError(\"Precondition failed: ch must be '0' or '1'\")\n    if ch == '0':\n        return '1'\n    else:\n        return '0'"
    },
    {
      "source_file": "program_242.py",
      "specification_index": 242,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CheckEqualityStr(s):\n    if not isinstance(s, (list, tuple, str)):\n        raise TypeError(\"s must be a sequence of characters\")\n    if len(s) == 0:\n        raise ValueError(\"Precondition violated: |s| > 0\")\n    first = s[0]\n    last = s[-1]\n    if first == last:\n        return \"Equal\"\n    else:\n        return \"Not Equal\""
    },
    {
      "source_file": "program_258.py",
      "specification_index": 258,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "from typing import List\n\ndef TupleModulo(testTup1: List[int], testTup2: List[int]) -> List[int]:\n    if len(testTup1) != len(testTup2):\n        raise ValueError(\"Input sequences must have the same length.\")\n    if any(x == 0 for x in testTup2):\n        raise ValueError(\"All elements of testTup2 must be non-zero.\")\n    return [a % b for a, b in zip(testTup1, testTup2)]"
    },
    {
      "source_file": "program_263.py",
      "specification_index": 263,
      "transformation": "remove_parentheses",
      "regenerated_code": "def AddTupleToList(test_list, test_tup):\n    if not (isinstance(test_list, (list, tuple)) and isinstance(test_tup, (list, tuple))):\n        raise TypeError(\"Both arguments must be sequences of integers\")\n    if not all(isinstance(x, int) for x in test_list):\n        raise TypeError(\"test_list must contain only integers\")\n    if not all(isinstance(x, int) for x in test_tup):\n        raise TypeError(\"test_tup must contain only integers\")\n    return list(test_list) + list(test_tup)"
    },
    {
      "source_file": "program_264.py",
      "specification_index": 264,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef IndexMinimumTestList(mintest_list: List[List[int]]) -> List[int]:\n    if len(mintest_list) == 0:\n        raise ValueError(\"mintest_list must have at least one element\")\n    for s in mintest_list:\n        if len(s) == 0:\n            raise ValueError(\"Each subsequence in mintest_list must have at least one element\")\n    min_index = 0\n    min_seq = mintest_list[0]\n    min_val = min_seq[0]\n    for i, seq in enumerate(mintest_list):\n        seq_min = min(seq)\n        if seq_min < min_val:\n            min_val = seq_min\n            min_seq = seq\n            min_index = i\n    return min_seq"
    },
    {
      "source_file": "program_271.py",
      "specification_index": 271,
      "transformation": "remove_parentheses",
      "regenerated_code": "def SumEven(l: int, r: int) -> int:\n    if l > r:\n        raise ValueError(\"Precondition violated: l must be less than or equal to r.\")\n    return (r // 2) - ((l + 1) // 2)"
    },
    {
      "source_file": "program_274.py",
      "specification_index": 274,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CountNoOfWays(n: int, k: int) -> int:\n    if n < 1 or k < 1:\n        raise ValueError(\"Preconditions: n >= 1 and k >= 1\")\n    mod = 1000000007\n    dp = [0] * (n + 2)\n    if n == 1:\n        return k % mod\n    dp[1] = k % mod\n    dp[2] = (k * (k - 1)) % mod\n    for i in range(3, n + 1):\n        dp[i] = ((dp[i-1] * (k - 1)) % mod + (dp[i-2] * (k - 1)) % mod) % mod\n    return dp[n]"
    },
    {
      "source_file": "program_276.py",
      "specification_index": 276,
      "transformation": "remove_parentheses",
      "regenerated_code": "def TextMatchWordText(text: str) -> str:\n    if text == \"word\":\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\""
    },
    {
      "source_file": "program_277.py",
      "specification_index": 277,
      "transformation": "remove_parentheses",
      "regenerated_code": "def MedianNumbers(a: int, b: int, c: int) -> int:\n    # No preconditions to enforce\n    # Compute the median of three numbers\n    if (a <= b <= c) or (c <= b <= a):\n        return b\n    elif (b <= a <= c) or (c <= a <= b):\n        return a\n    else:\n        return c"
    },
    {
      "source_file": "program_278.py",
      "specification_index": 278,
      "transformation": "remove_parentheses",
      "regenerated_code": "def SymbolOfArg(arg: int) -> int:\n    return arg"
    },
    {
      "source_file": "program_280.py",
      "specification_index": 280,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef ModDivList(nums1: List[int], nums2: List[int]) -> List[int]:\n    if len(nums1) != len(nums2):\n        raise ValueError(\"nums1 and nums2 must have the same length\")\n    if any(x == 0 for x in nums2):\n        raise ValueError(\"All elements of nums2 must be nonzero\")\n    return [a % b for a, b in zip(nums1, nums2)]"
    },
    {
      "source_file": "program_289.py",
      "specification_index": 289,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ClearLruCaches():\n    pass"
    },
    {
      "source_file": "program_290.py",
      "specification_index": 290,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def MergeDict(d1: dict[int, int], d2: dict[int, int]) -> dict[int, int]:\n    if not isinstance(d1, dict) or not isinstance(d2, dict):\n        raise TypeError(\"Both arguments must be dictionaries.\")\n    for k, v in d1.items():\n        if not isinstance(k, int) or not isinstance(v, int):\n            raise TypeError(\"All keys and values in d1 must be integers.\")\n    for k, v in d2.items():\n        if not isinstance(k, int) or not isinstance(v, int):\n            raise TypeError(\"All keys and values in d2 must be integers.\")\n    d = d1.copy()\n    d.update(d2)\n    return d"
    },
    {
      "source_file": "program_292.py",
      "specification_index": 292,
      "transformation": "remove_parentheses",
      "regenerated_code": "def TextMatch(text: str) -> str:\n    if text is None:\n        raise ValueError(\"text must not be None\")\n    import re\n    # Checks for 'a' followed by zero or more 'b's\n    pattern = r'a(b*)'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\""
    },
    {
      "source_file": "program_298.py",
      "specification_index": 298,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List, Tuple\n\ndef TupleIntStr(tuple_str: List[Tuple[int, str]]) -> List[Tuple[int, str]]:\n    # The specification seems to require that the output sequence has the same length as input,\n    # and for all i, result[i][0] == tuple_str[i][0]\n    # Since the full postcondition is not visible, we assume we must preserve the int part,\n    # and possibly can modify the string part (but since no further info, we return the input as is).\n    if not isinstance(tuple_str, list):\n        raise TypeError(\"tuple_str must be a list of (int, str) tuples\")\n    for t in tuple_str:\n        if not (isinstance(t, tuple) and len(t) == 2 and isinstance(t[0], int) and isinstance(t[1], str)):\n            raise TypeError(\"Each element of tuple_str must be a tuple (int, str)\")\n    return list(tuple_str)"
    },
    {
      "source_file": "program_306.py",
      "specification_index": 306,
      "transformation": "remove_parentheses",
      "regenerated_code": "def Slope(x1: int, y1: int, x2: int, y2: int) -> float:\n    if x2 == x1:\n        raise ValueError(\"Precondition violated: x2 must not be equal to x1\")\n    return (y2 - y1) / (x2 - x1)"
    },
    {
      "source_file": "program_309.py",
      "specification_index": 309,
      "transformation": "remove_parentheses",
      "regenerated_code": "def IsLowerString(s: str) -> bool:\n    for i in range(len(s)):\n        c = s[i]\n        if not ('a' <= c <= 'z'):\n            return False\n    return True"
    },
    {
      "source_file": "program_312.py",
      "specification_index": 312,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RemoveAllSpaces(text):\n    if not isinstance(text, (list, tuple, str)):\n        raise TypeError(\"text must be a sequence of characters\")\n    result = []\n    for c in text:\n        if c not in {' ', '\\t', '\\n', '\\r'}:\n            result.append(c)\n    if isinstance(text, str):\n        return ''.join(result)\n    else:\n        return type(text)(result)"
    },
    {
      "source_file": "program_315.py",
      "specification_index": 315,
      "transformation": "remove_parentheses",
      "regenerated_code": "def PrimeNum(num: int) -> bool:\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num ** 0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return True"
    },
    {
      "source_file": "program_316.py",
      "specification_index": 316,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef IsUndulating(n: List[int]) -> bool:\n    if len(n) <= 2:\n        return False\n    for i in range(2, len(n)):\n        if n[i] != n[i - 2]:\n            return False\n    return True"
    },
    {
      "source_file": "program_317.py",
      "specification_index": 317,
      "transformation": "json_combined_remove_indent_15_20250909_074202",
      "regenerated_code": "def CheckValidity(a: int, b: int, c: int) -> bool:\n    return (a + b > c) and (a + c > b) and (b + c > a)"
    },
    {
      "source_file": "program_319.py",
      "specification_index": 319,
      "transformation": "remove_parentheses",
      "regenerated_code": "import random\n\ndef RandomPivotLst(choicelst):\n    if len(choicelst) == 0:\n        raise ValueError(\"choicelst must have at least one element\")\n    return choicelst[0]"
    },
    {
      "source_file": "program_321.py",
      "specification_index": 321,
      "transformation": "remove_parentheses",
      "regenerated_code": "def Fibonacci(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"Precondition violated: n >= 1\")\n    if n == 1 or n == 2:\n        return 1\n    f1 = 1\n    f2 = 1\n    for _ in range(3, n + 1):\n        f = f1 + f2\n        f1, f2 = f2, f\n    return f2"
    },
    {
      "source_file": "program_339.py",
      "specification_index": 339,
      "transformation": "remove_parentheses",
      "regenerated_code": "def DfsMaze(x, y, depth, prev_dir):\n    # Placeholder implementation: just return a fixed value.\n    # In a real maze, this would explore the maze recursively.\n    return 0\n\ndef FindPathMaze():\n    cnt = DfsMaze(0, 0, 0, -1)\n    return cnt"
    },
    {
      "source_file": "program_342.py",
      "specification_index": 342,
      "transformation": "remove_parentheses",
      "regenerated_code": "def TextMatch(text: str) -> str:\n    # Since the Dafny spec is incomplete and only requires that the result\n    # is either \"Found a match!\" or \"Not matched!\", we must return one of them.\n    # To make this meaningful, let's check if the substring \"match\" is in the text.\n    if \"match\" in text:\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\""
    },
    {
      "source_file": "program_345.py",
      "specification_index": 345,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef SeqFlatten(s: List[List[int]]) -> List[int]:\n    if len(s) == 0:\n        return []\n    else:\n        return s[0] + SeqFlatten(s[1:])\n\ndef FlattenIterable(s: List[List[int]]) -> List[int]:\n    return SeqFlatten(s)"
    },
    {
      "source_file": "program_363.py",
      "specification_index": 363,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RealPower(apparent_power: float, power_factor: float) -> float:\n    if not (-1.0 <= power_factor <= 1.0):\n        raise ValueError(\"power_factor must be between -1.0 and 1.0 inclusive\")\n    return apparent_power * power_factor"
    },
    {
      "source_file": "program_365.py",
      "specification_index": 365,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "from typing import List\n\ndef AddNestedTuples(testTup1: List[List[int]], testTup2: List[List[int]]) -> List[List[int]]:\n    if len(testTup1) != len(testTup2):\n        raise ValueError(\"testTup1 and testTup2 must have the same length\")\n    res = []\n    for i in range(len(testTup1)):\n        if len(testTup1[i]) != len(testTup2[i]):\n            raise ValueError(f\"Inner tuples at index {i} have different lengths\")\n        inner = []\n        for a, b in zip(testTup1[i], testTup2[i]):\n            inner.append(a + b)\n        res.append(inner)\n    return res"
    },
    {
      "source_file": "program_375.py",
      "specification_index": 375,
      "transformation": "remove_parentheses",
      "regenerated_code": "def UnionElements(test_tup1, test_tup2):\n    if not isinstance(test_tup1, (list, tuple)) or not isinstance(test_tup2, (list, tuple)):\n        raise TypeError(\"Inputs must be sequences of integers.\")\n    if not all(isinstance(x, int) for x in test_tup1):\n        raise TypeError(\"All elements of test_tup1 must be integers.\")\n    if not all(isinstance(x, int) for x in test_tup2):\n        raise TypeError(\"All elements of test_tup2 must be integers.\")\n    return list(test_tup1) + list(test_tup2)"
    },
    {
      "source_file": "program_384.py",
      "specification_index": 384,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def CountIntegralPoints(x1: int, y1: int, x2: int, y2: int) -> int:\n    return (y2 - y1 - 1) * (x2 - x1 - 1)"
    },
    {
      "source_file": "program_394.py",
      "specification_index": 394,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CheckString(s: str) -> str:\n    vowels = set(\"AEIOUaeiou\")\n    unique_vowels = set(c for c in s if c in vowels)\n    if len(unique_vowels) >= 5:\n        return \"accepted\"\n    else:\n        return \"not accepted\""
    },
    {
      "source_file": "program_396.py",
      "specification_index": 396,
      "transformation": "remove_parentheses",
      "regenerated_code": "def StrToListString(s):\n    if not isinstance(s, (str, list, tuple)):\n        raise TypeError(\"Input must be a sequence of characters\")\n    # Convert to list of characters if not already\n    res = []\n    i = 0\n    while i < len(s):\n        res.append(s[i])\n        i += 1\n    return res"
    },
    {
      "source_file": "program_404.py",
      "specification_index": 404,
      "transformation": "remove_parentheses",
      "regenerated_code": "def FrontAndRearTestTup(testTup):\n    if len(testTup) < 1:\n        raise ValueError(\"Precondition violated: |testTup| >= 1\")\n    return (testTup[0], testTup[-1])"
    },
    {
      "source_file": "program_405.py",
      "specification_index": 405,
      "transformation": "remove_parentheses",
      "regenerated_code": "def AccessKey(dct: dict[int, int], key: int) -> int:\n    if key not in dct:\n        raise KeyError(f\"Key {key} not found in dictionary.\")\n    return dct[key]"
    },
    {
      "source_file": "program_410.py",
      "specification_index": 410,
      "transformation": "remove_parentheses",
      "regenerated_code": "def LastN(n):\n    if len(n) <= 0:\n        raise ValueError(\"Precondition violated: |n| > 0\")\n    return n[len(n) - 1]"
    },
    {
      "source_file": "program_411.py",
      "specification_index": 411,
      "transformation": "remove_parentheses",
      "regenerated_code": "import math\n\ndef CheckTypeOfTriangle(a: int, b: int, c: int) -> str:\n    if not (a > 0 and b > 0 and c > 0):\n        raise ValueError(\"All sides must be positive integers\")\n    sides = sorted([a, b, c])\n    x, y, z = sides  # x <= y <= z\n\n    # Triangle inequality\n    if x + y <= z:\n        raise ValueError(\"The given sides do not form a triangle\")\n\n    x2, y2, z2 = x * x, y * y, z * z\n    if z2 == x2 + y2:\n        return \"Right-angled Triangle\"\n    elif z2 > x2 + y2:\n        return \"Obtuse-angled Triangle\"\n    else:\n        return \"Acute-angled Triangle\""
    },
    {
      "source_file": "program_412.py",
      "specification_index": 412,
      "transformation": "remove_parentheses",
      "regenerated_code": "def GetDemoGraphIndex(index: int) -> dict[int, list[int]]:\n    if not (0 <= index < 4):\n        raise ValueError(\"index must be in the range 0 <= index < 4\")\n    if index == 0:\n        return {\n            0: [1, 2],\n            1: [0, 2],\n            2: [0, 1, 3, 4],\n            3: [2, 4],\n            4: [2, 3]\n        }\n    elif index == 1:\n        # Example: a simple cycle\n        return {\n            0: [1],\n            1: [2],\n            2: [3],\n            3: [0]\n        }\n    elif index == 2:\n        # Example: star graph\n        return {\n            0: [1, 2, 3, 4],\n            1: [0],\n            2: [0],\n            3: [0],\n            4: [0]\n        }\n    elif index == 3:\n        # Example: disconnected graph\n        return {\n            0: [1],\n            1: [0],\n            2: [],\n            3: [4],\n            4: [3]\n        }"
    },
    {
      "source_file": "program_413.py",
      "specification_index": 413,
      "transformation": "remove_parentheses",
      "regenerated_code": "def ElectricPowerVoltage(voltage: float, current: float, power: float) -> (str, float):\n    zero_count = sum([\n        1 if voltage == 0.0 else 0,\n        1 if current == 0.0 else 0,\n        1 if power == 0.0 else 0\n    ])\n    if zero_count != 1:\n        raise ValueError(\"Exactly one of voltage, current, or power must be zero.\")\n    if voltage == 0.0:\n        # Compute voltage from power and current: V = P / I\n        if current == 0.0:\n            raise ValueError(\"Current must not be zero when computing voltage.\")\n        result = power / current\n        return (\"voltage\", result)\n    elif current == 0.0:\n        # Compute current from power and voltage: I = P / V\n        if voltage == 0.0:\n            raise ValueError(\"Voltage must not be zero when computing current.\")\n        result = power / voltage\n        return (\"current\", result)\n    else:\n        # Compute power from voltage and current: P = V * I\n        result = voltage * current\n        return (\"power\", result)"
    },
    {
      "source_file": "program_420.py",
      "specification_index": 420,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CheckMonthnumNumbermonthnum2(monthnum2: int) -> bool:\n    # Returns True if monthnum2 is a month number with 31 days (Jan, Mar, May, Jul, Aug, Oct, Dec)\n    return monthnum2 in {1, 3, 5, 7, 8, 10, 12}"
    },
    {
      "source_file": "program_421.py",
      "specification_index": 421,
      "transformation": "remove_parentheses",
      "regenerated_code": "def LengthOfLastWord(a):\n    if not isinstance(a, (list, tuple, str)):\n        raise TypeError(\"Input must be a sequence of characters\")\n    n = len(a)\n    l = 0\n    i = n - 1\n    # Skip trailing spaces\n    while i >= 0 and a[i] == ' ':\n        i -= 1\n    # Count length of last word\n    while i >= 0 and a[i] != ' ':\n        l += 1\n        i -= 1\n    return l"
    },
    {
      "source_file": "program_424.py",
      "specification_index": 424,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RemoveMultipleSpaces(text1):\n    if not isinstance(text1, (list, tuple, str)):\n        raise TypeError(\"text1 must be a sequence of characters\")\n    # Convert to list for mutability if needed\n    chars = list(text1)\n    res = []\n    prev_space = False\n    for c in chars:\n        if c == ' ':\n            if not prev_space:\n                res.append(c)\n                prev_space = True\n            # else: skip this space (it's a duplicate)\n        else:\n            res.append(c)\n            prev_space = False\n    return res"
    },
    {
      "source_file": "program_431.py",
      "specification_index": 431,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef ParseStrings(strs: List[str]) -> List[str]:\n    # Since the spec does not define actual parsing logic,\n    # we'll just return a subset (possibly all) of the input strings,\n    # ensuring each result element is from the input and no more than input length.\n    # Here, we return the input as-is, which satisfies the spec.\n    if not isinstance(strs, list):\n        raise TypeError(\"Input must be a list of strings\")\n    for s in strs:\n        if not isinstance(s, str):\n            raise TypeError(\"All elements of input must be strings\")\n    return list(strs)"
    },
    {
      "source_file": "program_432.py",
      "specification_index": 432,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def CheckSolution(a: int, b: int, c: int) -> str:\n    if a == c:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
      "source_file": "program_437.py",
      "specification_index": 437,
      "transformation": "json_combined_prompt_14_20250905_140700",
      "regenerated_code": "def CountList(inputList):\n    if inputList is None:\n        raise ValueError(\"inputList must not be None\")\n    return len(inputList)"
    },
    {
      "source_file": "program_452.py",
      "specification_index": 452,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RomanToInts(s):\n    \"\"\"\n    Converts a sequence of Roman numeral characters to its integer value.\n    Preconditions:\n        - All elements in s must be one of {'I', 'V', 'X', 'L', 'C', 'D', 'M'}\n    Postconditions:\n        - The returned value is an integer >= 0\n    \"\"\"\n    romVal = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    # Precondition check\n    for ch in s:\n        if ch not in romVal:\n            raise ValueError(f\"Invalid Roman numeral character: {ch}\")\n\n    n = len(s)\n    intVal = 0\n    i = 0\n    while i < n:\n        curr = romVal[s[i]]\n        if i + 1 < n and romVal[s[i]] < romVal[s[i + 1]]:\n            intVal += romVal[s[i + 1]] - romVal[s[i]]\n            i += 2\n        else:\n            intVal += curr\n            i += 1\n    return intVal"
    },
    {
      "source_file": "program_459.py",
      "specification_index": 459,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef CheckDistinctTestTup(testTup: List[int]) -> bool:\n    seen = set()\n    for val in testTup:\n        if val in seen:\n            return False\n        seen.add(val)\n    return True"
    },
    {
      "source_file": "program_460.py",
      "specification_index": 460,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef SumList(lst1: List[int], lst2: List[int]) -> List[int]:\n    if len(lst1) != len(lst2):\n        raise ValueError(\"Input lists must have the same length.\")\n    return [a + b for a, b in zip(lst1, lst2)]"
    },
    {
      "source_file": "program_474.py",
      "specification_index": 474,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CountSetBits(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Precondition violated: n >= 0\")\n    m = n + 1\n    powerOf2 = 2\n    cnt = m // 2\n    while powerOf2 <= m:\n        cnt += (m // powerOf2) * (powerOf2 // 2) + max(0, (m % powerOf2) - (powerOf2 // 2))\n        powerOf2 *= 2\n    return cnt"
    },
    {
      "source_file": "program_479.py",
      "specification_index": 479,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CountVowels(testStr):\n    if len(testStr) < 2:\n        raise ValueError(\"Precondition violated: |testStr| >= 2\")\n    vowels = {'a', 'e', 'i', 'o', 'u',\n              'A', 'E', 'I', 'O', 'U'}\n    res = 0\n    for i, c in enumerate(testStr):\n        if c not in vowels:\n            if (i > 0 and testStr[i-1] in vowels) or (i < len(testStr)-1 and testStr[i+1] in vowels):\n                res += 1\n    return res"
    },
    {
      "source_file": "program_482.py",
      "specification_index": 482,
      "transformation": "remove_parentheses",
      "regenerated_code": "def RemoveUppercase(str1):\n    if not isinstance(str1, (list, tuple, str)):\n        raise TypeError(\"str1 must be a sequence of characters\")\n    # Convert to list of chars if input is string\n    chars = list(str1)\n    result = [c for c in chars if not ('A' <= c <= 'Z')]\n    return result"
    },
    {
      "source_file": "program_487.py",
      "specification_index": 487,
      "transformation": "remove_parentheses",
      "regenerated_code": "def CheckN(n: int, revn: int) -> bool:\n    return 2 * revn == n + 1"
    },
    {
      "source_file": "program_490.py",
      "specification_index": 490,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List, Tuple, Sequence\n\ndef MaximumValueTestList(test_list: Sequence[Tuple[int, Sequence[int]]]) -> List[Tuple[int, int]]:\n    res = []\n    for pair in test_list:\n        a, b = pair\n        if len(b) == 0:\n            raise ValueError(\"Inner sequence must be non-empty\")\n        max_b = max(b)\n        res.append((a, max_b))\n    return res"
    },
    {
      "source_file": "program_493.py",
      "specification_index": 493,
      "transformation": "remove_parentheses",
      "regenerated_code": "from typing import List\n\ndef LeftRotate(s: List[int], d: int) -> List[int]:\n    if not (0 <= d <= len(s)):\n        raise ValueError(\"Precondition failed: 0 <= d <= len(s)\")\n    return s[d:] + s[:d]"
    },
    {
      "source_file": "program_496.py",
      "specification_index": 496,
      "transformation": "remove_parentheses",
      "regenerated_code": "def LogprobSpecifyShapeOp(values: list[int], shapes: list[int], inner_rv: int) -> int:\n    if len(values) != 1:\n        raise ValueError(\"Precondition violated: |values| == 1\")\n    # No semantic postcondition specified; return a dummy value\n    return 0"
    },
    {
      "source_file": "program_499.py",
      "specification_index": 499,
      "transformation": "remove_parentheses",
      "regenerated_code": "import re\nfrom typing import Optional, Match\n\ndef FindNoqaPhysicalLine(physical_line: str) -> Optional[Match[str]]:\n    \"\"\"\n    Returns a match object for a '# noqa' comment in the physical_line, or None if not present.\n    \"\"\"\n    # Look for '# noqa' (case-insensitive), possibly with codes, after optional whitespace\n    pattern = r'#\\s*noqa(?:\\b|$)'\n    match = re.search(pattern, physical_line, re.IGNORECASE)\n    return match"
    }
  ]
}