[
  {
    "task_id": "002",
    "filename": "program_002.py",
    "code": "def find_triplet_array(A, arr_size, sum):\n\tfor i in range( 0, arr_size-2):\n\t\tfor j in range(i + 1, arr_size-1):\n\t\t\tfor k in range(j + 1, arr_size):\n\t\t\t\tif A[i] + A[j] + A[k] == sum:\n\t\t\t\t\treturn  A[i],A[j],A[k]\n\t\t\t\t\treturn True\n\treturn False"
  },
  {
    "task_id": "003",
    "filename": "program_003.py",
    "code": "def octal_To_Decimal(n):\n    num = n;\n    dec_value = 0;\n    base = 1;\n    temp = num;\n    while (temp):\n        last_digit = temp % 10;\n        temp = int(temp / 10);\n        dec_value += last_digit*base;\n        base = base * 8;\n    return dec_value;"
  },
  {
    "task_id": "005",
    "filename": "program_005.py",
    "code": "def dig_let(s):\n d=l=0\n for c in s:\n    if c.isdigit():\n        d=d+1\n    elif c.isalpha():\n        l=l+1\n    else:\n        pass\n return (l,d)"
  },
  {
    "task_id": "006",
    "filename": "program_006.py",
    "code": "def multi_list(rownum,colnum):\n  multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\n  for row in range(rownum):\n    for col in range(colnum):\n        multi_list[row][col]= row*col\n  return multi_list"
  },
  {
    "task_id": "009",
    "filename": "program_009.py",
    "code": "def find_Min_Sum(num):\n    sum = 0\n    i = 2\n    while(i * i <= num):\n        while(num % i == 0):\n            sum += i\n            num /= i\n        i += 1\n    sum += num\n    return sum"
  },
  {
    "task_id": "010",
    "filename": "program_010.py",
    "code": "def count_char(string,char):\n count = 0\n for i in range(len(string)):\n    if(string[i] == char):\n        count = count + 1\n return count"
  },
  {
    "task_id": "011",
    "filename": "program_011.py",
    "code": "def three_sum(array):\n    \"\"\"\n    :param array: List[int]\n    :return: Set[ Tuple[int, int, int] ]\n    \"\"\"\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if i > 0 and array[i] == array[i - 1]:\n            continue\n        l, r = i + 1, len(array) - 1\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if s > 0:\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                # found three sum\n                res.add((array[i], array[l], array[r]))\n\n                # remove duplicates\n                while l < r and array[l] == array[l + 1]:\n                    l += 1\n\n                while l < r and array[r] == array[r - 1]:\n                    r -= 1\n\n                l += 1\n                r -= 1\n    return res"
  },
  {
    "task_id": "015",
    "filename": "program_015.py",
    "code": "def min_Swaps(s1,s2) :\n    c0 = 0; c1 = 0;\n    for i in range(len(s1)) :\n        if (s1[i] == '0' and s2[i] == '1') :\n            c0 += 1;\n        elif (s1[i] == '1' and s2[i] == '0') :\n            c1 += 1;\n    result = c0 // 2 + c1 // 2;\n    if (c0 % 2 == 0 and c1 % 2 == 0) :\n        return result;\n    elif ((c0 + c1) % 2 == 0) :\n        return result + 2;\n    else :\n        return -1;"
  },
  {
    "task_id": "018",
    "filename": "program_018.py",
    "code": "def first_Element(arr,n,k):\n    count_map = {};\n    for i in range(0, n):\n        if(arr[i] in count_map.keys()):\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        i += 1\n    for i in range(0, n):\n        if (count_map[arr[i]] == k):\n            return arr[i]\n        i += 1\n    return -1"
  },
  {
    "task_id": "019",
    "filename": "program_019.py",
    "code": "def count_no (A,N,L,R):\n    count = 0\n    for i in range (L,R + 1):\n        if (i % A != 0):\n            count += 1\n        if (count == N):\n            break\n    return (i)"
  },
  {
    "task_id": "020",
    "filename": "program_020.py",
    "code": "def new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (alive and 2 <= neighbour_count <= 3) or (\n                not alive and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation"
  },
  {
    "task_id": "024",
    "filename": "program_024.py",
    "code": "def octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not octal_number:\n        raise ValueError(\"Empty string was passed to the function\")\n\n    binary_number = \"\"\n    octal_digits = \"01234567\"\n    for digit in octal_number:\n        if digit not in octal_digits:\n            raise ValueError(\"Non-octal value was passed to the function\")\n\n        binary_digit = \"\"\n        value = int(digit)\n        for _ in range(3):\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n        binary_number += binary_digit\n\n    return binary_number"
  },
  {
    "task_id": "025",
    "filename": "program_025.py",
    "code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])\n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)\n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True"
  },
  {
    "task_id": "027",
    "filename": "program_027.py",
    "code": "def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2"
  },
  {
    "task_id": "028",
    "filename": "program_028.py",
    "code": "def max_Product(arr):\n    arr_len = len(arr)\n    if (arr_len < 2):\n        return (\"No pairs exists\")\n    x = arr[0]; y = arr[1]\n    for i in range(0,arr_len):\n        for j in range(i + 1,arr_len):\n            if (arr[i] * arr[j] > x * y):\n                x = arr[i]; y = arr[j]\n    return x,y"
  },
  {
    "task_id": "030",
    "filename": "program_030.py",
    "code": "import heapq as hq\n\ndef heap_sort(iterable):\n    h = []\n    for value in iterable:\n        hq.heappush(h, value)\n    return [hq.heappop(h) for i in range(len(h))]"
  },
  {
    "task_id": "032",
    "filename": "program_032.py",
    "code": "def common_prefix (arr, n):\n\tprefix = arr[0]\n\tfor i in range (1, n):\n\t\tprefix = common_prefix_util(prefix, arr[i])\n\treturn (prefix)"
  },
  {
    "task_id": "033",
    "filename": "program_033.py",
    "code": "def no_of_subsequences(arr, k):\n\tn = len(arr)\n\tdp = [[0 for i in range(n + 1)]\n\t\t\tfor j in range(k + 1)]\n\tfor i in range(1, k + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tdp[i][j] = dp[i][j - 1]\n\t\t\tif arr[j - 1] <= i and arr[j - 1] > 0:\n\t\t\t\tdp[i][j] += dp[i // arr[j - 1]][j - 1] + 1\n\treturn dp[k][n]"
  },
  {
    "task_id": "034",
    "filename": "program_034.py",
    "code": "def swap_count(s):\n\tchars = s\n\tcount_left = 0\n\tcount_right = 0\n\tswap = 0\n\timbalance = 0;\n\tfor i in range(len(chars)):\n\t\tif chars[i] == '[':\n\t\t\tcount_left += 1\n\t\t\tif imbalance > 0:\n\t\t\t\tswap += imbalance\n\t\t\t\timbalance -= 1\n\t\telif chars[i] == ']':\n\t\t\tcount_right += 1\n\t\t\timbalance = (count_right - count_left)\n\treturn swap"
  },
  {
    "task_id": "036",
    "filename": "program_036.py",
    "code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list"
  },
  {
    "task_id": "037",
    "filename": "program_037.py",
    "code": "def find_Nth_Digit(p,q,N) :\n    while (N > 0) :\n        N -= 1;\n        p *= 10;\n        res = p // q;\n        p %= q;\n    return res;"
  },
  {
    "task_id": "039",
    "filename": "program_039.py",
    "code": "def find_missing_number(nums):\n\n    missing = 0\n    for i, num in enumerate(nums):\n        missing ^= num\n        missing ^= i + 1\n\n    return missing"
  },
  {
    "task_id": "041",
    "filename": "program_041.py",
    "code": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return (str(res))"
  },
  {
    "task_id": "042",
    "filename": "program_042.py",
    "code": "def run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n\n    for i in range(len(text)):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n\n    return encoded"
  },
  {
    "task_id": "043",
    "filename": "program_043.py",
    "code": "def longest_non_repeat_v2(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    Uses alternative algorithm.\n    \"\"\"\n    if string is None:\n        return 0\n    start, max_len = 0, 0\n    used_char = {}\n    for index, char in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        else:\n            max_len = max(max_len, index - start + 1)\n        used_char[char] = index\n    return max_len"
  },
  {
    "task_id": "044",
    "filename": "program_044.py",
    "code": "def find_demlo(s):\n\tl = len(s)\n\tres = \"\"\n\tfor i in range(1,l+1):\n\t\tres = res + str(i)\n\tfor i in range(l-1,0,-1):\n\t\tres = res + str(i)\n\treturn res"
  },
  {
    "task_id": "049",
    "filename": "program_049.py",
    "code": "def prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns prime factors of n as a list.\n\n    >>> prime_factors(0)\n    []\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(2560)\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n    >>> prime_factors(10**-2)\n    []\n    >>> prime_factors(0.02)\n    []\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n    >>> x == [2]*241 + [5]*241\n    True\n    >>> prime_factors(10**-354)\n    []\n    >>> prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors"
  },
  {
    "task_id": "050",
    "filename": "program_050.py",
    "code": "def bin_coff(n, r):\n\tval = 1\n\tif (r > (n - r)):\n\t\tr = (n - r)\n\tfor i in range(0, r):\n\t\tval *= (n - i)\n\t\tval //= (i + 1)\n\treturn val"
  },
  {
    "task_id": "051",
    "filename": "program_051.py",
    "code": "def int_to_roman( num):\n        val = [1000, 900, 500, 400,100, 90, 50, 40,10, 9, 5, 4,1]\n        syb = [\"M\", \"CM\", \"D\", \"CD\",\"C\", \"XC\", \"L\", \"XL\",\"X\", \"IX\", \"V\", \"IV\",\"I\"]\n        roman_num = ''\n        i = 0\n        while  num > 0:\n            for _ in range(num // val[i]):\n                roman_num += syb[i]\n                num -= val[i]\n            i += 1\n        return roman_num"
  },
  {
    "task_id": "053",
    "filename": "program_053.py",
    "code": "def lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    >>> # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    >>> # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    >>> # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    >>> # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    # Ensure that table is a square array\n    rows, columns = np.shape(table)\n    if rows != columns:\n        msg = (\n            \"'table' has to be of square shaped array but got a \"\n            f\"{rows}x{columns} array:\\n{table}\"\n        )\n        raise ValueError(msg)\n\n    lower = np.zeros((rows, columns))\n    upper = np.zeros((rows, columns))\n\n    # in 'total', the necessary data is extracted through slices\n    # and the sum of the products is obtained.\n\n    for i in range(columns):\n        for j in range(i):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            if upper[j][j] == 0:\n                raise ArithmeticError(\"No LU decomposition exists\")\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\n        lower[i][i] = 1\n        for j in range(i, columns):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            upper[i][j] = table[i][j] - total\n    return lower, upper"
  },
  {
    "task_id": "054",
    "filename": "program_054.py",
    "code": "def coin_change(S, m, n):\n    table = [[0 for x in range(m)] for x in range(n+1)]\n    for i in range(m):\n        table[0][i] = 1\n    for i in range(1, n+1):\n        for j in range(m):\n            x = table[i - S[j]][j] if i-S[j] >= 0 else 0\n            y = table[i][j-1] if j >= 1 else 0\n            table[i][j] = x + y\n    return table[n][m-1]"
  },
  {
    "task_id": "058",
    "filename": "program_058.py",
    "code": "def largest_pow_of_two_le_num(number: int) -> int:\n    \"\"\"\n    Return the largest power of two less than or equal to a number.\n\n    >>> largest_pow_of_two_le_num(0)\n    0\n    >>> largest_pow_of_two_le_num(1)\n    1\n    >>> largest_pow_of_two_le_num(-1)\n    0\n    >>> largest_pow_of_two_le_num(3)\n    2\n    >>> largest_pow_of_two_le_num(15)\n    8\n    >>> largest_pow_of_two_le_num(99)\n    64\n    >>> largest_pow_of_two_le_num(178)\n    128\n    >>> largest_pow_of_two_le_num(999999)\n    524288\n    >>> largest_pow_of_two_le_num(99.9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    \"\"\"\n    if isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    if number <= 0:\n        return 0\n    res = 1\n    while (res << 1) <= number:\n        res <<= 1\n    return res"
  },
  {
    "task_id": "064",
    "filename": "program_064.py",
    "code": "def longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError(\"longest_common_substring() takes two strings for inputs\")\n\n    if not text1 or not text2:\n        return \"\"\n\n    text1_length = len(text1)\n    text2_length = len(text2)\n\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    end_pos = 0\n    max_length = 0\n\n    for i in range(1, text1_length + 1):\n        for j in range(1, text2_length + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if dp[i][j] > max_length:\n                    end_pos = i\n                    max_length = dp[i][j]\n\n    return text1[end_pos - max_length : end_pos]"
  },
  {
    "task_id": "065",
    "filename": "program_065.py",
    "code": "def count_Unset_Bits(n) :\n    cnt = 0;\n    for i in range(1,n + 1) :\n        temp = i;\n        while (temp) :\n            if (temp % 2 == 0) :\n                cnt += 1;\n            temp = temp // 2;\n    return cnt;"
  },
  {
    "task_id": "066",
    "filename": "program_066.py",
    "code": "def longest_increasing_subsequence(arr):\n\tn = len(arr)\n\tlongest_increasing_subsequence = [1]*n\n\tfor i in range (1 , n):\n\t\tfor j in range(0 , i):\n\t\t\tif arr[i] > arr[j] and longest_increasing_subsequence[i]< longest_increasing_subsequence[j] + 1 :\n\t\t\t\tlongest_increasing_subsequence[i] = longest_increasing_subsequence[j]+1\n\tmaximum = 0\n\tfor i in range(n):\n\t\tmaximum = max(maximum , longest_increasing_subsequence[i])\n\treturn maximum"
  },
  {
    "task_id": "067",
    "filename": "program_067.py",
    "code": "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    uglies = [1]\n    def gen(prime):\n        for ugly in uglies:\n            yield ugly * prime\n    merged = heapq.merge(*map(gen, primes))\n    while len(uglies) < n:\n        ugly = next(merged)\n        if ugly != uglies[-1]:\n            uglies.append(ugly)\n    return uglies[-1]"
  },
  {
    "task_id": "068",
    "filename": "program_068.py",
    "code": "def find_longest_conseq_subseq(arr, n):\n\tans = 0\n\tcount = 0\n\tarr.sort()\n\tv = []\n\tv.append(arr[0])\n\tfor i in range(1, n):\n\t\tif (arr[i] != arr[i - 1]):\n\t\t\tv.append(arr[i])\n\tfor i in range(len(v)):\n\t\tif (i > 0 and v[i] == v[i - 1] + 1):\n\t\t\tcount += 1\n\t\telse:\n\t\t\tcount = 1\n\t\tans = max(ans, count)\n\treturn ans"
  },
  {
    "task_id": "070",
    "filename": "program_070.py",
    "code": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n//i]),\n                factor(n//i, i, combi+[i], combis)\n            i += 1\n        return combis\n\n    return factor(n, 2, [], [])"
  },
  {
    "task_id": "074",
    "filename": "program_074.py",
    "code": "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target-nums[i], i, path+[nums[i]], res)\n\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res"
  },
  {
    "task_id": "077",
    "filename": "program_077.py",
    "code": "def smallest_Divisor(n):\n    if (n % 2 == 0):\n        return 2;\n    i = 3;\n    while (i*i <= n):\n        if (n % i == 0):\n            return i;\n        i += 2;\n    return n;"
  },
  {
    "task_id": "078",
    "filename": "program_078.py",
    "code": "import math\nimport sys\n\ndef sd_calc(data):\n    n = len(data)\n    if n <= 1:\n        return 0.0\n    mean, sd = avg_calc(data), 0.0\n    for el in data:\n        sd += (float(el) - mean)**2\n    sd = math.sqrt(sd / float(n-1))\n    return sd"
  },
  {
    "task_id": "082",
    "filename": "program_082.py",
    "code": "def find_longest_repeating_subseq(str):\n\tn = len(str)\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)]\n\tfor i in range(1, n+1):\n\t\tfor j in range(1, n+1):\n\t\t\tif (str[i-1] == str[j-1] and i != j):\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1]\n\t\t\telse:\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j])\n\treturn dp[n][n]"
  },
  {
    "task_id": "083",
    "filename": "program_083.py",
    "code": "def depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    \"\"\"\n    Recur for all neighbours.\n    If any neighbour is visited and in rec_stk then graph is cyclic.\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n    >>> vertex, visited, rec_stk = 0, set(), set()\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\n    False\n    \"\"\"\n    # Mark current node as visited and add to recursion stack\n    visited.add(vertex)\n    rec_stk.add(vertex)\n\n    for node in graph[vertex]:\n        if node not in visited:\n            if depth_first_search(graph, node, visited, rec_stk):\n                return True\n        elif node in rec_stk:\n            return True\n\n    # The node needs to be removed from recursion stack before function ends\n    rec_stk.remove(vertex)\n    return False"
  },
  {
    "task_id": "086",
    "filename": "program_086.py",
    "code": "def get_factors(n):\n    \"\"\"[summary]\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n\n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n\n        Returns:\n            [list] -- [res]\n        \"\"\"\n\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, int(n/i)],\n                factor(n/i, i, combi+[i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])"
  },
  {
    "task_id": "087",
    "filename": "program_087.py",
    "code": "def is_valid_parenthese( str1):\n        stack, pchar = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in str1:\n            if parenthese in pchar:\n                stack.append(parenthese)\n            elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0"
  },
  {
    "task_id": "089",
    "filename": "program_089.py",
    "code": "def find_Element(arr,ranges,rotations,index) :\n    for i in range(rotations - 1,-1,-1 ) :\n        left = ranges[i][0]\n        right = ranges[i][1]\n        if (left <= index and right >= index) :\n            if (index == left) :\n                index = right\n            else :\n                index = index - 1\n    return arr[index]"
  },
  {
    "task_id": "092",
    "filename": "program_092.py",
    "code": "from collections import defaultdict\n\ndef grouping_dictionary(l):\n    d = defaultdict(list)\n    for k, v in l:\n        d[k].append(v)\n    return d"
  },
  {
    "task_id": "095",
    "filename": "program_095.py",
    "code": "def string_length(str1):\n    count = 0\n    for char in str1:\n        count += 1\n    return count"
  },
  {
    "task_id": "096",
    "filename": "program_096.py",
    "code": "def ncr_modp(n, r, p):\n    C = [0 for i in range(r+1)]\n    C[0] = 1\n    for i in range(1, n+1):\n        for j in range(min(i, r), 0, -1):\n            C[j] = (C[j] + C[j-1]) % p\n    return C[r]"
  },
  {
    "task_id": "099",
    "filename": "program_099.py",
    "code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums"
  },
  {
    "task_id": "101",
    "filename": "program_101.py",
    "code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False"
  },
  {
    "task_id": "102",
    "filename": "program_102.py",
    "code": "def frequency_Of_Smallest(n,arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1,n):\n        if (arr[i] < mn):\n            mn = arr[i]\n            freq = 1\n        elif (arr[i] == mn):\n            freq += 1\n    return freq"
  },
  {
    "task_id": "103",
    "filename": "program_103.py",
    "code": "def closest(x) :\n    ans = 0\n    while (ans * 10 + 9 <= x) :\n        ans = ans * 10 + 9\n    return ans"
  },
  {
    "task_id": "105",
    "filename": "program_105.py",
    "code": "def find_Min_Diff(arr,n):\n    arr = sorted(arr)\n    diff = 10**20\n    for i in range(n-1):\n        if arr[i+1] - arr[i] < diff:\n            diff = arr[i+1] - arr[i]\n    return diff"
  },
  {
    "task_id": "108",
    "filename": "program_108.py",
    "code": "def get_median(arr1, arr2, n):\n  i = 0\n  j = 0\n  m1 = -1\n  m2 = -1\n  count = 0\n  while count < n + 1:\n    count += 1\n    if i == n:\n      m1 = m2\n      m2 = arr2[0]\n      break\n    elif j == n:\n      m1 = m2\n      m2 = arr1[0]\n      break\n    if arr1[i] <= arr2[j]:\n      m1 = m2\n      m2 = arr1[i]\n      i += 1\n    else:\n      m1 = m2\n      m2 = arr2[j]\n      j += 1\n  return (m1 + m2)/2"
  },
  {
    "task_id": "110",
    "filename": "program_110.py",
    "code": "from collections import defaultdict\n\ndef most_occurrences(test_list):\n  temp = defaultdict(int)\n  for sub in test_list:\n    for wrd in sub.split():\n      temp[wrd] += 1\n  res = max(temp, key=temp.get)\n  return (str(res))"
  },
  {
    "task_id": "112",
    "filename": "program_112.py",
    "code": "def get_maxgold(gold, m, n):\n    goldTable = [[0 for i in range(n)]\n                        for j in range(m)]\n    for col in range(n-1, -1, -1):\n        for row in range(m):\n            if (col == n-1):\n                right = 0\n            else:\n                right = goldTable[row][col+1]\n            if (row == 0 or col == n-1):\n                right_up = 0\n            else:\n                right_up = goldTable[row-1][col+1]\n            if (row == m-1 or col == n-1):\n                right_down = 0\n            else:\n                right_down = goldTable[row+1][col+1]\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down)\n    res = goldTable[0][0]\n    for i in range(1, m):\n        res = max(res, goldTable[i][0])\n    return res"
  },
  {
    "task_id": "116",
    "filename": "program_116.py",
    "code": "def count_Set_Bits(n):\n    count = 0\n    while (n):\n        count += n & 1\n        n >>= 1\n    return count"
  },
  {
    "task_id": "117",
    "filename": "program_117.py",
    "code": "def longest_non_repeat_v1(string):\n    \"\"\"\n    Find the length of the longest substring\n    without repeating characters.\n    \"\"\"\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length"
  },
  {
    "task_id": "118",
    "filename": "program_118.py",
    "code": "def factorial(start,end):\n    res = 1\n    for i in range(start,end + 1):\n        res *= i\n    return res"
  },
  {
    "task_id": "119",
    "filename": "program_119.py",
    "code": "def reverse_floyd(n):\n\n    \"\"\"\n\n    Print the lower half of a diamond pattern with '*' characters.\n\n    Args:\n\n        n (int): Size of the pattern.\n\n    Examples:\n\n        >>> reverse_floyd(3)\n\n        '* * * \\\\n * * \\\\n  * \\\\n   '\n\n        >>> reverse_floyd(5)\n\n        '* * * * * \\\\n * * * * \\\\n  * * * \\\\n   * * \\\\n    * \\\\n     '\n\n    \"\"\"\n\n    result = \"\"\n\n    for i in range(n, 0, -1):\n\n        for _ in range(i, 0, -1):  # printing stars\n\n            result += \"* \"\n\n        result += \"\\n\"\n\n        for _ in range(n - i + 1, 0, -1):  # printing spaces\n\n            result += \" \"\n\n    return result"
  },
  {
    "task_id": "120",
    "filename": "program_120.py",
    "code": "def fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    | Plays FizzBuzz.\n    | Prints Fizz if number is a multiple of ``3``.\n    | Prints Buzz if its a multiple of ``5``.\n    | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``.\n    | Else Prints The Number Itself.\n\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError(\"iterations must be defined as integers\")\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError(\n            \"\"\"starting number must be\n                         and integer and be more than 0\"\"\"\n        )\n    if not iterations >= 1:\n        raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")\n\n    out = \"\"\n    while number <= iterations:\n        if number % 3 == 0:\n            out += \"Fizz\"\n        if number % 5 == 0:\n            out += \"Buzz\"\n        if 0 not in (number % 3, number % 5):\n            out += str(number)\n\n        # print(out)\n        number += 1\n        out += \" \"\n    return out"
  },
  {
    "task_id": "123",
    "filename": "program_123.py",
    "code": "def _from_ctypes_union(t):\n    import ctypes\n    formats = []\n    offsets = []\n    names = []\n    for fname, ftyp in t._fields_:\n        names.append(fname)\n        formats.append(dtype_from_ctypes_type(ftyp))\n        offsets.append(0)  # Union fields are offset to 0\n\n    return np.dtype({\n        \"formats\": formats,\n        \"offsets\": offsets,\n        \"names\": names,\n        \"itemsize\": ctypes.sizeof(t)})"
  },
  {
    "task_id": "124",
    "filename": "program_124.py",
    "code": "def check_K(test_tup, K):\n  res = False\n  for ele in test_tup:\n    if ele == K:\n      res = True\n      break\n  return (res)"
  },
  {
    "task_id": "125",
    "filename": "program_125.py",
    "code": "def ensure_unique(iterable, key=lambda x: x):\n    \"\"\"\n    Wrap an iterable to raise a ValueError if non-unique values are encountered.\n\n    >>> list(ensure_unique('abc'))\n    ['a', 'b', 'c']\n    >>> consume(ensure_unique('abca'))\n    Traceback (most recent call last):\n    ...\n    ValueError: Duplicate element 'a' encountered.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k in seen:\n            raise ValueError(f\"Duplicate element {element!r} encountered.\")\n        seen_add(k)\n        yield element"
  },
  {
    "task_id": "126",
    "filename": "program_126.py",
    "code": "def heapify(arr):\n    start = len(arr) // 2\n    while start >= 0:\n        shift_down(arr, start, len(arr) - 1)\n        start -= 1"
  },
  {
    "task_id": "127",
    "filename": "program_127.py",
    "code": "def find_Min_Swaps(arr,n) :\n    noOfZeroes = [0] * n\n    count = 0\n    noOfZeroes[n - 1] = 1 - arr[n - 1]\n    for i in range(n-2,-1,-1) :\n        noOfZeroes[i] = noOfZeroes[i + 1]\n        if (arr[i] == 0) :\n            noOfZeroes[i] = noOfZeroes[i] + 1\n    for i in range(0,n) :\n        if (arr[i] == 1) :\n            count = count + noOfZeroes[i]\n    return count"
  },
  {
    "task_id": "128",
    "filename": "program_128.py",
    "code": "def find_ind(key, i, n,\n\t\t\tk, arr):\n\tind = -1\n\tstart = i + 1\n\tend = n - 1;\n\twhile (start < end):\n\t\tmid = int(start +\n\t\t\t\t(end - start) / 2)\n\t\tif (arr[mid] - key <= k):\n\t\t\tind = mid\n\t\t\tstart = mid + 1\n\t\telse:\n\t\t\tend = mid\n\treturn ind"
  },
  {
    "task_id": "129",
    "filename": "program_129.py",
    "code": "def max_volume (s):\n    maxvalue = 0\n    i = 1\n    for i in range(s - 1):\n        j = 1\n        for j in range(s):\n            k = s - i - j\n            maxvalue = max(maxvalue, i * j * k)\n    return maxvalue"
  },
  {
    "task_id": "130",
    "filename": "program_130.py",
    "code": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)"
  },
  {
    "task_id": "131",
    "filename": "program_131.py",
    "code": "def get_Inv_Count(arr,n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1,n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count"
  },
  {
    "task_id": "133",
    "filename": "program_133.py",
    "code": "def frequency_Of_Largest(n,arr):\n    mn = arr[0]\n    freq = 1\n    for i in range(1,n):\n        if (arr[i] >mn):\n            mn = arr[i]\n            freq = 1\n        elif (arr[i] == mn):\n            freq += 1\n    return freq"
  },
  {
    "task_id": "140",
    "filename": "program_140.py",
    "code": "def count(s,c) :\n    res = 0\n    for i in range(len(s)) :\n        if (s[i] == c):\n            res = res + 1\n    return res"
  },
  {
    "task_id": "141",
    "filename": "program_141.py",
    "code": "def find_Max_Len_Even(str):\n    n = len(str)\n    i = 0\n    currlen = 0\n    maxlen = 0\n    st = -1\n    while (i < n):\n        if (str[i] == ' '):\n            if (currlen % 2 == 0):\n                if (maxlen < currlen):\n                    maxlen = currlen\n                    st = i - currlen\n            currlen = 0\n        else :\n            currlen += 1\n        i += 1\n    if (currlen % 2 == 0):\n        if (maxlen < currlen):\n            maxlen = currlen\n            st = i - currlen\n    if (st == -1):\n        return \"-1\"\n    return str[st: st + maxlen]"
  },
  {
    "task_id": "142",
    "filename": "program_142.py",
    "code": "def unique_Characters(str):\n    for i in range(len(str)):\n        for j in range(i + 1,len(str)):\n            if (str[i] == str[j]):\n                return False;\n    return True;"
  },
  {
    "task_id": "144",
    "filename": "program_144.py",
    "code": "def glob_to_regex_pattern(glob: str) -> str:\n    tokens = [\"^\"]\n    in_group = False\n\n    i = 0\n    while i < len(glob):\n        c = glob[i]\n        if c == \"\\\\\" and i + 1 < len(glob):\n            char = glob[i + 1]\n            tokens.append(\"\\\\\" + char if char in escaped_chars else char)\n            i += 1\n        elif c == \"*\":\n            before_deep = glob[i - 1] if i > 0 else None\n            star_count = 1\n            while i + 1 < len(glob) and glob[i + 1] == \"*\":\n                star_count += 1\n                i += 1\n            after_deep = glob[i + 1] if i + 1 < len(glob) else None\n            is_deep = (\n                star_count > 1\n                and (before_deep == \"/\" or before_deep is None)\n                and (after_deep == \"/\" or after_deep is None)\n            )\n            if is_deep:\n                tokens.append(\"((?:[^/]*(?:/|$))*)\")\n                i += 1\n            else:\n                tokens.append(\"([^/]*)\")\n        else:\n            if c == \"{\":\n                in_group = True\n                tokens.append(\"(\")\n            elif c == \"}\":\n                in_group = False\n                tokens.append(\")\")\n            elif c == \",\":\n                if in_group:\n                    tokens.append(\"|\")\n                else:\n                    tokens.append(\"\\\\\" + c)\n            else:\n                tokens.append(\"\\\\\" + c if c in escaped_chars else c)\n        i += 1\n\n    tokens.append(\"$\")\n    return \"\".join(tokens)"
  },
  {
    "task_id": "145",
    "filename": "program_145.py",
    "code": "def min_Swaps(str1,str2) :\n    count = 0\n    for i in range(len(str1)) :\n        if str1[i] != str2[i] :\n            count += 1\n    if count % 2 == 0 :\n        return (count // 2)\n    else :\n        return (\"Not Possible\")"
  },
  {
    "task_id": "147",
    "filename": "program_147.py",
    "code": "def dfs(graph: dict, vert: int, visited: list) -> list:\n    \"\"\"\n    Use depth first search to find all vertices\n    being in the same component as initial vertex\n    >>> dfs(test_graph_1, 0, 5 * [False])\n    [0, 1, 3, 2]\n    >>> dfs(test_graph_2, 0, 6 * [False])\n    [0, 1, 3, 2]\n    \"\"\"\n\n    visited[vert] = True\n    connected_verts = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            connected_verts += dfs(graph, neighbour, visited)\n\n    return [vert, *connected_verts]"
  },
  {
    "task_id": "148",
    "filename": "program_148.py",
    "code": "def rsafactor(d: int, e: int, n: int) -> list[int]:\n\n    \"\"\"\n\n    This function returns the factors of N, where p*q=N\n\n    Return: [p, q]\n\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\n\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\n\n    encrypt messages.\n\n    The pair (N, d) is the secret key or private key and is known only to the recipient\n\n    of encrypted messages.\n\n    >>> rsafactor(3, 16971, 25777)\n\n    [149, 173]\n\n    >>> rsafactor(7331, 11, 27233)\n\n    [113, 241]\n\n    >>> rsafactor(4021, 13, 17711)\n\n    [89, 199]\n\n    \"\"\"\n\n    k = d * e - 1\n\n    p = 0\n\n    q = 0\n\n    while p == 0:\n\n        g = random.randint(2, n - 1)\n\n        t = k\n\n        while True:\n\n            if t % 2 == 0:\n\n                t = t // 2\n\n                x = (g**t) % n\n\n                y = math.gcd(x - 1, n)\n\n                if x > 1 and y > 1:\n\n                    p = y\n\n                    q = n // y\n\n                    break  # find the correct factors\n\n            else:\n\n                break  # t is not divisible by 2, break and choose another g\n\n    return sorted([p, q])"
  },
  {
    "task_id": "151",
    "filename": "program_151.py",
    "code": "def find_platform(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    while (i < n and j < n):\n        if (arr[i] <= dep[j]):\n            plat_needed+= 1\n            i+= 1\n        elif (arr[i] > dep[j]):\n            plat_needed-= 1\n            j+= 1\n        if (plat_needed > result):\n            result = plat_needed\n    return result"
  },
  {
    "task_id": "152",
    "filename": "program_152.py",
    "code": "def check_element(test_tup, check_list):\n  res = False\n  for ele in check_list:\n    if ele in test_tup:\n      res = True\n      break\n  return (res)"
  },
  {
    "task_id": "153",
    "filename": "program_153.py",
    "code": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer"
  },
  {
    "task_id": "154",
    "filename": "program_154.py",
    "code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr"
  },
  {
    "task_id": "156",
    "filename": "program_156.py",
    "code": "def sort_tuple(tup):\n\tlst = len(tup)\n\tfor i in range(0, lst):\n\t\tfor j in range(0, lst-i-1):\n\t\t\tif (tup[j][-1] > tup[j + 1][-1]):\n\t\t\t\ttemp = tup[j]\n\t\t\t\ttup[j]= tup[j + 1]\n\t\t\t\ttup[j + 1]= temp\n\treturn tup"
  },
  {
    "task_id": "162",
    "filename": "program_162.py",
    "code": "def bin_to_octal(bin_string: str) -> str:\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    oct_string = \"\"\n    while len(bin_string) % 3 != 0:\n        bin_string = \"0\" + bin_string\n    bin_string_in_3_list = [\n        bin_string[index : index + 3]\n        for index in range(len(bin_string))\n        if index % 3 == 0\n    ]\n    for bin_group in bin_string_in_3_list:\n        oct_val = 0\n        for index, val in enumerate(bin_group):\n            oct_val += int(2 ** (2 - index) * int(val))\n        oct_string += str(oct_val)\n    return oct_string"
  },
  {
    "task_id": "165",
    "filename": "program_165.py",
    "code": "def perfect_cube_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_cube_binary_search(27)\n    True\n    >>> perfect_cube_binary_search(64)\n    True\n    >>> perfect_cube_binary_search(4)\n    False\n    >>> perfect_cube_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    >>> perfect_cube_binary_search(0.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"perfect_cube_binary_search() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return True\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False"
  },
  {
    "task_id": "169",
    "filename": "program_169.py",
    "code": "def maximum_segments(n, a, b, c) :\n\tdp = [-1] * (n + 10)\n\tdp[0] = 0\n\tfor i in range(0, n) :\n\t\tif (dp[i] != -1) :\n\t\t\tif(i + a <= n ):\n\t\t\t\tdp[i + a] = max(dp[i] + 1,\n\t\t\t\t\t\t\tdp[i + a])\n\t\t\tif(i + b <= n ):\n\t\t\t\tdp[i + b] = max(dp[i] + 1,\n\t\t\t\t\t\t\tdp[i + b])\n\t\t\tif(i + c <= n ):\n\t\t\t\tdp[i + c] = max(dp[i] + 1,\n\t\t\t\t\t\t\tdp[i + c])\n\treturn dp[n]"
  },
  {
    "task_id": "171",
    "filename": "program_171.py",
    "code": "def get_index_of_rightmost_set_bit(number: int) -> int:\n    \"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    intermediate = number & ~(number - 1)\n    index = 0\n    while intermediate:\n        intermediate >>= 1\n        index += 1\n    return index - 1"
  },
  {
    "task_id": "175",
    "filename": "program_175.py",
    "code": "def decimal_to_Octal(deciNum):\n    octalNum = 0\n    countval = 1;\n    dNo = deciNum;\n    while (deciNum!= 0):\n        remainder= deciNum % 8;\n        octalNum+= remainder*countval;\n        countval= countval*10;\n        deciNum //= 8;\n    return (octalNum)"
  },
  {
    "task_id": "176",
    "filename": "program_176.py",
    "code": "def first_Missing_Positive(arr,n):\n    ptr = 0\n    for i in range(n):\n        if arr[i] == 1:\n            ptr = 1\n            break\n    if ptr == 0:\n        return(1)\n    for i in range(n):\n        if arr[i] <= 0 or arr[i] > n:\n            arr[i] = 1\n    for i in range(n):\n        arr[(arr[i] - 1) % n] += n\n    for i in range(n):\n        if arr[i] <= n:\n            return(i + 1)\n    return(n + 1)"
  },
  {
    "task_id": "177",
    "filename": "program_177.py",
    "code": "def letter_combinations(digits):\n    if digits == \"\":\n        return []\n    kmaps = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\"\n    }\n    ans = [\"\"]\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans"
  },
  {
    "task_id": "181",
    "filename": "program_181.py",
    "code": "def get_output_shapes(model_data):\n  \"\"\"Returns a list of output shapes in the tflite model data.\"\"\"\n  model = schema_fb.Model.GetRootAsModel(model_data, 0)\n\n  output_shapes = []\n  for subgraph_idx in range(model.SubgraphsLength()):\n    subgraph = model.Subgraphs(subgraph_idx)\n    for output_idx in range(subgraph.OutputsLength()):\n      output_tensor_idx = subgraph.Outputs(output_idx)\n      output_tensor = subgraph.Tensors(output_tensor_idx)\n      output_shapes.append(output_tensor.ShapeAsNumpy().tolist())\n\n  return output_shapes"
  },
  {
    "task_id": "187",
    "filename": "program_187.py",
    "code": "def topological_sort(graph: dict[int, list[int]]) -> list[int] | None:\n    \"\"\"\n    Perform topological sorting of a Directed Acyclic Graph (DAG)\n    using Kahn's Algorithm via Breadth-First Search (BFS).\n\n    Topological sorting is a linear ordering of vertices in a graph such that for\n    every directed edge u  v, vertex u comes before vertex v in the ordering.\n\n    Parameters:\n    graph: Adjacency list representing the directed graph where keys are\n           vertices, and values are lists of adjacent vertices.\n\n    Returns:\n    The topologically sorted order of vertices if the graph is a DAG.\n    Returns None if the graph contains a cycle.\n\n    Example:\n    >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\n    >>> topological_sort(graph)\n    [0, 1, 2, 3, 4, 5]\n\n    >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]}\n    >>> topological_sort(graph_with_cycle)\n    \"\"\"\n\n    indegree = [0] * len(graph)\n    queue = []\n    topo_order = []\n    processed_vertices_count = 0\n\n    # Calculate the indegree of each vertex\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n\n    # Add all vertices with 0 indegree to the queue\n    for i in range(len(indegree)):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    # Perform BFS\n    while queue:\n        vertex = queue.pop(0)\n        processed_vertices_count += 1\n        topo_order.append(vertex)\n\n        # Traverse neighbors\n        for neighbor in graph[vertex]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if processed_vertices_count != len(graph):\n        return None  # no topological ordering exists due to cycle\n    return topo_order  # valid topological ordering"
  },
  {
    "task_id": "189",
    "filename": "program_189.py",
    "code": "import math\n\ndef max_Prime_Factors (n):\n    maxPrime = -1\n    while n%2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)"
  },
  {
    "task_id": "193",
    "filename": "program_193.py",
    "code": "def list_of_submasks(mask: int) -> list[int]:\n    \"\"\"\n    Args:\n        mask : number which shows mask ( always integer > 0, zero does not have any\n            submasks )\n\n    Returns:\n        all_submasks : the list of submasks of mask (mask s is called submask of mask\n        m if only bits that were included in original mask are set\n\n    Raises:\n        AssertionError: mask not positive integer\n\n    >>> list_of_submasks(15)\n    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    >>> list_of_submasks(13)\n    [13, 12, 9, 8, 5, 4, 1]\n    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input -7\n    >>> list_of_submasks(0)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input 0\n\n    \"\"\"\n\n    assert isinstance(mask, int) and mask > 0, (\n        f\"mask needs to be positive integer, your input {mask}\"\n    )\n\n    \"\"\"\n    first submask iterated will be mask itself then operation will be performed\n    to get other submasks till we reach empty submask that is zero ( zero is not\n    included in final submasks list )\n    \"\"\"\n    all_submasks = []\n    submask = mask\n\n    while submask:\n        all_submasks.append(submask)\n        submask = (submask - 1) & mask\n\n    return all_submasks"
  },
  {
    "task_id": "194",
    "filename": "program_194.py",
    "code": "def func(nums, k):\n    import collections\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n    temp = []\n    import heapq\n    for key, v in d.items():\n        if len(temp) < k:\n            temp.append((v, key))\n            if len(temp) == k:\n                heapq.heapify(temp)\n        else:\n            if v > temp[0][0]:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n    return result"
  },
  {
    "task_id": "199",
    "filename": "program_199.py",
    "code": "def sum_Square(n) :\n    i = 1\n    while i*i <= n :\n        j = 1\n        while (j*j <= n) :\n            if (i*i+j*j == n) :\n                return True\n            j = j+1\n        i = i+1\n    return False"
  },
  {
    "task_id": "200",
    "filename": "program_200.py",
    "code": "def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if partitions <= 0:\n        raise ValueError(\"partitions must be a positive number!\")\n    if partitions > number_of_bytes:\n        raise ValueError(\"partitions can not > number_of_bytes!\")\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    for i in range(partitions):\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = (\n            number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        )\n        allocation_list.append(f\"{start_bytes}-{end_bytes}\")\n    return allocation_list"
  },
  {
    "task_id": "202",
    "filename": "program_202.py",
    "code": "def immediate_dominators(G, start):\n    \"\"\"Returns the immediate dominators of all nodes of a directed graph.\n\n    Parameters\n    ----------\n    G : a DiGraph or MultiDiGraph\n        The graph where dominance is to be computed.\n\n    start : node\n        The start node of dominance computation.\n\n    Returns\n    -------\n    idom : dict keyed by nodes\n        A dict containing the immediate dominators of each node reachable from\n        `start`.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    NetworkXError\n        If `start` is not in `G`.\n\n    Notes\n    -----\n    Except for `start`, the immediate dominators are the parents of their\n    corresponding nodes in the dominator tree.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n    >>> sorted(nx.immediate_dominators(G, 1).items())\n    [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]\n\n    References\n    ----------\n    .. [1] Cooper, Keith D., Harvey, Timothy J. and Kennedy, Ken.\n           \"A simple, fast dominance algorithm.\" (2006).\n           https://hdl.handle.net/1911/96345\n    \"\"\"\n    if start not in G:\n        raise nx.NetworkXError(\"start is not in G\")\n\n    idom = {start: start}\n\n    order = list(nx.dfs_postorder_nodes(G, start))\n    dfn = {u: i for i, u in enumerate(order)}\n    order.pop()\n    order.reverse()\n\n    def intersect(u, v):\n        while u != v:\n            while dfn[u] < dfn[v]:\n                u = idom[u]\n            while dfn[u] > dfn[v]:\n                v = idom[v]\n        return u\n\n    changed = True\n    while changed:\n        changed = False\n        for u in order:\n            new_idom = reduce(intersect, (v for v in G.pred[u] if v in idom))\n            if u not in idom or idom[u] != new_idom:\n                idom[u] = new_idom\n                changed = True\n\n    return idom"
  },
  {
    "task_id": "203",
    "filename": "program_203.py",
    "code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)"
  },
  {
    "task_id": "206",
    "filename": "program_206.py",
    "code": "def lcp_w_suffix_str(array, s):\n\tN = len(array)\n\n\tlcp_array = [0]*N\n\tinv_suffix = [0]*N\n\n\tfor index in range(N):\n\t\tinv_suffix[array[index]] = index\n\n\tmaxLen = 0\n\n\tfor index in range(N):\n\t\tif inv_suffix[index] == N-1:\n\t\t\tmaxLen = 0\n\t\t\tcontinue\n\n\t\tindex_j = array[inv_suffix[index]+1]\n\t\twhile(index+maxLen < N and index_j+maxLen < N and s[index+maxLen] == s[index_j+maxLen]):\n\t\t\tmaxLen += 1\n\n\t\tlcp_array[inv_suffix[index]] = maxLen\n\n\t\tif maxLen > 0:\n\t\t\tmaxLen -= 1\n\n\treturn lcp_array"
  },
  {
    "task_id": "207",
    "filename": "program_207.py",
    "code": "def neg_count(list):\n  neg_count= 0\n  for num in list:\n    if num <= 0:\n      neg_count += 1\n  return neg_count"
  },
  {
    "task_id": "208",
    "filename": "program_208.py",
    "code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x"
  },
  {
    "task_id": "215",
    "filename": "program_215.py",
    "code": "def get_1s_count(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    count = 0\n    while number:\n        # This way we arrive at next set bit (next 1) instead of looping\n        # through each bit and checking for 1s hence the\n        # loop won't run 32 times it will only run the number of `1` times\n        number &= number - 1\n        count += 1\n    return count"
  },
  {
    "task_id": "217",
    "filename": "program_217.py",
    "code": "def reverse_bit(number: int) -> str:\n    \"\"\"\n    Take in an 32 bit integer, reverse its bits,\n    return a string of reverse bits\n\n    result of a reverse_bit and operation on the integer provided.\n\n    >>> reverse_bit(25)\n    '00000000000000000000000000011001'\n    >>> reverse_bit(37)\n    '00000000000000000000000000100101'\n    >>> reverse_bit(21)\n    '00000000000000000000000000010101'\n    >>> reverse_bit(58)\n    '00000000000000000000000000111010'\n    >>> reverse_bit(0)\n    '00000000000000000000000000000000'\n    >>> reverse_bit(256)\n    '00000000000000000000000100000000'\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be positive\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must be positive\")\n    elif isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    elif isinstance(number, str):\n        raise TypeError(\"'<' not supported between instances of 'str' and 'int'\")\n    result = 0\n    # iterator over [1 to 32],since we are dealing with 32 bit integer\n    for _ in range(1, 33):\n        # left shift the bits by unity\n        result = result << 1\n        # get the end bit\n        end_bit = number % 2\n        # right shift the bits by unity\n        number = number >> 1\n        # add that bit to our ans\n        result = result | end_bit\n    return get_reverse_bit_string(result)"
  },
  {
    "task_id": "218",
    "filename": "program_218.py",
    "code": "def count_elim(num):\n  count_elim = 0\n  for n in num:\n    if isinstance(n, tuple):\n        break\n    count_elim += 1\n  return count_elim"
  },
  {
    "task_id": "223",
    "filename": "program_223.py",
    "code": "def excess_3_code(number: int) -> str:\n    \"\"\"\n    Find excess-3 code of integer base 10.\n    Add 3 to all digits in a decimal number then convert to a binary-coded decimal.\n    https://en.wikipedia.org/wiki/Excess-3\n\n    >>> excess_3_code(0)\n    '0b0011'\n    >>> excess_3_code(3)\n    '0b0110'\n    >>> excess_3_code(2)\n    '0b0101'\n    >>> excess_3_code(20)\n    '0b01010011'\n    >>> excess_3_code(120)\n    '0b010001010011'\n    \"\"\"\n    num = \"\"\n    for digit in str(max(0, number)):\n        num += str(bin(int(digit) + 3))[2:].zfill(4)\n    return \"0b\" + num"
  },
  {
    "task_id": "224",
    "filename": "program_224.py",
    "code": "import sys\n\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i"
  },
  {
    "task_id": "226",
    "filename": "program_226.py",
    "code": "import re\n\ndef check_literals(text, patterns):\n  for pattern in patterns:\n    if re.search(pattern,  text):\n        return ('Matched!')\n    else:\n        return ('Not Matched!')"
  },
  {
    "task_id": "227",
    "filename": "program_227.py",
    "code": "def min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]"
  },
  {
    "task_id": "228",
    "filename": "program_228.py",
    "code": "def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n\n    \"\"\"\n\n    A matrix multiplied with its inverse gives the identity matrix.\n\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n\n    [[0.0, 0.5], [0.2, -0.2]]\n\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n\n    Traceback (most recent call last):\n\n        ...\n\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\n    \"\"\"\n\n    d = Decimal\n\n    # Check if the provided matrix has 2 rows and 2 columns\n\n    # since this implementation only works for 2x2 matrices\n\n    if len(matrix) == 2 and len(matrix[0]) == 2 and len(matrix[1]) == 2:\n\n        # Calculate the determinant of the matrix\n\n        determinant = float(\n\n            d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1])\n\n        )\n\n        if determinant == 0:\n\n            raise ValueError(\"This matrix has no inverse.\")\n\n        # Creates a copy of the matrix with swapped positions of the elements\n\n        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\n\n        swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]\n\n        swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]\n\n        # Calculate the inverse of the matrix\n\n        return [\n\n            [(float(d(n)) / determinant) or 0.0 for n in row] for row in swapped_matrix\n\n        ]\n\n    elif (\n\n        len(matrix) == 3\n\n        and len(matrix[0]) == 3\n\n        and len(matrix[1]) == 3\n\n        and len(matrix[2]) == 3\n\n    ):\n\n        # Calculate the determinant of the matrix using Sarrus rule\n\n        determinant = float(\n\n            (\n\n                (d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]))\n\n                + (d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]))\n\n                + (d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]))\n\n            )\n\n            - (\n\n                (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]))\n\n                + (d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]))\n\n                + (d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1]))\n\n            )\n\n        )\n\n        if determinant == 0:\n\n            raise ValueError(\"This matrix has no inverse.\")\n\n        # Creating cofactor matrix\n\n        cofactor_matrix = [\n\n            [d(0.0), d(0.0), d(0.0)],\n\n            [d(0.0), d(0.0), d(0.0)],\n\n            [d(0.0), d(0.0), d(0.0)],\n\n        ]\n\n        cofactor_matrix[0][0] = (d(matrix[1][1]) * d(matrix[2][2])) - (\n\n            d(matrix[1][2]) * d(matrix[2][1])\n\n        )\n\n        cofactor_matrix[0][1] = -(\n\n            (d(matrix[1][0]) * d(matrix[2][2])) - (d(matrix[1][2]) * d(matrix[2][0]))\n\n        )\n\n        cofactor_matrix[0][2] = (d(matrix[1][0]) * d(matrix[2][1])) - (\n\n            d(matrix[1][1]) * d(matrix[2][0])\n\n        )\n\n        cofactor_matrix[1][0] = -(\n\n            (d(matrix[0][1]) * d(matrix[2][2])) - (d(matrix[0][2]) * d(matrix[2][1]))\n\n        )\n\n        cofactor_matrix[1][1] = (d(matrix[0][0]) * d(matrix[2][2])) - (\n\n            d(matrix[0][2]) * d(matrix[2][0])\n\n        )\n\n        cofactor_matrix[1][2] = -(\n\n            (d(matrix[0][0]) * d(matrix[2][1])) - (d(matrix[0][1]) * d(matrix[2][0]))\n\n        )\n\n        cofactor_matrix[2][0] = (d(matrix[0][1]) * d(matrix[1][2])) - (\n\n            d(matrix[0][2]) * d(matrix[1][1])\n\n        )\n\n        cofactor_matrix[2][1] = -(\n\n            (d(matrix[0][0]) * d(matrix[1][2])) - (d(matrix[0][2]) * d(matrix[1][0]))\n\n        )\n\n        cofactor_matrix[2][2] = (d(matrix[0][0]) * d(matrix[1][1])) - (\n\n            d(matrix[0][1]) * d(matrix[1][0])\n\n        )\n\n        # Transpose the cofactor matrix (Adjoint matrix)\n\n        adjoint_matrix = array(cofactor_matrix)\n\n        for i in range(3):\n\n            for j in range(3):\n\n                adjoint_matrix[i][j] = cofactor_matrix[j][i]\n\n        # Inverse of the matrix using the formula (1/determinant) * adjoint matrix\n\n        inverse_matrix = array(cofactor_matrix)\n\n        for i in range(3):\n\n            for j in range(3):\n\n                inverse_matrix[i][j] /= d(determinant)\n\n        # Calculate the inverse of the matrix\n\n        return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]\n\n    raise ValueError(\"Please provide a matrix of size 2x2 or 3x3.\")"
  },
  {
    "task_id": "229",
    "filename": "program_229.py",
    "code": "def num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j, col in enumerate(grid[i]):\n            if col == 1:\n                dfs(grid, i, j)\n                count += 1\n    return count"
  },
  {
    "task_id": "230",
    "filename": "program_230.py",
    "code": "def max_ones_index(arr):\n\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n\n    for curr in range(n):\n\n        # If current element is 0,\n        # then calculate the difference\n        # between curr and prev_prev_zero\n        if arr[curr] == 0:\n            if curr - prev_prev_zero > max_count:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n\n    if n - prev_prev_zero > max_count:\n        max_index = prev_zero\n\n    return max_index"
  },
  {
    "task_id": "232",
    "filename": "program_232.py",
    "code": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]"
  },
  {
    "task_id": "235",
    "filename": "program_235.py",
    "code": "def factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    facs: list[int] = []\n    if num < 1:\n        return facs\n    facs.append(1)\n    if num == 1:\n        return facs\n    facs.append(num)\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:  # If i is a factor of num\n            facs.append(i)\n            d = num // i  # num//i is the other factor of num\n            if d != i:  # If d and i are distinct\n                facs.append(d)  # we have found another factor\n    facs.sort()\n    return facs"
  },
  {
    "task_id": "236",
    "filename": "program_236.py",
    "code": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        '''\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        '''\n\n        if '#' in trie:\n            result.add(pre)\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n            return\n\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i+1, j, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            backtrack(board, i, j+1, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            backtrack(board, i-1, j, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            backtrack(board, i, j-1, trie[board[i][j]],\n                      pre+board[i][j], used, result)\n            used[i][j] = False\n\n    # make a trie structure that is essentially dictionaries of dictionaries\n    # that map each character to a potential next character\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n\n    # result is a set of found words since we do not want repeats\n    result = set()\n    used = [[False]*len(board[0]) for _ in range(len(board))]\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)"
  },
  {
    "task_id": "239",
    "filename": "program_239.py",
    "code": "def word_len(s):\n    s = s.split(' ')\n    for word in s:\n        if len(word)%2==0:\n            return True\n        else:\n          return False"
  },
  {
    "task_id": "245",
    "filename": "program_245.py",
    "code": "def max_sub_array_sum_repeated(a, n, k):\n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k):\n\t\tmax_ending_here = max_ending_here + a[i%n]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\t\tif (max_ending_here < 0):\n\t\t\tmax_ending_here = 0\n\treturn max_so_far"
  },
  {
    "task_id": "247",
    "filename": "program_247.py",
    "code": "def max_sum_pair_diff_lessthan_K(arr, N, K):\n\tarr.sort()\n\tdp = [0] * N\n\tdp[0] = 0\n\tfor i in range(1, N):\n\t\tdp[i] = dp[i-1]\n\t\tif (arr[i] - arr[i-1] < K):\n\t\t\tif (i >= 2):\n\t\t\t\tdp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]);\n\t\t\telse:\n\t\t\t\tdp[i] = max(dp[i], arr[i] + arr[i-1]);\n\treturn dp[N - 1]"
  },
  {
    "task_id": "249",
    "filename": "program_249.py",
    "code": "def char_frequency(str1):\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if n in keys:\n            dict[n] += 1\n        else:\n            dict[n] = 1\n    return dict"
  },
  {
    "task_id": "250",
    "filename": "program_250.py",
    "code": "def first_Factorial_Divisible_Number(x):\n    i = 1;\n    fact = 1;\n    for i in range(1,x):\n        fact = fact * i\n        if (fact % x == 0):\n            break\n    return i"
  },
  {
    "task_id": "251",
    "filename": "program_251.py",
    "code": "def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False"
  },
  {
    "task_id": "259",
    "filename": "program_259.py",
    "code": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr"
  },
  {
    "task_id": "260",
    "filename": "program_260.py",
    "code": "def int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:\n        bytestr.append(num & 0xff)\n        num >>= 8\n    return bytes(bytestr)"
  },
  {
    "task_id": "261",
    "filename": "program_261.py",
    "code": "def get_total_number_of_sequences(m,n):\n\tT=[[0 for i in range(n+1)] for i in range(m+1)]\n\tfor i in range(m+1):\n\t\tfor j in range(n+1):\n\t\t\tif i==0 or j==0:\n\t\t\t\tT[i][j]=0\n\t\t\telif i<j:\n\t\t\t\tT[i][j]=0\n\t\t\telif j==1:\n\t\t\t\tT[i][j]=i\n\t\t\telse:\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1]\n\treturn T[m][n]"
  },
  {
    "task_id": "266",
    "filename": "program_266.py",
    "code": "def minimum_Length(s) :\n    maxOcc = 0\n    n = len(s)\n    arr = [0]*26\n    for i in range(n) :\n        arr[ord(s[i]) -ord('a')] += 1\n    for i in range(26) :\n        if arr[i] > maxOcc :\n            maxOcc = arr[i]\n    return n - maxOcc"
  },
  {
    "task_id": "267",
    "filename": "program_267.py",
    "code": "def count_char_position(str1):\n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or\n            (i == ord(str1[i]) - ord('a'))):\n            count_chars += 1\n    return count_chars"
  },
  {
    "task_id": "269",
    "filename": "program_269.py",
    "code": "from collections import deque\n\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '(' or ch == '{' or ch == '[':\n            stack.append(ch)\n        if ch == ')' or ch == '}' or ch == ']':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\n                return False\n    return not stack"
  },
  {
    "task_id": "272",
    "filename": "program_272.py",
    "code": "def even_Power_Sum(n):\n    sum = 0;\n    for i in range(1,n+1):\n        j = 2*i;\n        sum = sum + (j*j*j*j*j);\n    return sum;"
  },
  {
    "task_id": "274",
    "filename": "program_274.py",
    "code": "def count_no_of_ways(n, k):\n\tdp = [0] * (n + 1)\n\ttotal = k\n\tmod = 1000000007\n\tdp[1] = k\n\tdp[2] = k * k\n\tfor i in range(3,n+1):\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod\n\treturn dp[n]"
  },
  {
    "task_id": "275",
    "filename": "program_275.py",
    "code": "def first_Repeated_Char(str):\n    h = {}\n    for ch in str:\n        if ch in h:\n            return ch;\n        else:\n            h[ch] = 0\n    return '\\0'"
  },
  {
    "task_id": "279",
    "filename": "program_279.py",
    "code": "from itertools import groupby\n\ndef group_element(test_list):\n  res = dict()\n  for key, val in groupby(sorted(test_list, key = lambda ele: ele[1]), key = lambda ele: ele[1]):\n    res[key] = [ele[0] for ele in val]\n  return (res)"
  },
  {
    "task_id": "281",
    "filename": "program_281.py",
    "code": "def find_lcm(num1, num2):\n\tif(num1>num2):\n\t\tnum = num1\n\t\tden = num2\n\telse:\n\t\tnum = num2\n\t\tden = num1\n\trem = num % den\n\twhile (rem != 0):\n\t\tnum = den\n\t\tden = rem\n\t\trem = num % den\n\tgcd = den\n\tlcm = int(int(num1 * num2)/int(gcd))\n\treturn lcm"
  },
  {
    "task_id": "282",
    "filename": "program_282.py",
    "code": "import math as mt\n\ndef get_Position(a,n,m):\n    for i in range(n):\n        a[i] = (a[i] // m + (a[i] % m != 0))\n    result,maxx = -1,-1\n    for i in range(n - 1,-1,-1):\n        if (maxx < a[i]):\n            maxx = a[i]\n            result = i\n    return result + 1"
  },
  {
    "task_id": "285",
    "filename": "program_285.py",
    "code": "def Odd_Length_Sum(arr):\n    Sum = 0\n    l = len(arr)\n    for i in range(l):\n        Sum += ((((i + 1) *(l - i) + 1) // 2) * arr[i])\n    return Sum"
  },
  {
    "task_id": "288",
    "filename": "program_288.py",
    "code": "def bin_to_hexadecimal(binary_str: str) -> str:\n    \"\"\"\n    Converting a binary string into hexadecimal using Grouping Method\n\n    >>> bin_to_hexadecimal('101011111')\n    '0x15f'\n    >>> bin_to_hexadecimal(' 1010   ')\n    '0x0a'\n    >>> bin_to_hexadecimal('-11101')\n    '-0x1d'\n    >>> bin_to_hexadecimal('a')\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_hexadecimal('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    # Sanitising parameter\n    binary_str = str(binary_str).strip()\n\n    # Exceptions\n    if not binary_str:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = binary_str[0] == \"-\"\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not all(char in \"01\" for char in binary_str):\n        raise ValueError(\"Non-binary value was passed to the function\")\n\n    binary_str = (\n        \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    )\n\n    hexadecimal = []\n    for x in range(0, len(binary_str), 4):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])\n    hexadecimal_str = \"0x\" + \"\".join(hexadecimal)\n\n    return \"-\" + hexadecimal_str if is_negative else hexadecimal_str"
  },
  {
    "task_id": "289",
    "filename": "program_289.py",
    "code": "def clear_lru_caches() -> None:\n    \"\"\"Clear caches holding references to AST nodes.\"\"\"\n    caches_holding_node_references: list[_lru_cache_wrapper[Any]] = [\n        class_is_abstract,\n        in_for_else_branch,\n        infer_all,\n        is_overload_stub,\n        overridden_method,\n        unimplemented_abstract_methods,\n        safe_infer,\n        _similar_names,\n    ]\n    for lru in caches_holding_node_references:\n        lru.cache_clear()"
  },
  {
    "task_id": "293",
    "filename": "program_293.py",
    "code": "def stable_matching(\n    donor_pref: list[list[int]], recipient_pref: list[list[int]]\n) -> list[int]:\n    \"\"\"\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\n    prefer each other over their partner.  The function accepts the preferences of\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\n    returns a list where the index position corresponds to the donor and value at the\n    index is the organ recipient.\n\n    To better understand the algorithm, see also:\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n    >>> stable_matching(donor_pref, recipient_pref)\n    [1, 2, 3, 0]\n    \"\"\"\n    assert len(donor_pref) == len(recipient_pref)\n\n    n = len(donor_pref)\n    unmatched_donors = list(range(n))\n    donor_record = [-1] * n  # who the donor has donated to\n    rec_record = [-1] * n  # who the recipient has received from\n    num_donations = [0] * n\n\n    while unmatched_donors:\n        donor = unmatched_donors[0]\n        donor_preference = donor_pref[donor]\n        recipient = donor_preference[num_donations[donor]]\n        num_donations[donor] += 1\n        rec_preference = recipient_pref[recipient]\n        prev_donor = rec_record[recipient]\n\n        if prev_donor != -1:\n            if rec_preference.index(prev_donor) > rec_preference.index(donor):\n                rec_record[recipient] = donor\n                donor_record[donor] = recipient\n                unmatched_donors.append(prev_donor)\n                unmatched_donors.remove(donor)\n        else:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.remove(donor)\n    return donor_record"
  },
  {
    "task_id": "294",
    "filename": "program_294.py",
    "code": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not n: return []\n    m = len(matrix[0])\n    if not m: return []\n    res = []\n    atlantic = [[False for _ in range (n)] for _ in range(m)]\n    pacific =  [[False for _ in range (n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float(\"-inf\"), i, 0)\n        dfs(atlantic, matrix, float(\"-inf\"), i, m-1)\n    for i in range(m):\n        dfs(pacific, matrix, float(\"-inf\"), 0, i)\n        dfs(atlantic, matrix, float(\"-inf\"), n-1, i)\n    for i in range(n):\n        for j in range(m):\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n    return res"
  },
  {
    "task_id": "296",
    "filename": "program_296.py",
    "code": "def neg_nos(list1):\n  for num in list1:\n    if num < 0:\n       return num"
  },
  {
    "task_id": "297",
    "filename": "program_297.py",
    "code": "from array import array\n\ndef negative_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x < 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)"
  },
  {
    "task_id": "303",
    "filename": "program_303.py",
    "code": "def merge(a,b):\n    c = []\n    while len(a) != 0 and len(b) != 0:\n        if a[0] < b[0]:\n            c.append(a[0])\n            a.remove(a[0])\n        else:\n            c.append(b[0])\n            b.remove(b[0])\n    if len(a) == 0:\n        c += b\n    else:\n        c += a\n    return c"
  },
  {
    "task_id": "304",
    "filename": "program_304.py",
    "code": "def remove_datatype(test_tuple, data_type):\n  res = []\n  for ele in test_tuple:\n    if not isinstance(ele, data_type):\n      res.append(ele)\n  return (res)"
  },
  {
    "task_id": "307",
    "filename": "program_307.py",
    "code": "def common_prefix_util(str1, str2):\n\tresult = \"\";\n\tn1 = len(str1)\n\tn2 = len(str2)\n\ti = 0\n\tj = 0\n\twhile i <= n1 - 1 and j <= n2 - 1:\n\t\tif (str1[i] != str2[j]):\n\t\t\tbreak\n\t\tresult += str1[i]\n\t\ti += 1\n\t\tj += 1\n\treturn (result)"
  },
  {
    "task_id": "308",
    "filename": "program_308.py",
    "code": "def extract_index_list(l1, l2, l3):\n    result = []\n    for m, n, o in zip(l1, l2, l3):\n        if (m == n == o):\n            result.append(m)\n    return result"
  },
  {
    "task_id": "310",
    "filename": "program_310.py",
    "code": "def maze_search(maze):\n    BLOCKED, ALLOWED = 0, 1\n    UNVISITED, VISITED = 0, 1\n\n    initial_x, initial_y = 0, 0\n\n    if maze[initial_x][initial_y] == BLOCKED:\n        return -1\n\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n    height, width = len(maze), len(maze[0])\n\n    target_x, target_y = height - 1, width - 1\n\n    queue = deque([(initial_x, initial_y, 0)])\n\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n\n    while queue:\n        x, y, steps = queue.popleft()\n\n        if x == target_x and y == target_y:\n            return steps\n\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n\n            if not (0 <= new_x < height and 0 <= new_y < width):\n                continue\n\n            if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n\n    return -1"
  },
  {
    "task_id": "313",
    "filename": "program_313.py",
    "code": "def removals(arr, n, k):\n\tans = n - 1\n\tarr.sort()\n\tfor i in range(0, n):\n\t\tj = find_ind(arr[i], i,\n\t\t\t\t\tn, k, arr)\n\t\tif (j != -1):\n\t\t\tans = min(ans, n -\n\t\t\t\t\t\t(j - i + 1))\n\treturn ans"
  },
  {
    "task_id": "315",
    "filename": "program_315.py",
    "code": "def prime_num(num):\n  if num >=1:\n   for i in range(2, num//2):\n     if (num % i) == 0:\n                return False\n     else:\n                return True\n  else:\n          return False"
  },
  {
    "task_id": "316",
    "filename": "program_316.py",
    "code": "def is_undulating(n):\n\tif (len(n) <= 2):\n\t\treturn False\n\tfor i in range(2, len(n)):\n\t\tif (n[i - 2] != n[i]):\n\t\t\treturn False\n\treturn True"
  },
  {
    "task_id": "318",
    "filename": "program_318.py",
    "code": "def return_sum(dict):\n  sum = 0\n  for i in dict.values():\n    sum = sum + i\n  return sum"
  },
  {
    "task_id": "323",
    "filename": "program_323.py",
    "code": "def encode_rle(input):\n    \"\"\"\n    Gets a stream of data and compresses it\n    under a Run-Length Encoding.\n    :param input: The data to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    if not input: return ''\n\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n\n    for ch in input:\n\n        # Check If the subsequent character does not match\n        if ch != prev_ch:\n            # Add the count and character\n            if prev_ch:\n                encoded_str += str(count) + prev_ch\n            # Reset the count and set the character\n            count = 1\n            prev_ch = ch\n        else:\n            # Otherwise increment the counter\n            count += 1\n    else:\n        return encoded_str + (str(count) + prev_ch)"
  },
  {
    "task_id": "324",
    "filename": "program_324.py",
    "code": "def count_Rectangles(radius):\n    rectangles = 0\n    diameter = 2 * radius\n    diameterSquare = diameter * diameter\n    for a in range(1, 2 * radius):\n        for b in range(1, 2 * radius):\n            diagnalLengthSquare = (a * a +  b * b)\n            if (diagnalLengthSquare <= diameterSquare) :\n                rectangles += 1\n    return rectangles"
  },
  {
    "task_id": "325",
    "filename": "program_325.py",
    "code": "def breakSum(n):\n\tdp = [0]*(n+1)\n\tdp[0] = 0\n\tdp[1] = 1\n\tfor i in range(2, n+1):\n\t\tdp[i] = max(dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)], i);\n\treturn dp[n]"
  },
  {
    "task_id": "326",
    "filename": "program_326.py",
    "code": "def decimal_to_any(num: int, base: int) -> str:\n    \"\"\"\n    Convert a positive integer to another base as str.\n    >>> decimal_to_any(0, 2)\n    '0'\n    >>> decimal_to_any(5, 4)\n    '11'\n    >>> decimal_to_any(20, 3)\n    '202'\n    >>> decimal_to_any(58, 16)\n    '3A'\n    >>> decimal_to_any(243, 17)\n    'E5'\n    >>> decimal_to_any(34923, 36)\n    'QY3'\n    >>> decimal_to_any(10, 11)\n    'A'\n    >>> decimal_to_any(16, 16)\n    '10'\n    >>> decimal_to_any(36, 36)\n    '10'\n    >>> # negatives will error\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: parameter must be positive int\n    >>> # floats will error\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: int() can't convert non-string with explicit base\n    >>> # a float base will error\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # a str base will error\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    >>> # a base less than 2 will error\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be >= 2\n    >>> # a base greater than 36 will error\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be <= 36\n    \"\"\"\n    if isinstance(num, float):\n        raise TypeError(\"int() can't convert non-string with explicit base\")\n    if num < 0:\n        raise ValueError(\"parameter must be positive int\")\n    if isinstance(base, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n    if isinstance(base, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if base in (0, 1):\n        raise ValueError(\"base must be >= 2\")\n    if base > 36:\n        raise ValueError(\"base must be <= 36\")\n    new_value = \"\"\n    mod = 0\n    div = 0\n    while div != 1:\n        div, mod = divmod(num, base)\n        if base >= 11 and 9 < mod < 36:\n            actual_value = ALPHABET_VALUES[str(mod)]\n        else:\n            actual_value = str(mod)\n        new_value += actual_value\n        div = num // base\n        num = div\n        if div == 0:\n            return str(new_value[::-1])\n        elif div == 1:\n            new_value += str(div)\n            return str(new_value[::-1])\n\n    return new_value[::-1]"
  },
  {
    "task_id": "327",
    "filename": "program_327.py",
    "code": "def find_Min_Sum(a,b,n):\n    a.sort()\n    b.sort()\n    sum = 0\n    for i in range(n):\n        sum = sum + abs(a[i] - b[i])\n    return sum"
  },
  {
    "task_id": "328",
    "filename": "program_328.py",
    "code": "def longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]"
  },
  {
    "task_id": "329",
    "filename": "program_329.py",
    "code": "def previous_palindrome(num):\n    for x in range(num-1,0,-1):\n        if str(x) == str(x)[::-1]:\n            return x"
  },
  {
    "task_id": "334",
    "filename": "program_334.py",
    "code": "def num_comm_div(x,y):\n  n = ngcd(x,y)\n  result = 0\n  z = int(n**0.5)\n  i = 1\n  while(i <= z):\n    if(n % i == 0):\n      result += 2\n      if(i == n/i):\n        result-=1\n    i+=1\n  return result"
  },
  {
    "task_id": "335",
    "filename": "program_335.py",
    "code": "def gcd(p,q):\n    while q != 0:\n        p, q = q,p%q\n    return p"
  },
  {
    "task_id": "336",
    "filename": "program_336.py",
    "code": "def palindromic_substrings_iter(s):\n    \"\"\"\n    A slightly more Pythonic approach with a recursive generator\n    \"\"\"\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield [sub] + rest"
  },
  {
    "task_id": "337",
    "filename": "program_337.py",
    "code": "def decimal_to_hexadecimal(decimal: float) -> str:\n    \"\"\"\n    take integer decimal value, return hexadecimal representation as str beginning\n    with 0x\n    >>> decimal_to_hexadecimal(5)\n    '0x5'\n    >>> decimal_to_hexadecimal(15)\n    '0xf'\n    >>> decimal_to_hexadecimal(37)\n    '0x25'\n    >>> decimal_to_hexadecimal(255)\n    '0xff'\n    >>> decimal_to_hexadecimal(4096)\n    '0x1000'\n    >>> decimal_to_hexadecimal(999098)\n    '0xf3eba'\n    >>> # negatives work too\n    >>> decimal_to_hexadecimal(-256)\n    '-0x100'\n    >>> # floats are acceptable if equivalent to an int\n    >>> decimal_to_hexadecimal(17.0)\n    '0x11'\n    >>> # other floats will error\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # strings will error as well\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # results are the same when compared to Python's default hex function\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\n    True\n    \"\"\"\n    assert isinstance(decimal, (int, float))\n    assert decimal == int(decimal)\n    decimal = int(decimal)\n    hexadecimal = \"\"\n    negative = False\n    if decimal < 0:\n        negative = True\n        decimal *= -1\n    while decimal > 0:\n        decimal, remainder = divmod(decimal, 16)\n        hexadecimal = values[remainder] + hexadecimal\n    hexadecimal = \"0x\" + hexadecimal\n    if negative:\n        hexadecimal = \"-\" + hexadecimal\n    return hexadecimal"
  },
  {
    "task_id": "341",
    "filename": "program_341.py",
    "code": "def maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)"
  },
  {
    "task_id": "345",
    "filename": "program_345.py",
    "code": "def flatten_iter(iterable):\n    \"\"\"\n    Takes as input multi dimensional iterable and\n    returns generator which produces one dimensional output.\n    \"\"\"\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)\n        else:\n            yield element"
  },
  {
    "task_id": "347",
    "filename": "program_347.py",
    "code": "def flatten(test_tuple):\n\tfor tup in test_tuple:\n\t\tif isinstance(tup, tuple):\n\t\t\tyield from flatten(tup)\n\t\telse:\n\t\t\tyield tup"
  },
  {
    "task_id": "348",
    "filename": "program_348.py",
    "code": "def missing_ranges(arr, lo, hi):\n\n    res = []\n    start = lo\n\n    for n in arr:\n\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n-1))\n            start = n + 1\n\n    if start <= hi:                 # after done iterating thru array,\n        res.append((start, hi))     # append remainder to list\n\n    return res"
  },
  {
    "task_id": "349",
    "filename": "program_349.py",
    "code": "def is_Isomorphic(str1,str2):\n    dict_str1 = {}\n    dict_str2 = {}\n    for i, value in enumerate(str1):\n        dict_str1[value] = dict_str1.get(value,[]) + [i]\n    for j, value in enumerate(str2):\n        dict_str2[value] = dict_str2.get(value,[]) + [j]\n    if sorted(dict_str1.values()) == sorted(dict_str2.values()):\n        return True\n    else:\n        return False"
  },
  {
    "task_id": "352",
    "filename": "program_352.py",
    "code": "def remove_even(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 != 0):\n        str2 = str2 + str1[i - 1]\n return str2"
  },
  {
    "task_id": "354",
    "filename": "program_354.py",
    "code": "def are_Equal(arr1,arr2,n,m):\n    if (n != m):\n        return False\n    arr1.sort()\n    arr2.sort()\n    for i in range(0,n - 1):\n        if (arr1[i] != arr2[i]):\n            return False\n    return True"
  },
  {
    "task_id": "356",
    "filename": "program_356.py",
    "code": "def zip_tuples(test_tup1, test_tup2):\n  res = []\n  for i, j in enumerate(test_tup1):\n    res.append((j, test_tup2[i % len(test_tup2)]))\n  return (res)"
  },
  {
    "task_id": "357",
    "filename": "program_357.py",
    "code": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([4, 3, 1, 0])\n        2\n        >>> find_missing_number([-4, -3, -1, 0])\n        -2\n        >>> find_missing_number([-2, 2, 1, 3, 0])\n        -1\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number"
  },
  {
    "task_id": "358",
    "filename": "program_358.py",
    "code": "def check_permutation(str1, str2):\n  n1=len(str1)\n  n2=len(str2)\n  if(n1!=n2):\n    return False\n  a=sorted(str1)\n  str1=\" \".join(a)\n  b=sorted(str2)\n  str2=\" \".join(b)\n  for i in range(0, n1, 1):\n    if(str1[i] != str2[i]):\n      return False\n  return True"
  },
  {
    "task_id": "359",
    "filename": "program_359.py",
    "code": "def ngcd(x,y):\n    i=1\n    while(i<=x and i<=y):\n        if(x%i==0 and y%i == 0):\n            gcd=i;\n        i+=1\n    return gcd;"
  },
  {
    "task_id": "367",
    "filename": "program_367.py",
    "code": "def pos_count(list):\n  pos_count= 0\n  for num in list:\n    if num >= 0:\n      pos_count += 1\n  return pos_count"
  },
  {
    "task_id": "368",
    "filename": "program_368.py",
    "code": "import math\n\ndef sumofFactors(n) :\n    if (n % 2 != 0) :\n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) :\n            count= count + 1\n            n = n // i\n            if (i == 2 and count == 1) :\n                curr_sum = 0\n            curr_term = curr_term * i\n            curr_sum = curr_sum + curr_term\n        res = res * curr_sum\n    if (n >= 2) :\n        res = res * (1 + n)\n    return res"
  },
  {
    "task_id": "372",
    "filename": "program_372.py",
    "code": "def re_order(A):\n    k = 0\n    for i in A:\n        if i:\n            A[k] = i\n            k = k + 1\n    for i in range(k, len(A)):\n        A[i] = 0\n    return A"
  },
  {
    "task_id": "373",
    "filename": "program_373.py",
    "code": "def count_alpha_dig_spl(string):\n  alphabets=digits = special = 0\n  for i in range(len(string)):\n    if(string[i].isalpha()):\n        alphabets = alphabets + 1\n    elif(string[i].isdigit()):\n        digits = digits + 1\n    else:\n        special = special + 1\n  return (alphabets,digits,special)"
  },
  {
    "task_id": "374",
    "filename": "program_374.py",
    "code": "import re\n\ndef num_position(text):\n for m in re.finditer(\"\\d+\", text):\n    return m.start()"
  },
  {
    "task_id": "377",
    "filename": "program_377.py",
    "code": "def even_bit_toggle_number(n) :\n    res = 0; count = 0; temp = n\n    while(temp > 0 ) :\n        if (count % 2 == 0) :\n            res = res | (1 << count)\n        count = count + 1\n        temp >>= 1\n    return n ^ res"
  },
  {
    "task_id": "378",
    "filename": "program_378.py",
    "code": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l)+1):\n                new_perms.append(l[:i]+[n]+l[i:])\n                if i < len(l) and l[i] == n:\n                    break  # handles duplication\n        perms = new_perms\n    return perms"
  },
  {
    "task_id": "379",
    "filename": "program_379.py",
    "code": "def permutation_coefficient(n, k):\n\tP = [[0 for i in range(k + 1)]\n\t\t\tfor j in range(n + 1)]\n\tfor i in range(n + 1):\n\t\tfor j in range(min(i, k) + 1):\n\t\t\tif (j == 0):\n\t\t\t\tP[i][j] = 1\n\t\t\telse:\n\t\t\t\tP[i][j] = P[i - 1][j] + (\n\t\t\t\t\t\tj * P[i - 1][j - 1])\n\t\t\tif (j < k):\n\t\t\t\tP[i][j + 1] = 0\n\treturn P[n][k]"
  },
  {
    "task_id": "381",
    "filename": "program_381.py",
    "code": "def prod_Square(n):\n    for i in range(2,(n) + 1):\n        if (i*i < (n+1)):\n            for j in range(2,n + 1):\n                if ((i*i*j*j) == n):\n                    return True;\n    return False;"
  },
  {
    "task_id": "383",
    "filename": "program_383.py",
    "code": "def find_Product(arr,n):\n    arr.sort()\n    prod = 1\n    for i in range(0,n,1):\n        if (arr[i - 1] != arr[i]):\n            prod = prod * arr[i]\n    return prod;"
  },
  {
    "task_id": "385",
    "filename": "program_385.py",
    "code": "def remove_column(list1, n):\n   for i in list1:\n    del i[n]\n   return list1"
  },
  {
    "task_id": "386",
    "filename": "program_386.py",
    "code": "def lbs(arr):\n\tn = len(arr)\n\tlis = [1 for i in range(n+1)]\n\tfor i in range(1 , n):\n\t\tfor j in range(0 , i):\n\t\t\tif ((arr[i] > arr[j]) and (lis[i] < lis[j] +1)):\n\t\t\t\tlis[i] = lis[j] + 1\n\tlds = [1 for i in range(n+1)]\n\tfor i in reversed(range(n-1)):\n\t\tfor j in reversed(range(i-1 ,n)):\n\t\t\tif(arr[i] > arr[j] and lds[i] < lds[j] + 1):\n\t\t\t\tlds[i] = lds[j] + 1\n\tmaximum = lis[0] + lds[0] - 1\n\tfor i in range(1 , n):\n\t\tmaximum = max((lis[i] + lds[i]-1), maximum)\n\treturn maximum"
  },
  {
    "task_id": "388",
    "filename": "program_388.py",
    "code": "def get_max_occuring_char(str1):\n  ASCII_SIZE = 256\n  ctr = [0] * ASCII_SIZE\n  max = -1\n  ch = ''\n  for i in str1:\n    ctr[ord(i)]+=1;\n  for i in str1:\n    if max < ctr[ord(i)]:\n      max = ctr[ord(i)]\n      ch = i\n  return ch"
  },
  {
    "task_id": "390",
    "filename": "program_390.py",
    "code": "def highest_Power_of_2(n):\n    res = 0;\n    for i in range(n, 0, -1):\n        if ((i & (i - 1)) == 0):\n            res = i;\n            break;\n    return res;"
  },
  {
    "task_id": "393",
    "filename": "program_393.py",
    "code": "def first_repeated_word(str1):\n  temp = set()\n  for word in str1.split():\n    if word in temp:\n      return word;\n    else:\n      temp.add(word)\n  return 'None'"
  },
  {
    "task_id": "395",
    "filename": "program_395.py",
    "code": "def radix_sort(nums):\n    RADIX = 10\n    placement = 1\n    max_digit = max(nums)\n\n    while placement < max_digit:\n      buckets = [list() for _ in range( RADIX )]\n      for i in nums:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range( RADIX ):\n        buck = buckets[b]\n        for i in buck:\n          nums[a] = i\n          a += 1\n      placement *= RADIX\n    return nums"
  },
  {
    "task_id": "396",
    "filename": "program_396.py",
    "code": "def str_to_list(string):\n\ttemp = []\n\tfor x in string:\n\t\ttemp.append(x)\n\treturn temp"
  },
  {
    "task_id": "398",
    "filename": "program_398.py",
    "code": "def ascii_value_string(str1):\n  for i in range(len(str1)):\n   return ord(str1[i])"
  },
  {
    "task_id": "399",
    "filename": "program_399.py",
    "code": "def find_Odd_Pair(A,N) :\n    oddPair = 0\n    for i in range(0,N) :\n        for j in range(i+1,N) :\n            if ((A[i] ^ A[j]) % 2 != 0):\n                oddPair+=1\n    return oddPair"
  },
  {
    "task_id": "400",
    "filename": "program_400.py",
    "code": "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)]\n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]"
  },
  {
    "task_id": "401",
    "filename": "program_401.py",
    "code": "from collections import Counter\n\ndef second_frequent(input):\n\tdict = Counter(input)\n\tvalue = sorted(dict.values(), reverse=True)\n\tsecond_large = value[1]\n\tfor (key, val) in dict.items():\n\t\tif val == second_large:\n\t\t\treturn (key)"
  },
  {
    "task_id": "406",
    "filename": "program_406.py",
    "code": "def get_gcd(l):\n  num1 = l[0]\n  num2 = l[1]\n  gcd = find_gcd(num1, num2)\n  for i in range(2, len(l)):\n    gcd = find_gcd(gcd, l[i])\n  return gcd"
  },
  {
    "task_id": "409",
    "filename": "program_409.py",
    "code": "def count_Rotation(arr,n):\n    for i in range (1,n):\n        if (arr[i] < arr[i - 1]):\n            return i\n    return 0"
  },
  {
    "task_id": "414",
    "filename": "program_414.py",
    "code": "def sum_Of_Series(n):\n    sum = 0\n    for i in range(1,n + 1):\n        sum += i * i*i\n    return sum"
  },
  {
    "task_id": "418",
    "filename": "program_418.py",
    "code": "def plus_one_v3(num_arr):\n\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if num_arr[idx[0]]:\n            return num_arr\n    return [1] + num_arr"
  },
  {
    "task_id": "421",
    "filename": "program_421.py",
    "code": "def length_Of_Last_Word(a):\n    l = 0\n    x = a.strip()\n    for i in range(len(x)):\n        if x[i] == \" \":\n            l = 0\n        else:\n            l += 1\n    return l"
  },
  {
    "task_id": "426",
    "filename": "program_426.py",
    "code": "def similarity_search(\n    dataset: np.ndarray, value_array: np.ndarray\n) -> list[list[list[float] | float]]:\n    \"\"\"\n    :param dataset: Set containing the vectors. Should be ndarray.\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\n    :return: Result will be a list containing\n            1. the nearest vector\n            2. distance from the vector\n\n    >>> dataset = np.array([[0], [1], [2]])\n    >>> value_array = np.array([[0]])\n    >>> similarity_search(dataset, value_array)\n    [[[0], 0.0]]\n\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\n    These are the errors that might occur:\n\n    1. If dimensions are different.\n    For example, dataset has 2d array and value_array has 1d array:\n    >>> dataset = np.array([[1]])\n    >>> value_array = np.array([1])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n    2. If data's shapes are different.\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\n    We are expecting same shapes of two arrays, so it is wrong.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n    3. If data types are different.\n    When trying to compare, we are expecting same types so they should be same.\n    If not, it'll come up with errors.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: Input data have different datatype...\n    dataset : float32, value_array : int32\n    \"\"\"\n\n    if dataset.ndim != value_array.ndim:\n        msg = (\n            \"Wrong input data's dimensions... \"\n            f\"dataset : {dataset.ndim}, value_array : {value_array.ndim}\"\n        )\n        raise ValueError(msg)\n\n    try:\n        if dataset.shape[1] != value_array.shape[1]:\n            msg = (\n                \"Wrong input data's shape... \"\n                f\"dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}\"\n            )\n            raise ValueError(msg)\n    except IndexError:\n        if dataset.ndim != value_array.ndim:\n            raise TypeError(\"Wrong shape\")\n\n    if dataset.dtype != value_array.dtype:\n        msg = (\n            \"Input data have different datatype... \"\n            f\"dataset : {dataset.dtype}, value_array : {value_array.dtype}\"\n        )\n        raise TypeError(msg)\n\n    answer = []\n\n    for value in value_array:\n        dist = euclidean(value, dataset[0])\n        vector = dataset[0].tolist()\n\n        for dataset_value in dataset[1:]:\n            temp_dist = euclidean(value, dataset_value)\n\n            if dist > temp_dist:\n                dist = temp_dist\n                vector = dataset_value.tolist()\n\n        answer.append([vector, dist])\n\n    return answer"
  },
  {
    "task_id": "428",
    "filename": "program_428.py",
    "code": "def lucky_num(n):\n List=range(-1,n*n+9,2)\n i=2\n while List[i:]:List=sorted(set(List)-set(List[List[i]::List[i]]));i+=1\n return List[1:n+1]"
  },
  {
    "task_id": "429",
    "filename": "program_429.py",
    "code": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, \"__call__\"):\n            hooks = [hooks]\n        for hook in hooks:\n            _hook_data = hook(hook_data, **kwargs)\n            if _hook_data is not None:\n                hook_data = _hook_data\n    return hook_data"
  },
  {
    "task_id": "433",
    "filename": "program_433.py",
    "code": "def build_client_middlewares(\n    handler: ClientHandlerType,\n    middlewares: Sequence[ClientMiddlewareType],\n) -> ClientHandlerType:\n    \"\"\"\n    Apply middlewares to request handler.\n\n    The middlewares are applied in reverse order, so the first middleware\n    in the list wraps all subsequent middlewares and the handler.\n\n    This implementation avoids using partial/update_wrapper to minimize overhead\n    and doesn't cache to avoid holding references to stateful middleware.\n    \"\"\"\n    # Optimize for single middleware case\n    if len(middlewares) == 1:\n        middleware = middlewares[0]\n\n        async def single_middleware_handler(req: ClientRequest) -> ClientResponse:\n            return await middleware(req, handler)\n\n        return single_middleware_handler\n\n    # Build the chain for multiple middlewares\n    current_handler = handler\n\n    for middleware in reversed(middlewares):\n        # Create a new closure that captures the current state\n        def make_wrapper(\n            mw: ClientMiddlewareType, next_h: ClientHandlerType\n        ) -> ClientHandlerType:\n            async def wrapped(req: ClientRequest) -> ClientResponse:\n                return await mw(req, next_h)\n\n            return wrapped\n\n        current_handler = make_wrapper(middleware, current_handler)\n\n    return current_handler"
  },
  {
    "task_id": "442",
    "filename": "program_442.py",
    "code": "def Split(list):\n    od_li = []\n    for i in list:\n        if (i % 2 != 0):\n            od_li.append(i)\n    return od_li"
  },
  {
    "task_id": "449",
    "filename": "program_449.py",
    "code": "def count_X(tup, x):\n    count = 0\n    for ele in tup:\n        if (ele == x):\n            count = count + 1\n    return count"
  },
  {
    "task_id": "450",
    "filename": "program_450.py",
    "code": "def find_even_Pair(A,N):\n    evenPair = 0\n    for i in range(0,N):\n        for j in range(i+1,N):\n            if ((A[i] ^ A[j]) % 2 == 0):\n                evenPair+=1\n    return evenPair;"
  },
  {
    "task_id": "451",
    "filename": "program_451.py",
    "code": "import math\n\ndef sum_of_odd_Factors(n):\n    res = 1\n    while n % 2 == 0:\n        n = n // 2\n    for i in range(3,int(math.sqrt(n) + 1)):\n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0:\n            count+=1\n            n = n // i\n            curr_term *= i\n            curr_sum += curr_term\n        res *= curr_sum\n    if n >= 2:\n        res *= (1 + n)\n    return res"
  },
  {
    "task_id": "452",
    "filename": "program_452.py",
    "code": "def roman_to_int(s):\n        rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        int_val = 0\n        for i in range(len(s)):\n            if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:\n                int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]\n            else:\n                int_val += rom_val[s[i]]\n        return int_val"
  },
  {
    "task_id": "453",
    "filename": "program_453.py",
    "code": "def prefix_sum(array: list[int], queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    >>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)])\n    [81, 85, 63]\n    >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)])\n    [9, 9, 7]\n    \"\"\"\n    # The prefix sum array\n    dp = [0] * len(array)\n    dp[0] = array[0]\n    for i in range(1, len(array)):\n        dp[i] = dp[i - 1] + array[i]\n\n    # See Algorithm section (Line 44)\n    result = []\n    for query in queries:\n        left, right = query\n        res = dp[right]\n        if left > 0:\n            res -= dp[left - 1]\n        result.append(res)\n\n    return result"
  },
  {
    "task_id": "454",
    "filename": "program_454.py",
    "code": "def len_log(list1):\n    min=len(list1[0])\n    for i in list1:\n        if len(i)<min:\n            min=len(i)\n    return min"
  },
  {
    "task_id": "455",
    "filename": "program_455.py",
    "code": "def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:\n    \"\"\"\n    Return probability list of all possible sums when throwing dice.\n\n    >>> random.seed(0)\n    >>> throw_dice(10, 1)\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n    >>> throw_dice(100, 1)\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n    >>> throw_dice(1000, 1)\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n    >>> throw_dice(10000, 1)\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n    >>> throw_dice(10000, 2)\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\n    \"\"\"\n    dices = [Dice() for i in range(num_dice)]\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\n    for _ in range(num_throws):\n        count_of_sum[sum(dice.roll() for dice in dices)] += 1\n    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]\n    return probability[num_dice:]  # remove probability of sums that never appear"
  },
  {
    "task_id": "457",
    "filename": "program_457.py",
    "code": "def modular_sum(arr, n, m):\n\tif (n > m):\n\t\treturn True\n\tDP = [False for i in range(m)]\n\tfor i in range(n):\n\t\tif (DP[0]):\n\t\t\treturn True\n\t\ttemp = [False for i in range(m)]\n\t\tfor j in range(m):\n\t\t\tif (DP[j] == True):\n\t\t\t\tif (DP[(j + arr[i]) % m] == False):\n\t\t\t\t\ttemp[(j + arr[i]) % m] = True\n\t\tfor j in range(m):\n\t\t\tif (temp[j]):\n\t\t\t\tDP[j] = True\n\t\tDP[arr[i] % m] = True\n\treturn DP[0]"
  },
  {
    "task_id": "459",
    "filename": "program_459.py",
    "code": "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return (res)"
  },
  {
    "task_id": "461",
    "filename": "program_461.py",
    "code": "from heapq import heappop, heappush\n\ndef find_minimum_range(list):\n    high = float('-inf')\n    p = (0, float('inf'))\n    pq = []\n    for i in range(len(list)):\n        heappush(pq, Node(list[i][0], i, 0))\n        high = max(high, list[i][0])\n    while True:\n        top = heappop(pq)\n        low = top.value\n        i = top.list_num\n        j = top.index\n        if high - low < p[1] - p[0]:\n            p = (low, high)\n        if j == len(list[i]) - 1:\n            return p\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\n        high = max(high, list[i][j + 1])"
  },
  {
    "task_id": "463",
    "filename": "program_463.py",
    "code": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    count = 0\n    for item in tup:\n        if item in lst:\n            count+= 1\n    return count"
  },
  {
    "task_id": "467",
    "filename": "program_467.py",
    "code": "def get_Pairs_Count(arr,n,sum):\n    count = 0\n    for i in range(0,n):\n        for j in range(i + 1,n):\n            if arr[i] + arr[j] == sum:\n                count += 1\n    return count"
  },
  {
    "task_id": "468",
    "filename": "program_468.py",
    "code": "from collections import defaultdict\n\ndef count_Substrings(s,n):\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count"
  },
  {
    "task_id": "470",
    "filename": "program_470.py",
    "code": "def remove_even(l):\n    for i in l:\n        if i % 2 == 0:\n            l.remove(i)\n    return l"
  },
  {
    "task_id": "473",
    "filename": "program_473.py",
    "code": "def find_length(string, n):\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n):\n\t\tcurrent_sum += (1 if string[i] == '0' else -1)\n\t\tif current_sum < 0:\n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum)\n\treturn max_sum if max_sum else 0"
  },
  {
    "task_id": "474",
    "filename": "program_474.py",
    "code": "def count_Set_Bits(n) :\n    n += 1;\n    powerOf2 = 2;\n    cnt = n // 2;\n    while (powerOf2 <= n) :\n        totalPairs = n // powerOf2;\n        cnt += (totalPairs // 2) * powerOf2;\n        if (totalPairs & 1) :\n            cnt += (n % powerOf2)\n        else :\n            cnt += 0\n        powerOf2 <<= 1;\n    return cnt;"
  },
  {
    "task_id": "476",
    "filename": "program_476.py",
    "code": "def pass_and_relaxation(\n    graph: dict,\n    v: str,\n    visited_forward: set,\n    visited_backward: set,\n    cst_fwd: dict,\n    cst_bwd: dict,\n    queue: PriorityQueue,\n    parent: dict,\n    shortest_distance: float,\n) -> float:\n    for nxt, d in graph[v]:\n        if nxt in visited_forward:\n            continue\n        old_cost_f = cst_fwd.get(nxt, np.inf)\n        new_cost_f = cst_fwd[v] + d\n        if new_cost_f < old_cost_f:\n            queue.put((new_cost_f, nxt))\n            cst_fwd[nxt] = new_cost_f\n            parent[nxt] = v\n        if (\n            nxt in visited_backward\n            and cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance\n        ):\n            shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]\n    return shortest_distance"
  },
  {
    "task_id": "477",
    "filename": "program_477.py",
    "code": "def retroactive_resolution(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    \"\"\"\n    This function performs a retroactive linear system resolution\n    for triangular matrix\n\n    Examples:\n        1.\n            * 2x1 + 2x2 - 1x3 = 5\n            * 0x1 - 2x2 - 1x3 = -7\n            * 0x1 + 0x2 + 5x3 = 15\n        2.\n            * 2x1 + 2x2 = -1\n            * 0x1 - 2x2 = -1\n\n    >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])\n    array([[2.],\n           [2.],\n           [3.]])\n    >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])\n    array([[-1. ],\n           [ 0.5]])\n    \"\"\"\n\n    rows, columns = np.shape(coefficients)\n\n    x: NDArray[float64] = np.zeros((rows, 1), dtype=float)\n    for row in reversed(range(rows)):\n        total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])\n        x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]\n\n    return x"
  },
  {
    "task_id": "478",
    "filename": "program_478.py",
    "code": "def second_smallest(numbers):\n  if (len(numbers)<2):\n    return\n  if ((len(numbers)==2)  and (numbers[0] == numbers[1]) ):\n    return\n  dup_items = set()\n  uniq_items = []\n  for x in numbers:\n    if x not in dup_items:\n      uniq_items.append(x)\n      dup_items.add(x)\n  uniq_items.sort()\n  return  uniq_items[1]"
  },
  {
    "task_id": "479",
    "filename": "program_479.py",
    "code": "def count_vowels(test_str):\n  res = 0\n  vow_list = ['a', 'e', 'i', 'o', 'u']\n  for idx in range(1, len(test_str) - 1):\n    if test_str[idx] not in vow_list and (test_str[idx - 1] in vow_list or test_str[idx + 1] in vow_list):\n      res += 1\n  if test_str[0] not in vow_list and test_str[1] in vow_list:\n    res += 1\n  if test_str[-1] not in vow_list and test_str[-2] in vow_list:\n    res += 1\n  return (res)"
  },
  {
    "task_id": "481",
    "filename": "program_481.py",
    "code": "def plus_one_v1(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits)-1\n    while i >= 0 or ten == 1:\n        summ = 0\n        if i >= 0:\n            summ += digits[i]\n        if ten:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]"
  },
  {
    "task_id": "483",
    "filename": "program_483.py",
    "code": "def sum_range_list(list1, m, n):\n    sum_range = 0\n    for i in range(m, n+1, 1):\n        sum_range += list1[i]\n    return sum_range"
  },
  {
    "task_id": "485",
    "filename": "program_485.py",
    "code": "def max_product(arr):\n    arr_len = len(arr)\n    if (arr_len < 2):\n        return None\n    x = arr[0]; y = arr[1]\n    for i in range(0, arr_len):\n        for j in range(i + 1, arr_len):\n            if (arr[i] * arr[j] > x * y):\n                x = arr[i]; y = arr[j]\n    return x,y"
  },
  {
    "task_id": "488",
    "filename": "program_488.py",
    "code": "def remove_nested(test_tup):\n  res = tuple()\n  for count, ele in enumerate(test_tup):\n    if not isinstance(ele, tuple):\n      res = res + (ele, )\n  return (res)"
  },
  {
    "task_id": "494",
    "filename": "program_494.py",
    "code": "def lcm(x, y):\n   if x > y:\n       z = x\n   else:\n       z = y\n   while(True):\n       if((z % x == 0) and (z % y == 0)):\n           lcm = z\n           break\n       z += 1\n   return lcm"
  },
  {
    "task_id": "498",
    "filename": "program_498.py",
    "code": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list"
  },
  {
    "task_id": "500",
    "filename": "program_500.py",
    "code": "def remove_negs(num_list):\n    for item in num_list:\n        if item < 0:\n           num_list.remove(item)\n    return num_list"
  }
]